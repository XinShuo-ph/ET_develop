/*@@
   @file    AliasedFunctions.c
   @author  Automatically generated by CreateFunctionBindings.pl
   @desc
            Prototypes for the aliased functions.
   @enddesc
 @@*/


#include <stdlib.h>
#include <string.h>

#include "cctk_Flesh.h"
#include "cctk_WarnLevel.h"
#include "cctk_FortranString.h"

/*
 * The function pointers to be set
 */

static CCTK_INT (*Accelerator_Cycle_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*Accelerator_Cycle_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Accelerator_Cycle (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT Accelerator_Cycle (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!Accelerator_Cycle_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Accelerator_Cycle has not been provided by any active thorn.");
  }

  retval = (*Accelerator_Cycle_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Accelerator_Cycle) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(Accelerator_Cycle) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!Accelerator_Cycle_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Accelerator_Cycle has not been provided by any active thorn.");
  }

  retval = (*Accelerator_Cycle_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedAccelerator_Cycle(void);
CCTK_INT IsAliasedAccelerator_Cycle(void)
{
  return (Accelerator_Cycle_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasAccelerator_Cycle_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasAccelerator_Cycle_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = Accelerator_Cycle_C_Wrapper != NULL;
  if (!aliased)
  {
    Accelerator_Cycle_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasAccelerator_Cycle_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasAccelerator_Cycle_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = Accelerator_Cycle_C_Wrapper != NULL;
  if (!aliased)
  {
    Accelerator_Cycle_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Accelerator_NotifyDataModified_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT nvariables ,
 const CCTK_INT on_device) = NULL;
static CCTK_INT (*Accelerator_NotifyDataModified_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT* nvariables ,
 const CCTK_INT* on_device) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Accelerator_NotifyDataModified (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT nvariables ,
 const CCTK_INT on_device);
CCTK_INT Accelerator_NotifyDataModified (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT nvariables ,
 const CCTK_INT on_device)
{
  CCTK_INT retval;

  if (!Accelerator_NotifyDataModified_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Accelerator_NotifyDataModified has not been provided by any active thorn.");
  }

  retval = (*Accelerator_NotifyDataModified_C_Wrapper)(cctkGH , variables , rls , tls , nvariables , on_device);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Accelerator_NotifyDataModified) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT* nvariables ,
 const CCTK_INT* on_device);
CCTK_INT CCTK_FCALL CCTK_FNAME(Accelerator_NotifyDataModified) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT* nvariables ,
 const CCTK_INT* on_device)
{
  CCTK_INT retval;

  if (!Accelerator_NotifyDataModified_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Accelerator_NotifyDataModified has not been provided by any active thorn.");
  }

  retval = (*Accelerator_NotifyDataModified_F_Wrapper)(cctkGH , variables , rls , tls , nvariables , on_device);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedAccelerator_NotifyDataModified(void);
CCTK_INT IsAliasedAccelerator_NotifyDataModified(void)
{
  return (Accelerator_NotifyDataModified_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasAccelerator_NotifyDataModified_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT nvariables ,
 const CCTK_INT on_device));
CCTK_INT AliasAccelerator_NotifyDataModified_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT nvariables ,
 const CCTK_INT on_device))
{
  CCTK_INT aliased = Accelerator_NotifyDataModified_C_Wrapper != NULL;
  if (!aliased)
  {
    Accelerator_NotifyDataModified_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasAccelerator_NotifyDataModified_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT* nvariables ,
 const CCTK_INT* on_device));
CCTK_INT AliasAccelerator_NotifyDataModified_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT* nvariables ,
 const CCTK_INT* on_device))
{
  CCTK_INT aliased = Accelerator_NotifyDataModified_C_Wrapper != NULL;
  if (!aliased)
  {
    Accelerator_NotifyDataModified_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Accelerator_PostCallFunction_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST attribute) = NULL;
static CCTK_INT (*Accelerator_PostCallFunction_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* attribute) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Accelerator_PostCallFunction (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST attribute);
CCTK_INT Accelerator_PostCallFunction (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST attribute)
{
  CCTK_INT retval;

  if (!Accelerator_PostCallFunction_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Accelerator_PostCallFunction has not been provided by any active thorn.");
  }

  retval = (*Accelerator_PostCallFunction_C_Wrapper)(cctkGH , attribute);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Accelerator_PostCallFunction) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* attribute);
CCTK_INT CCTK_FCALL CCTK_FNAME(Accelerator_PostCallFunction) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* attribute)
{
  CCTK_INT retval;

  if (!Accelerator_PostCallFunction_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Accelerator_PostCallFunction has not been provided by any active thorn.");
  }

  retval = (*Accelerator_PostCallFunction_F_Wrapper)(cctkGH , attribute);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedAccelerator_PostCallFunction(void);
CCTK_INT IsAliasedAccelerator_PostCallFunction(void)
{
  return (Accelerator_PostCallFunction_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasAccelerator_PostCallFunction_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST attribute));
CCTK_INT AliasAccelerator_PostCallFunction_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST attribute))
{
  CCTK_INT aliased = Accelerator_PostCallFunction_C_Wrapper != NULL;
  if (!aliased)
  {
    Accelerator_PostCallFunction_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasAccelerator_PostCallFunction_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* attribute));
CCTK_INT AliasAccelerator_PostCallFunction_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* attribute))
{
  CCTK_INT aliased = Accelerator_PostCallFunction_C_Wrapper != NULL;
  if (!aliased)
  {
    Accelerator_PostCallFunction_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Accelerator_PostSync_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT ngroups) = NULL;
static CCTK_INT (*Accelerator_PostSync_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT* ngroups) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Accelerator_PostSync (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT ngroups);
CCTK_INT Accelerator_PostSync (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT ngroups)
{
  CCTK_INT retval;

  if (!Accelerator_PostSync_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Accelerator_PostSync has not been provided by any active thorn.");
  }

  retval = (*Accelerator_PostSync_C_Wrapper)(cctkGH , groups , ngroups);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Accelerator_PostSync) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT* ngroups);
CCTK_INT CCTK_FCALL CCTK_FNAME(Accelerator_PostSync) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT* ngroups)
{
  CCTK_INT retval;

  if (!Accelerator_PostSync_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Accelerator_PostSync has not been provided by any active thorn.");
  }

  retval = (*Accelerator_PostSync_F_Wrapper)(cctkGH , groups , ngroups);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedAccelerator_PostSync(void);
CCTK_INT IsAliasedAccelerator_PostSync(void)
{
  return (Accelerator_PostSync_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasAccelerator_PostSync_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT ngroups));
CCTK_INT AliasAccelerator_PostSync_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT ngroups))
{
  CCTK_INT aliased = Accelerator_PostSync_C_Wrapper != NULL;
  if (!aliased)
  {
    Accelerator_PostSync_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasAccelerator_PostSync_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT* ngroups));
CCTK_INT AliasAccelerator_PostSync_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT* ngroups))
{
  CCTK_INT aliased = Accelerator_PostSync_C_Wrapper != NULL;
  if (!aliased)
  {
    Accelerator_PostSync_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Accelerator_PreCallFunction_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST attribute) = NULL;
static CCTK_INT (*Accelerator_PreCallFunction_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* attribute) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Accelerator_PreCallFunction (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST attribute);
CCTK_INT Accelerator_PreCallFunction (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST attribute)
{
  CCTK_INT retval;

  if (!Accelerator_PreCallFunction_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Accelerator_PreCallFunction has not been provided by any active thorn.");
  }

  retval = (*Accelerator_PreCallFunction_C_Wrapper)(cctkGH , attribute);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Accelerator_PreCallFunction) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* attribute);
CCTK_INT CCTK_FCALL CCTK_FNAME(Accelerator_PreCallFunction) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* attribute)
{
  CCTK_INT retval;

  if (!Accelerator_PreCallFunction_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Accelerator_PreCallFunction has not been provided by any active thorn.");
  }

  retval = (*Accelerator_PreCallFunction_F_Wrapper)(cctkGH , attribute);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedAccelerator_PreCallFunction(void);
CCTK_INT IsAliasedAccelerator_PreCallFunction(void)
{
  return (Accelerator_PreCallFunction_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasAccelerator_PreCallFunction_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST attribute));
CCTK_INT AliasAccelerator_PreCallFunction_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST attribute))
{
  CCTK_INT aliased = Accelerator_PreCallFunction_C_Wrapper != NULL;
  if (!aliased)
  {
    Accelerator_PreCallFunction_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasAccelerator_PreCallFunction_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* attribute));
CCTK_INT AliasAccelerator_PreCallFunction_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* attribute))
{
  CCTK_INT aliased = Accelerator_PreCallFunction_C_Wrapper != NULL;
  if (!aliased)
  {
    Accelerator_PreCallFunction_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Accelerator_PreSync_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT ngroups) = NULL;
static CCTK_INT (*Accelerator_PreSync_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT* ngroups) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Accelerator_PreSync (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT ngroups);
CCTK_INT Accelerator_PreSync (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT ngroups)
{
  CCTK_INT retval;

  if (!Accelerator_PreSync_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Accelerator_PreSync has not been provided by any active thorn.");
  }

  retval = (*Accelerator_PreSync_C_Wrapper)(cctkGH , groups , ngroups);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Accelerator_PreSync) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT* ngroups);
CCTK_INT CCTK_FCALL CCTK_FNAME(Accelerator_PreSync) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT* ngroups)
{
  CCTK_INT retval;

  if (!Accelerator_PreSync_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Accelerator_PreSync has not been provided by any active thorn.");
  }

  retval = (*Accelerator_PreSync_F_Wrapper)(cctkGH , groups , ngroups);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedAccelerator_PreSync(void);
CCTK_INT IsAliasedAccelerator_PreSync(void)
{
  return (Accelerator_PreSync_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasAccelerator_PreSync_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT ngroups));
CCTK_INT AliasAccelerator_PreSync_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT ngroups))
{
  CCTK_INT aliased = Accelerator_PreSync_C_Wrapper != NULL;
  if (!aliased)
  {
    Accelerator_PreSync_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasAccelerator_PreSync_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT* ngroups));
CCTK_INT AliasAccelerator_PreSync_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* groups ,
 const CCTK_INT* ngroups))
{
  CCTK_INT aliased = Accelerator_PreSync_C_Wrapper != NULL;
  if (!aliased)
  {
    Accelerator_PreSync_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Accelerator_RequireValidData_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT nvariables ,
 const CCTK_INT on_device) = NULL;
static CCTK_INT (*Accelerator_RequireValidData_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT* nvariables ,
 const CCTK_INT* on_device) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Accelerator_RequireValidData (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT nvariables ,
 const CCTK_INT on_device);
CCTK_INT Accelerator_RequireValidData (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT nvariables ,
 const CCTK_INT on_device)
{
  CCTK_INT retval;

  if (!Accelerator_RequireValidData_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Accelerator_RequireValidData has not been provided by any active thorn.");
  }

  retval = (*Accelerator_RequireValidData_C_Wrapper)(cctkGH , variables , rls , tls , nvariables , on_device);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Accelerator_RequireValidData) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT* nvariables ,
 const CCTK_INT* on_device);
CCTK_INT CCTK_FCALL CCTK_FNAME(Accelerator_RequireValidData) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT* nvariables ,
 const CCTK_INT* on_device)
{
  CCTK_INT retval;

  if (!Accelerator_RequireValidData_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Accelerator_RequireValidData has not been provided by any active thorn.");
  }

  retval = (*Accelerator_RequireValidData_F_Wrapper)(cctkGH , variables , rls , tls , nvariables , on_device);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedAccelerator_RequireValidData(void);
CCTK_INT IsAliasedAccelerator_RequireValidData(void)
{
  return (Accelerator_RequireValidData_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasAccelerator_RequireValidData_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT nvariables ,
 const CCTK_INT on_device));
CCTK_INT AliasAccelerator_RequireValidData_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT nvariables ,
 const CCTK_INT on_device))
{
  CCTK_INT aliased = Accelerator_RequireValidData_C_Wrapper != NULL;
  if (!aliased)
  {
    Accelerator_RequireValidData_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasAccelerator_RequireValidData_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT* nvariables ,
 const CCTK_INT* on_device));
CCTK_INT AliasAccelerator_RequireValidData_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* rls ,
 const CCTK_INT* tls ,
 const CCTK_INT* nvariables ,
 const CCTK_INT* on_device))
{
  CCTK_INT aliased = Accelerator_RequireValidData_C_Wrapper != NULL;
  if (!aliased)
  {
    Accelerator_RequireValidData_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Boundary_RegisterPhysicalBC_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name) = NULL;
static CCTK_INT (*Boundary_RegisterPhysicalBC_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Boundary_RegisterPhysicalBC (const CCTK_POINTER_TO_CONST GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name);
CCTK_INT Boundary_RegisterPhysicalBC (const CCTK_POINTER_TO_CONST GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name)
{
  CCTK_INT retval;

  if (!Boundary_RegisterPhysicalBC_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_RegisterPhysicalBC has not been provided by any active thorn.");
  }

  retval = (*Boundary_RegisterPhysicalBC_C_Wrapper)(GH , function_pointer , bc_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_RegisterPhysicalBC) (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_RegisterPhysicalBC) (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Boundary_RegisterPhysicalBC_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_RegisterPhysicalBC has not been provided by any active thorn.");
  }

  retval = (*Boundary_RegisterPhysicalBC_F_Wrapper)(GH , function_pointer , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedBoundary_RegisterPhysicalBC(void);
CCTK_INT IsAliasedBoundary_RegisterPhysicalBC(void)
{
  return (Boundary_RegisterPhysicalBC_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasBoundary_RegisterPhysicalBC_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_RegisterPhysicalBC_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_RegisterPhysicalBC_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_RegisterPhysicalBC_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasBoundary_RegisterPhysicalBC_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_RegisterPhysicalBC_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_RegisterPhysicalBC_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_RegisterPhysicalBC_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Boundary_SelectGroupForBC_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING group_name, CCTK_STRING bc_name) = NULL;
static CCTK_INT (*Boundary_SelectGroupForBC_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 CCTK_STRING group_name, CCTK_STRING bc_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Boundary_SelectGroupForBC (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING group_name, CCTK_STRING bc_name);
CCTK_INT Boundary_SelectGroupForBC (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING group_name, CCTK_STRING bc_name)
{
  CCTK_INT retval;

  if (!Boundary_SelectGroupForBC_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectGroupForBC has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectGroupForBC_C_Wrapper)(GH , faces , boundary_width , table_handle , group_name , bc_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectGroupForBC) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 TWO_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectGroupForBC) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 TWO_FORTSTRING_ARG)
{
  CCTK_INT retval;

  TWO_FORTSTRING_CREATE(cctki_string1,cctki_string2)

  if (!Boundary_SelectGroupForBC_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectGroupForBC has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectGroupForBC_F_Wrapper)(GH , faces , boundary_width , table_handle , cctki_string1,cctki_string2);
  free(cctki_string1);
  free(cctki_string2);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedBoundary_SelectGroupForBC(void);
CCTK_INT IsAliasedBoundary_SelectGroupForBC(void)
{
  return (Boundary_SelectGroupForBC_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasBoundary_SelectGroupForBC_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING group_name, CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectGroupForBC_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING group_name, CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectGroupForBC_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectGroupForBC_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasBoundary_SelectGroupForBC_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 CCTK_STRING group_name, CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectGroupForBC_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 CCTK_STRING group_name, CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectGroupForBC_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectGroupForBC_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Boundary_SelectGroupForBCI_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT group_index ,
 CCTK_STRING bc_name) = NULL;
static CCTK_INT (*Boundary_SelectGroupForBCI_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* group_index ,
 CCTK_STRING bc_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Boundary_SelectGroupForBCI (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT group_index ,
 CCTK_STRING bc_name);
CCTK_INT Boundary_SelectGroupForBCI (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT group_index ,
 CCTK_STRING bc_name)
{
  CCTK_INT retval;

  if (!Boundary_SelectGroupForBCI_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectGroupForBCI has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectGroupForBCI_C_Wrapper)(GH , faces , boundary_width , table_handle , group_index , bc_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectGroupForBCI) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* group_index ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectGroupForBCI) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* group_index ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Boundary_SelectGroupForBCI_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectGroupForBCI has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectGroupForBCI_F_Wrapper)(GH , faces , boundary_width , table_handle , group_index , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedBoundary_SelectGroupForBCI(void);
CCTK_INT IsAliasedBoundary_SelectGroupForBCI(void)
{
  return (Boundary_SelectGroupForBCI_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasBoundary_SelectGroupForBCI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT group_index ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectGroupForBCI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT group_index ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectGroupForBCI_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectGroupForBCI_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasBoundary_SelectGroupForBCI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* group_index ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectGroupForBCI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* group_index ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectGroupForBCI_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectGroupForBCI_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Boundary_SelectVarForBC_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name) = NULL;
static CCTK_INT (*Boundary_SelectVarForBC_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Boundary_SelectVarForBC (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name);
CCTK_INT Boundary_SelectVarForBC (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name)
{
  CCTK_INT retval;

  if (!Boundary_SelectVarForBC_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectVarForBC has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectVarForBC_C_Wrapper)(GH , faces , boundary_width , table_handle , var_name , bc_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectVarForBC) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 TWO_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectVarForBC) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 TWO_FORTSTRING_ARG)
{
  CCTK_INT retval;

  TWO_FORTSTRING_CREATE(cctki_string1,cctki_string2)

  if (!Boundary_SelectVarForBC_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectVarForBC has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectVarForBC_F_Wrapper)(GH , faces , boundary_width , table_handle , cctki_string1,cctki_string2);
  free(cctki_string1);
  free(cctki_string2);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedBoundary_SelectVarForBC(void);
CCTK_INT IsAliasedBoundary_SelectVarForBC(void)
{
  return (Boundary_SelectVarForBC_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasBoundary_SelectVarForBC_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectVarForBC_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectVarForBC_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectVarForBC_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasBoundary_SelectVarForBC_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectVarForBC_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectVarForBC_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectVarForBC_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Boundary_SelectVarForBCI_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT var_index ,
 CCTK_STRING bc_name) = NULL;
static CCTK_INT (*Boundary_SelectVarForBCI_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* var_index ,
 CCTK_STRING bc_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Boundary_SelectVarForBCI (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT var_index ,
 CCTK_STRING bc_name);
CCTK_INT Boundary_SelectVarForBCI (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT var_index ,
 CCTK_STRING bc_name)
{
  CCTK_INT retval;

  if (!Boundary_SelectVarForBCI_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectVarForBCI has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectVarForBCI_C_Wrapper)(GH , faces , boundary_width , table_handle , var_index , bc_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectVarForBCI) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* var_index ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectVarForBCI) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* var_index ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Boundary_SelectVarForBCI_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectVarForBCI has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectVarForBCI_F_Wrapper)(GH , faces , boundary_width , table_handle , var_index , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedBoundary_SelectVarForBCI(void);
CCTK_INT IsAliasedBoundary_SelectVarForBCI(void)
{
  return (Boundary_SelectVarForBCI_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasBoundary_SelectVarForBCI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT var_index ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectVarForBCI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT var_index ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectVarForBCI_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectVarForBCI_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasBoundary_SelectVarForBCI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* var_index ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectVarForBCI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* var_index ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectVarForBCI_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectVarForBCI_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Boundary_SelectedGVs_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name) = NULL;
static CCTK_INT (*Boundary_SelectedGVs_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Boundary_SelectedGVs (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name);
CCTK_INT Boundary_SelectedGVs (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name)
{
  CCTK_INT retval;

  if (!Boundary_SelectedGVs_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectedGVs has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectedGVs_C_Wrapper)(GH , array_size , var_indicies , faces , boundary_widths , table_handles , bc_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectedGVs) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectedGVs) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Boundary_SelectedGVs_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectedGVs has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectedGVs_F_Wrapper)(GH , array_size , var_indicies , faces , boundary_widths , table_handles , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedBoundary_SelectedGVs(void);
CCTK_INT IsAliasedBoundary_SelectedGVs(void)
{
  return (Boundary_SelectedGVs_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasBoundary_SelectedGVs_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectedGVs_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectedGVs_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectedGVs_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasBoundary_SelectedGVs_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectedGVs_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectedGVs_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectedGVs_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*CCTK_MyHost_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*CCTK_MyHost_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT CCTK_MyHost (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT CCTK_MyHost (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!CCTK_MyHost_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function CCTK_MyHost has not been provided by any active thorn.");
  }

  retval = (*CCTK_MyHost_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(CCTK_MyHost) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(CCTK_MyHost) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!CCTK_MyHost_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function CCTK_MyHost has not been provided by any active thorn.");
  }

  retval = (*CCTK_MyHost_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCCTK_MyHost(void);
CCTK_INT IsAliasedCCTK_MyHost(void)
{
  return (CCTK_MyHost_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCCTK_MyHost_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasCCTK_MyHost_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = CCTK_MyHost_C_Wrapper != NULL;
  if (!aliased)
  {
    CCTK_MyHost_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCCTK_MyHost_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasCCTK_MyHost_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = CCTK_MyHost_C_Wrapper != NULL;
  if (!aliased)
  {
    CCTK_MyHost_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*CCTK_ProcsOnHost_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT host ,
 CCTK_INT* procs ,
 const CCTK_INT nprocs) = NULL;
static CCTK_INT (*CCTK_ProcsOnHost_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* host ,
 CCTK_INT* procs ,
 const CCTK_INT* nprocs) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT CCTK_ProcsOnHost (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT host ,
 CCTK_INT* procs ,
 const CCTK_INT nprocs);
CCTK_INT CCTK_ProcsOnHost (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT host ,
 CCTK_INT* procs ,
 const CCTK_INT nprocs)
{
  CCTK_INT retval;

  if (!CCTK_ProcsOnHost_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function CCTK_ProcsOnHost has not been provided by any active thorn.");
  }

  retval = (*CCTK_ProcsOnHost_C_Wrapper)(cctkGH , host , procs , nprocs);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(CCTK_ProcsOnHost) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* host ,
 CCTK_INT* procs ,
 const CCTK_INT* nprocs);
CCTK_INT CCTK_FCALL CCTK_FNAME(CCTK_ProcsOnHost) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* host ,
 CCTK_INT* procs ,
 const CCTK_INT* nprocs)
{
  CCTK_INT retval;

  if (!CCTK_ProcsOnHost_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function CCTK_ProcsOnHost has not been provided by any active thorn.");
  }

  retval = (*CCTK_ProcsOnHost_F_Wrapper)(cctkGH , host , procs , nprocs);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCCTK_ProcsOnHost(void);
CCTK_INT IsAliasedCCTK_ProcsOnHost(void)
{
  return (CCTK_ProcsOnHost_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCCTK_ProcsOnHost_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT host ,
 CCTK_INT* procs ,
 const CCTK_INT nprocs));
CCTK_INT AliasCCTK_ProcsOnHost_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT host ,
 CCTK_INT* procs ,
 const CCTK_INT nprocs))
{
  CCTK_INT aliased = CCTK_ProcsOnHost_C_Wrapper != NULL;
  if (!aliased)
  {
    CCTK_ProcsOnHost_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCCTK_ProcsOnHost_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* host ,
 CCTK_INT* procs ,
 const CCTK_INT* nprocs));
CCTK_INT AliasCCTK_ProcsOnHost_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* host ,
 CCTK_INT* procs ,
 const CCTK_INT* nprocs))
{
  CCTK_INT aliased = CCTK_ProcsOnHost_C_Wrapper != NULL;
  if (!aliased)
  {
    CCTK_ProcsOnHost_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*CCTK_nHosts_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*CCTK_nHosts_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT CCTK_nHosts (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT CCTK_nHosts (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!CCTK_nHosts_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function CCTK_nHosts has not been provided by any active thorn.");
  }

  retval = (*CCTK_nHosts_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(CCTK_nHosts) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(CCTK_nHosts) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!CCTK_nHosts_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function CCTK_nHosts has not been provided by any active thorn.");
  }

  retval = (*CCTK_nHosts_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCCTK_nHosts(void);
CCTK_INT IsAliasedCCTK_nHosts(void)
{
  return (CCTK_nHosts_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCCTK_nHosts_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasCCTK_nHosts_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = CCTK_nHosts_C_Wrapper != NULL;
  if (!aliased)
  {
    CCTK_nHosts_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCCTK_nHosts_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasCCTK_nHosts_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = CCTK_nHosts_C_Wrapper != NULL;
  if (!aliased)
  {
    CCTK_nHosts_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*CCTK_nProcsOnHost_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT host) = NULL;
static CCTK_INT (*CCTK_nProcsOnHost_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* host) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT CCTK_nProcsOnHost (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT host);
CCTK_INT CCTK_nProcsOnHost (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT host)
{
  CCTK_INT retval;

  if (!CCTK_nProcsOnHost_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function CCTK_nProcsOnHost has not been provided by any active thorn.");
  }

  retval = (*CCTK_nProcsOnHost_C_Wrapper)(cctkGH , host);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(CCTK_nProcsOnHost) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* host);
CCTK_INT CCTK_FCALL CCTK_FNAME(CCTK_nProcsOnHost) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* host)
{
  CCTK_INT retval;

  if (!CCTK_nProcsOnHost_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function CCTK_nProcsOnHost has not been provided by any active thorn.");
  }

  retval = (*CCTK_nProcsOnHost_F_Wrapper)(cctkGH , host);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCCTK_nProcsOnHost(void);
CCTK_INT IsAliasedCCTK_nProcsOnHost(void)
{
  return (CCTK_nProcsOnHost_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCCTK_nProcsOnHost_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT host));
CCTK_INT AliasCCTK_nProcsOnHost_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT host))
{
  CCTK_INT aliased = CCTK_nProcsOnHost_C_Wrapper != NULL;
  if (!aliased)
  {
    CCTK_nProcsOnHost_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCCTK_nProcsOnHost_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* host));
CCTK_INT AliasCCTK_nProcsOnHost_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* host))
{
  CCTK_INT aliased = CCTK_nProcsOnHost_C_Wrapper != NULL;
  if (!aliased)
  {
    CCTK_nProcsOnHost_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Carpet_Regrid_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregss ,
 const CCTK_POINTER regsss ,
 const CCTK_INT force) = NULL;
static CCTK_INT (*Carpet_Regrid_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregss ,
 const CCTK_POINTER* regsss ,
 const CCTK_INT* force) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Carpet_Regrid (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregss ,
 const CCTK_POINTER regsss ,
 const CCTK_INT force);
CCTK_INT Carpet_Regrid (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregss ,
 const CCTK_POINTER regsss ,
 const CCTK_INT force)
{
  CCTK_INT retval;

  if (!Carpet_Regrid_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Carpet_Regrid has not been provided by any active thorn.");
  }

  retval = (*Carpet_Regrid_C_Wrapper)(cctkGH , superregss , regsss , force);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Carpet_Regrid) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregss ,
 const CCTK_POINTER* regsss ,
 const CCTK_INT* force);
CCTK_INT CCTK_FCALL CCTK_FNAME(Carpet_Regrid) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregss ,
 const CCTK_POINTER* regsss ,
 const CCTK_INT* force)
{
  CCTK_INT retval;

  if (!Carpet_Regrid_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Carpet_Regrid has not been provided by any active thorn.");
  }

  retval = (*Carpet_Regrid_F_Wrapper)(cctkGH , superregss , regsss , force);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCarpet_Regrid(void);
CCTK_INT IsAliasedCarpet_Regrid(void)
{
  return (Carpet_Regrid_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCarpet_Regrid_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregss ,
 const CCTK_POINTER regsss ,
 const CCTK_INT force));
CCTK_INT AliasCarpet_Regrid_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregss ,
 const CCTK_POINTER regsss ,
 const CCTK_INT force))
{
  CCTK_INT aliased = Carpet_Regrid_C_Wrapper != NULL;
  if (!aliased)
  {
    Carpet_Regrid_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCarpet_Regrid_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregss ,
 const CCTK_POINTER* regsss ,
 const CCTK_INT* force));
CCTK_INT AliasCarpet_Regrid_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregss ,
 const CCTK_POINTER* regsss ,
 const CCTK_INT* force))
{
  CCTK_INT aliased = Carpet_Regrid_C_Wrapper != NULL;
  if (!aliased)
  {
    Carpet_Regrid_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Carpet_RegridMaps_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregsss ,
 const CCTK_POINTER regssss ,
 const CCTK_INT force) = NULL;
static CCTK_INT (*Carpet_RegridMaps_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregsss ,
 const CCTK_POINTER* regssss ,
 const CCTK_INT* force) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Carpet_RegridMaps (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregsss ,
 const CCTK_POINTER regssss ,
 const CCTK_INT force);
CCTK_INT Carpet_RegridMaps (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregsss ,
 const CCTK_POINTER regssss ,
 const CCTK_INT force)
{
  CCTK_INT retval;

  if (!Carpet_RegridMaps_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Carpet_RegridMaps has not been provided by any active thorn.");
  }

  retval = (*Carpet_RegridMaps_C_Wrapper)(cctkGH , superregsss , regssss , force);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Carpet_RegridMaps) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregsss ,
 const CCTK_POINTER* regssss ,
 const CCTK_INT* force);
CCTK_INT CCTK_FCALL CCTK_FNAME(Carpet_RegridMaps) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregsss ,
 const CCTK_POINTER* regssss ,
 const CCTK_INT* force)
{
  CCTK_INT retval;

  if (!Carpet_RegridMaps_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Carpet_RegridMaps has not been provided by any active thorn.");
  }

  retval = (*Carpet_RegridMaps_F_Wrapper)(cctkGH , superregsss , regssss , force);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCarpet_RegridMaps(void);
CCTK_INT IsAliasedCarpet_RegridMaps(void)
{
  return (Carpet_RegridMaps_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCarpet_RegridMaps_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregsss ,
 const CCTK_POINTER regssss ,
 const CCTK_INT force));
CCTK_INT AliasCarpet_RegridMaps_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregsss ,
 const CCTK_POINTER regssss ,
 const CCTK_INT force))
{
  CCTK_INT aliased = Carpet_RegridMaps_C_Wrapper != NULL;
  if (!aliased)
  {
    Carpet_RegridMaps_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCarpet_RegridMaps_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregsss ,
 const CCTK_POINTER* regssss ,
 const CCTK_INT* force));
CCTK_INT AliasCarpet_RegridMaps_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregsss ,
 const CCTK_POINTER* regssss ,
 const CCTK_INT* force))
{
  CCTK_INT aliased = Carpet_RegridMaps_C_Wrapper != NULL;
  if (!aliased)
  {
    Carpet_RegridMaps_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*CartToSphere_C_Wrapper) (const CCTK_INT* lsh ,
 const CCTK_INT r2norm ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 const CCTK_REAL* cart_xx ,
 const CCTK_REAL* cart_xy ,
 const CCTK_REAL* cart_xz ,
 const CCTK_REAL* cart_yy ,
 const CCTK_REAL* cart_yz ,
 const CCTK_REAL* cart_zz ,
 CCTK_REAL* sphere_rr ,
 CCTK_REAL* sphere_rq ,
 CCTK_REAL* sphere_rp ,
 CCTK_REAL* sphere_qq ,
 CCTK_REAL* sphere_qp ,
 CCTK_REAL* sphere_pp) = NULL;
static void (*CartToSphere_F_Wrapper) (const CCTK_INT* lsh ,
 const CCTK_INT* r2norm ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 const CCTK_REAL* cart_xx ,
 const CCTK_REAL* cart_xy ,
 const CCTK_REAL* cart_xz ,
 const CCTK_REAL* cart_yy ,
 const CCTK_REAL* cart_yz ,
 const CCTK_REAL* cart_zz ,
 CCTK_REAL* sphere_rr ,
 CCTK_REAL* sphere_rq ,
 CCTK_REAL* sphere_rp ,
 CCTK_REAL* sphere_qq ,
 CCTK_REAL* sphere_qp ,
 CCTK_REAL* sphere_pp) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void CartToSphere (const CCTK_INT* lsh ,
 const CCTK_INT r2norm ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 const CCTK_REAL* cart_xx ,
 const CCTK_REAL* cart_xy ,
 const CCTK_REAL* cart_xz ,
 const CCTK_REAL* cart_yy ,
 const CCTK_REAL* cart_yz ,
 const CCTK_REAL* cart_zz ,
 CCTK_REAL* sphere_rr ,
 CCTK_REAL* sphere_rq ,
 CCTK_REAL* sphere_rp ,
 CCTK_REAL* sphere_qq ,
 CCTK_REAL* sphere_qp ,
 CCTK_REAL* sphere_pp);
void CartToSphere (const CCTK_INT* lsh ,
 const CCTK_INT r2norm ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 const CCTK_REAL* cart_xx ,
 const CCTK_REAL* cart_xy ,
 const CCTK_REAL* cart_xz ,
 const CCTK_REAL* cart_yy ,
 const CCTK_REAL* cart_yz ,
 const CCTK_REAL* cart_zz ,
 CCTK_REAL* sphere_rr ,
 CCTK_REAL* sphere_rq ,
 CCTK_REAL* sphere_rp ,
 CCTK_REAL* sphere_qq ,
 CCTK_REAL* sphere_qp ,
 CCTK_REAL* sphere_pp)
{
  if (!CartToSphere_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function CartToSphere has not been provided by any active thorn.");
  }

  (*CartToSphere_C_Wrapper)(lsh , r2norm , x , y , z , r , cart_xx , cart_xy , cart_xz , cart_yy , cart_yz , cart_zz , sphere_rr , sphere_rq , sphere_rp , sphere_qq , sphere_qp , sphere_pp);
}

void CCTK_FCALL CCTK_FNAME(CartToSphere) (const CCTK_INT* lsh ,
 const CCTK_INT* r2norm ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 const CCTK_REAL* cart_xx ,
 const CCTK_REAL* cart_xy ,
 const CCTK_REAL* cart_xz ,
 const CCTK_REAL* cart_yy ,
 const CCTK_REAL* cart_yz ,
 const CCTK_REAL* cart_zz ,
 CCTK_REAL* sphere_rr ,
 CCTK_REAL* sphere_rq ,
 CCTK_REAL* sphere_rp ,
 CCTK_REAL* sphere_qq ,
 CCTK_REAL* sphere_qp ,
 CCTK_REAL* sphere_pp);
void CCTK_FCALL CCTK_FNAME(CartToSphere) (const CCTK_INT* lsh ,
 const CCTK_INT* r2norm ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 const CCTK_REAL* cart_xx ,
 const CCTK_REAL* cart_xy ,
 const CCTK_REAL* cart_xz ,
 const CCTK_REAL* cart_yy ,
 const CCTK_REAL* cart_yz ,
 const CCTK_REAL* cart_zz ,
 CCTK_REAL* sphere_rr ,
 CCTK_REAL* sphere_rq ,
 CCTK_REAL* sphere_rp ,
 CCTK_REAL* sphere_qq ,
 CCTK_REAL* sphere_qp ,
 CCTK_REAL* sphere_pp)
{
  if (!CartToSphere_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function CartToSphere has not been provided by any active thorn.");
  }

  (*CartToSphere_F_Wrapper)(lsh , r2norm , x , y , z , r , cart_xx , cart_xy , cart_xz , cart_yy , cart_yz , cart_zz , sphere_rr , sphere_rq , sphere_rp , sphere_qq , sphere_qp , sphere_pp);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCartToSphere(void);
CCTK_INT IsAliasedCartToSphere(void)
{
  return (CartToSphere_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCartToSphere_C(void (*func)(const CCTK_INT* lsh ,
 const CCTK_INT r2norm ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 const CCTK_REAL* cart_xx ,
 const CCTK_REAL* cart_xy ,
 const CCTK_REAL* cart_xz ,
 const CCTK_REAL* cart_yy ,
 const CCTK_REAL* cart_yz ,
 const CCTK_REAL* cart_zz ,
 CCTK_REAL* sphere_rr ,
 CCTK_REAL* sphere_rq ,
 CCTK_REAL* sphere_rp ,
 CCTK_REAL* sphere_qq ,
 CCTK_REAL* sphere_qp ,
 CCTK_REAL* sphere_pp));
CCTK_INT AliasCartToSphere_C(void (*func)(const CCTK_INT* lsh ,
 const CCTK_INT r2norm ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 const CCTK_REAL* cart_xx ,
 const CCTK_REAL* cart_xy ,
 const CCTK_REAL* cart_xz ,
 const CCTK_REAL* cart_yy ,
 const CCTK_REAL* cart_yz ,
 const CCTK_REAL* cart_zz ,
 CCTK_REAL* sphere_rr ,
 CCTK_REAL* sphere_rq ,
 CCTK_REAL* sphere_rp ,
 CCTK_REAL* sphere_qq ,
 CCTK_REAL* sphere_qp ,
 CCTK_REAL* sphere_pp))
{
  CCTK_INT aliased = CartToSphere_C_Wrapper != NULL;
  if (!aliased)
  {
    CartToSphere_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCartToSphere_F(void (*func)(const CCTK_INT* lsh ,
 const CCTK_INT* r2norm ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 const CCTK_REAL* cart_xx ,
 const CCTK_REAL* cart_xy ,
 const CCTK_REAL* cart_xz ,
 const CCTK_REAL* cart_yy ,
 const CCTK_REAL* cart_yz ,
 const CCTK_REAL* cart_zz ,
 CCTK_REAL* sphere_rr ,
 CCTK_REAL* sphere_rq ,
 CCTK_REAL* sphere_rp ,
 CCTK_REAL* sphere_qq ,
 CCTK_REAL* sphere_qp ,
 CCTK_REAL* sphere_pp));
CCTK_INT AliasCartToSphere_F(void (*func)(const CCTK_INT* lsh ,
 const CCTK_INT* r2norm ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 const CCTK_REAL* cart_xx ,
 const CCTK_REAL* cart_xy ,
 const CCTK_REAL* cart_xz ,
 const CCTK_REAL* cart_yy ,
 const CCTK_REAL* cart_yz ,
 const CCTK_REAL* cart_zz ,
 CCTK_REAL* sphere_rr ,
 CCTK_REAL* sphere_rq ,
 CCTK_REAL* sphere_rp ,
 CCTK_REAL* sphere_qq ,
 CCTK_REAL* sphere_qp ,
 CCTK_REAL* sphere_pp))
{
  CCTK_INT aliased = CartToSphere_C_Wrapper != NULL;
  if (!aliased)
  {
    CartToSphere_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*CheckVarsForNaN_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found) = NULL;
static CCTK_INT (*CheckVarsForNaN_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT CheckVarsForNaN (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found);
CCTK_INT CheckVarsForNaN (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found)
{
  CCTK_INT retval;

  if (!CheckVarsForNaN_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function CheckVarsForNaN has not been provided by any active thorn.");
  }

  retval = (*CheckVarsForNaN_C_Wrapper)(cctkGH , report_max , vars , check_for , action_if_found);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(CheckVarsForNaN) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* report_max ,
 THREE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(CheckVarsForNaN) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* report_max ,
 THREE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  THREE_FORTSTRING_CREATE(cctki_string1,cctki_string2,cctki_string3)

  if (!CheckVarsForNaN_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function CheckVarsForNaN has not been provided by any active thorn.");
  }

  retval = (*CheckVarsForNaN_F_Wrapper)(cctkGH , report_max , cctki_string1,cctki_string2,cctki_string3);
  free(cctki_string1);
  free(cctki_string2);
  free(cctki_string3);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCheckVarsForNaN(void);
CCTK_INT IsAliasedCheckVarsForNaN(void)
{
  return (CheckVarsForNaN_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCheckVarsForNaN_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found));
CCTK_INT AliasCheckVarsForNaN_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found))
{
  CCTK_INT aliased = CheckVarsForNaN_C_Wrapper != NULL;
  if (!aliased)
  {
    CheckVarsForNaN_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCheckVarsForNaN_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found));
CCTK_INT AliasCheckVarsForNaN_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found))
{
  CCTK_INT aliased = CheckVarsForNaN_C_Wrapper != NULL;
  if (!aliased)
  {
    CheckVarsForNaN_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*Con2PrimGen_C_Wrapper) (const CCTK_INT handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z ,
 const CCTK_REAL r ,
 CCTK_INT* epsnegative ,
 const CCTK_REAL GRHydro_rho_min ,
 const CCTK_REAL pmin ,
 const CCTK_REAL epsmin ,
 const CCTK_INT GRHydro_reflevel ,
 CCTK_REAL* retval) = NULL;
static void (*Con2PrimGen_F_Wrapper) (const CCTK_INT* handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 CCTK_INT* epsnegative ,
 const CCTK_REAL* GRHydro_rho_min ,
 const CCTK_REAL* pmin ,
 const CCTK_REAL* epsmin ,
 const CCTK_INT* GRHydro_reflevel ,
 CCTK_REAL* retval) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void Con2PrimGen (const CCTK_INT handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z ,
 const CCTK_REAL r ,
 CCTK_INT* epsnegative ,
 const CCTK_REAL GRHydro_rho_min ,
 const CCTK_REAL pmin ,
 const CCTK_REAL epsmin ,
 const CCTK_INT GRHydro_reflevel ,
 CCTK_REAL* retval);
void Con2PrimGen (const CCTK_INT handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z ,
 const CCTK_REAL r ,
 CCTK_INT* epsnegative ,
 const CCTK_REAL GRHydro_rho_min ,
 const CCTK_REAL pmin ,
 const CCTK_REAL epsmin ,
 const CCTK_INT GRHydro_reflevel ,
 CCTK_REAL* retval)
{
  if (!Con2PrimGen_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Con2PrimGen has not been provided by any active thorn.");
  }

  (*Con2PrimGen_C_Wrapper)(handle , dens , sx , sy , sz , tau , rho , velx , vely , velz , epsilon , pressure , w_lorentz , uxx , uxy , uxz , uyy , uyz , uzz , det , x , y , z , r , epsnegative , GRHydro_rho_min , pmin , epsmin , GRHydro_reflevel , retval);
}

void CCTK_FCALL CCTK_FNAME(Con2PrimGen) (const CCTK_INT* handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 CCTK_INT* epsnegative ,
 const CCTK_REAL* GRHydro_rho_min ,
 const CCTK_REAL* pmin ,
 const CCTK_REAL* epsmin ,
 const CCTK_INT* GRHydro_reflevel ,
 CCTK_REAL* retval);
void CCTK_FCALL CCTK_FNAME(Con2PrimGen) (const CCTK_INT* handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 CCTK_INT* epsnegative ,
 const CCTK_REAL* GRHydro_rho_min ,
 const CCTK_REAL* pmin ,
 const CCTK_REAL* epsmin ,
 const CCTK_INT* GRHydro_reflevel ,
 CCTK_REAL* retval)
{
  if (!Con2PrimGen_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Con2PrimGen has not been provided by any active thorn.");
  }

  (*Con2PrimGen_F_Wrapper)(handle , dens , sx , sy , sz , tau , rho , velx , vely , velz , epsilon , pressure , w_lorentz , uxx , uxy , uxz , uyy , uyz , uzz , det , x , y , z , r , epsnegative , GRHydro_rho_min , pmin , epsmin , GRHydro_reflevel , retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCon2PrimGen(void);
CCTK_INT IsAliasedCon2PrimGen(void)
{
  return (Con2PrimGen_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCon2PrimGen_C(void (*func)(const CCTK_INT handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z ,
 const CCTK_REAL r ,
 CCTK_INT* epsnegative ,
 const CCTK_REAL GRHydro_rho_min ,
 const CCTK_REAL pmin ,
 const CCTK_REAL epsmin ,
 const CCTK_INT GRHydro_reflevel ,
 CCTK_REAL* retval));
CCTK_INT AliasCon2PrimGen_C(void (*func)(const CCTK_INT handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z ,
 const CCTK_REAL r ,
 CCTK_INT* epsnegative ,
 const CCTK_REAL GRHydro_rho_min ,
 const CCTK_REAL pmin ,
 const CCTK_REAL epsmin ,
 const CCTK_INT GRHydro_reflevel ,
 CCTK_REAL* retval))
{
  CCTK_INT aliased = Con2PrimGen_C_Wrapper != NULL;
  if (!aliased)
  {
    Con2PrimGen_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCon2PrimGen_F(void (*func)(const CCTK_INT* handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 CCTK_INT* epsnegative ,
 const CCTK_REAL* GRHydro_rho_min ,
 const CCTK_REAL* pmin ,
 const CCTK_REAL* epsmin ,
 const CCTK_INT* GRHydro_reflevel ,
 CCTK_REAL* retval));
CCTK_INT AliasCon2PrimGen_F(void (*func)(const CCTK_INT* handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 CCTK_INT* epsnegative ,
 const CCTK_REAL* GRHydro_rho_min ,
 const CCTK_REAL* pmin ,
 const CCTK_REAL* epsmin ,
 const CCTK_INT* GRHydro_reflevel ,
 CCTK_REAL* retval))
{
  CCTK_INT aliased = Con2PrimGen_C_Wrapper != NULL;
  if (!aliased)
  {
    Con2PrimGen_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*Con2PrimGenM_C_Wrapper) (const CCTK_INT handle ,
 const CCTK_INT keytemp ,
 const CCTK_REAL prec ,
 const CCTK_REAL gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL Bconsx ,
 const CCTK_REAL Bconsy ,
 const CCTK_REAL Bconsz ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval) = NULL;
static void (*Con2PrimGenM_F_Wrapper) (const CCTK_INT* handle ,
 const CCTK_INT* keytemp ,
 const CCTK_REAL* prec ,
 const CCTK_REAL* gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* Bconsx ,
 const CCTK_REAL* Bconsy ,
 const CCTK_REAL* Bconsz ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void Con2PrimGenM (const CCTK_INT handle ,
 const CCTK_INT keytemp ,
 const CCTK_REAL prec ,
 const CCTK_REAL gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL Bconsx ,
 const CCTK_REAL Bconsy ,
 const CCTK_REAL Bconsz ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval);
void Con2PrimGenM (const CCTK_INT handle ,
 const CCTK_INT keytemp ,
 const CCTK_REAL prec ,
 const CCTK_REAL gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL Bconsx ,
 const CCTK_REAL Bconsy ,
 const CCTK_REAL Bconsz ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval)
{
  if (!Con2PrimGenM_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Con2PrimGenM has not been provided by any active thorn.");
  }

  (*Con2PrimGenM_C_Wrapper)(handle , keytemp , prec , gamma_eos , dens , sx , sy , sz , tau , Bconsx , Bconsy , Bconsz , y_e , temp , rho , velx , vely , velz , epsilon , pressure , Bvecx , Bvecy , Bvecz , bvecsq , w_lorentz , gxx , gxy , gxz , gyy , gyz , gzz , uxx , uxy , uxz , uyy , uyz , uzz , det , epsnegative , retval);
}

void CCTK_FCALL CCTK_FNAME(Con2PrimGenM) (const CCTK_INT* handle ,
 const CCTK_INT* keytemp ,
 const CCTK_REAL* prec ,
 const CCTK_REAL* gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* Bconsx ,
 const CCTK_REAL* Bconsy ,
 const CCTK_REAL* Bconsz ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval);
void CCTK_FCALL CCTK_FNAME(Con2PrimGenM) (const CCTK_INT* handle ,
 const CCTK_INT* keytemp ,
 const CCTK_REAL* prec ,
 const CCTK_REAL* gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* Bconsx ,
 const CCTK_REAL* Bconsy ,
 const CCTK_REAL* Bconsz ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval)
{
  if (!Con2PrimGenM_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Con2PrimGenM has not been provided by any active thorn.");
  }

  (*Con2PrimGenM_F_Wrapper)(handle , keytemp , prec , gamma_eos , dens , sx , sy , sz , tau , Bconsx , Bconsy , Bconsz , y_e , temp , rho , velx , vely , velz , epsilon , pressure , Bvecx , Bvecy , Bvecz , bvecsq , w_lorentz , gxx , gxy , gxz , gyy , gyz , gzz , uxx , uxy , uxz , uyy , uyz , uzz , det , epsnegative , retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCon2PrimGenM(void);
CCTK_INT IsAliasedCon2PrimGenM(void)
{
  return (Con2PrimGenM_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCon2PrimGenM_C(void (*func)(const CCTK_INT handle ,
 const CCTK_INT keytemp ,
 const CCTK_REAL prec ,
 const CCTK_REAL gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL Bconsx ,
 const CCTK_REAL Bconsy ,
 const CCTK_REAL Bconsz ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval));
CCTK_INT AliasCon2PrimGenM_C(void (*func)(const CCTK_INT handle ,
 const CCTK_INT keytemp ,
 const CCTK_REAL prec ,
 const CCTK_REAL gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL Bconsx ,
 const CCTK_REAL Bconsy ,
 const CCTK_REAL Bconsz ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval))
{
  CCTK_INT aliased = Con2PrimGenM_C_Wrapper != NULL;
  if (!aliased)
  {
    Con2PrimGenM_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCon2PrimGenM_F(void (*func)(const CCTK_INT* handle ,
 const CCTK_INT* keytemp ,
 const CCTK_REAL* prec ,
 const CCTK_REAL* gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* Bconsx ,
 const CCTK_REAL* Bconsy ,
 const CCTK_REAL* Bconsz ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval));
CCTK_INT AliasCon2PrimGenM_F(void (*func)(const CCTK_INT* handle ,
 const CCTK_INT* keytemp ,
 const CCTK_REAL* prec ,
 const CCTK_REAL* gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* Bconsx ,
 const CCTK_REAL* Bconsy ,
 const CCTK_REAL* Bconsz ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval))
{
  CCTK_INT aliased = Con2PrimGenM_C_Wrapper != NULL;
  if (!aliased)
  {
    Con2PrimGenM_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*Con2PrimGenMee_C_Wrapper) (const CCTK_INT handle ,
 const CCTK_INT keytemp ,
 const CCTK_REAL prec ,
 const CCTK_REAL gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL Bconsx ,
 const CCTK_REAL Bconsy ,
 const CCTK_REAL Bconsz ,
 CCTK_REAL* entropycons ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval) = NULL;
static void (*Con2PrimGenMee_F_Wrapper) (const CCTK_INT* handle ,
 const CCTK_INT* keytemp ,
 const CCTK_REAL* prec ,
 const CCTK_REAL* gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* Bconsx ,
 const CCTK_REAL* Bconsy ,
 const CCTK_REAL* Bconsz ,
 CCTK_REAL* entropycons ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void Con2PrimGenMee (const CCTK_INT handle ,
 const CCTK_INT keytemp ,
 const CCTK_REAL prec ,
 const CCTK_REAL gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL Bconsx ,
 const CCTK_REAL Bconsy ,
 const CCTK_REAL Bconsz ,
 CCTK_REAL* entropycons ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval);
void Con2PrimGenMee (const CCTK_INT handle ,
 const CCTK_INT keytemp ,
 const CCTK_REAL prec ,
 const CCTK_REAL gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL Bconsx ,
 const CCTK_REAL Bconsy ,
 const CCTK_REAL Bconsz ,
 CCTK_REAL* entropycons ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval)
{
  if (!Con2PrimGenMee_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Con2PrimGenMee has not been provided by any active thorn.");
  }

  (*Con2PrimGenMee_C_Wrapper)(handle , keytemp , prec , gamma_eos , dens , sx , sy , sz , tau , Bconsx , Bconsy , Bconsz , entropycons , y_e , temp , rho , velx , vely , velz , epsilon , pressure , Bvecx , Bvecy , Bvecz , Bvecsq , w_lorentz , gxx , gxy , gxz , gyy , gyz , gzz , uxx , uxy , uxz , uyy , uyz , uzz , det , epsnegative , retval);
}

void CCTK_FCALL CCTK_FNAME(Con2PrimGenMee) (const CCTK_INT* handle ,
 const CCTK_INT* keytemp ,
 const CCTK_REAL* prec ,
 const CCTK_REAL* gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* Bconsx ,
 const CCTK_REAL* Bconsy ,
 const CCTK_REAL* Bconsz ,
 CCTK_REAL* entropycons ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval);
void CCTK_FCALL CCTK_FNAME(Con2PrimGenMee) (const CCTK_INT* handle ,
 const CCTK_INT* keytemp ,
 const CCTK_REAL* prec ,
 const CCTK_REAL* gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* Bconsx ,
 const CCTK_REAL* Bconsy ,
 const CCTK_REAL* Bconsz ,
 CCTK_REAL* entropycons ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval)
{
  if (!Con2PrimGenMee_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Con2PrimGenMee has not been provided by any active thorn.");
  }

  (*Con2PrimGenMee_F_Wrapper)(handle , keytemp , prec , gamma_eos , dens , sx , sy , sz , tau , Bconsx , Bconsy , Bconsz , entropycons , y_e , temp , rho , velx , vely , velz , epsilon , pressure , Bvecx , Bvecy , Bvecz , Bvecsq , w_lorentz , gxx , gxy , gxz , gyy , gyz , gzz , uxx , uxy , uxz , uyy , uyz , uzz , det , epsnegative , retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCon2PrimGenMee(void);
CCTK_INT IsAliasedCon2PrimGenMee(void)
{
  return (Con2PrimGenMee_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCon2PrimGenMee_C(void (*func)(const CCTK_INT handle ,
 const CCTK_INT keytemp ,
 const CCTK_REAL prec ,
 const CCTK_REAL gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL Bconsx ,
 const CCTK_REAL Bconsy ,
 const CCTK_REAL Bconsz ,
 CCTK_REAL* entropycons ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval));
CCTK_INT AliasCon2PrimGenMee_C(void (*func)(const CCTK_INT handle ,
 const CCTK_INT keytemp ,
 const CCTK_REAL prec ,
 const CCTK_REAL gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL Bconsx ,
 const CCTK_REAL Bconsy ,
 const CCTK_REAL Bconsz ,
 CCTK_REAL* entropycons ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval))
{
  CCTK_INT aliased = Con2PrimGenMee_C_Wrapper != NULL;
  if (!aliased)
  {
    Con2PrimGenMee_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCon2PrimGenMee_F(void (*func)(const CCTK_INT* handle ,
 const CCTK_INT* keytemp ,
 const CCTK_REAL* prec ,
 const CCTK_REAL* gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* Bconsx ,
 const CCTK_REAL* Bconsy ,
 const CCTK_REAL* Bconsz ,
 CCTK_REAL* entropycons ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval));
CCTK_INT AliasCon2PrimGenMee_F(void (*func)(const CCTK_INT* handle ,
 const CCTK_INT* keytemp ,
 const CCTK_REAL* prec ,
 const CCTK_REAL* gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* Bconsx ,
 const CCTK_REAL* Bconsy ,
 const CCTK_REAL* Bconsz ,
 CCTK_REAL* entropycons ,
 CCTK_REAL* y_e ,
 CCTK_REAL* temp ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval))
{
  CCTK_INT aliased = Con2PrimGenMee_C_Wrapper != NULL;
  if (!aliased)
  {
    Con2PrimGenMee_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*Con2PrimPoly_C_Wrapper) (const CCTK_INT handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z ,
 const CCTK_REAL r ,
 const CCTK_REAL rho_min ,
 const CCTK_INT GRHydro_reflevel ,
 CCTK_REAL* GRHydro_C2P_failed) = NULL;
static void (*Con2PrimPoly_F_Wrapper) (const CCTK_INT* handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 const CCTK_REAL* rho_min ,
 const CCTK_INT* GRHydro_reflevel ,
 CCTK_REAL* GRHydro_C2P_failed) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void Con2PrimPoly (const CCTK_INT handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z ,
 const CCTK_REAL r ,
 const CCTK_REAL rho_min ,
 const CCTK_INT GRHydro_reflevel ,
 CCTK_REAL* GRHydro_C2P_failed);
void Con2PrimPoly (const CCTK_INT handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z ,
 const CCTK_REAL r ,
 const CCTK_REAL rho_min ,
 const CCTK_INT GRHydro_reflevel ,
 CCTK_REAL* GRHydro_C2P_failed)
{
  if (!Con2PrimPoly_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Con2PrimPoly has not been provided by any active thorn.");
  }

  (*Con2PrimPoly_C_Wrapper)(handle , dens , sx , sy , sz , tau , rho , velx , vely , velz , epsilon , press , w_lorentz , uxx , uxy , uxz , uyy , uyz , uzz , det , x , y , z , r , rho_min , GRHydro_reflevel , GRHydro_C2P_failed);
}

void CCTK_FCALL CCTK_FNAME(Con2PrimPoly) (const CCTK_INT* handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 const CCTK_REAL* rho_min ,
 const CCTK_INT* GRHydro_reflevel ,
 CCTK_REAL* GRHydro_C2P_failed);
void CCTK_FCALL CCTK_FNAME(Con2PrimPoly) (const CCTK_INT* handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 const CCTK_REAL* rho_min ,
 const CCTK_INT* GRHydro_reflevel ,
 CCTK_REAL* GRHydro_C2P_failed)
{
  if (!Con2PrimPoly_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Con2PrimPoly has not been provided by any active thorn.");
  }

  (*Con2PrimPoly_F_Wrapper)(handle , dens , sx , sy , sz , tau , rho , velx , vely , velz , epsilon , press , w_lorentz , uxx , uxy , uxz , uyy , uyz , uzz , det , x , y , z , r , rho_min , GRHydro_reflevel , GRHydro_C2P_failed);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCon2PrimPoly(void);
CCTK_INT IsAliasedCon2PrimPoly(void)
{
  return (Con2PrimPoly_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCon2PrimPoly_C(void (*func)(const CCTK_INT handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z ,
 const CCTK_REAL r ,
 const CCTK_REAL rho_min ,
 const CCTK_INT GRHydro_reflevel ,
 CCTK_REAL* GRHydro_C2P_failed));
CCTK_INT AliasCon2PrimPoly_C(void (*func)(const CCTK_INT handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z ,
 const CCTK_REAL r ,
 const CCTK_REAL rho_min ,
 const CCTK_INT GRHydro_reflevel ,
 CCTK_REAL* GRHydro_C2P_failed))
{
  CCTK_INT aliased = Con2PrimPoly_C_Wrapper != NULL;
  if (!aliased)
  {
    Con2PrimPoly_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCon2PrimPoly_F(void (*func)(const CCTK_INT* handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 const CCTK_REAL* rho_min ,
 const CCTK_INT* GRHydro_reflevel ,
 CCTK_REAL* GRHydro_C2P_failed));
CCTK_INT AliasCon2PrimPoly_F(void (*func)(const CCTK_INT* handle ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* r ,
 const CCTK_REAL* rho_min ,
 const CCTK_INT* GRHydro_reflevel ,
 CCTK_REAL* GRHydro_C2P_failed))
{
  CCTK_INT aliased = Con2PrimPoly_C_Wrapper != NULL;
  if (!aliased)
  {
    Con2PrimPoly_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*Con2PrimPolyM_C_Wrapper) (const CCTK_INT handle ,
 const CCTK_REAL gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* sc ,
 const CCTK_REAL Bconsx ,
 const CCTK_REAL Bconsy ,
 const CCTK_REAL Bconsz ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval) = NULL;
static void (*Con2PrimPolyM_F_Wrapper) (const CCTK_INT* handle ,
 const CCTK_REAL* gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* sc ,
 const CCTK_REAL* Bconsx ,
 const CCTK_REAL* Bconsy ,
 const CCTK_REAL* Bconsz ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void Con2PrimPolyM (const CCTK_INT handle ,
 const CCTK_REAL gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* sc ,
 const CCTK_REAL Bconsx ,
 const CCTK_REAL Bconsy ,
 const CCTK_REAL Bconsz ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval);
void Con2PrimPolyM (const CCTK_INT handle ,
 const CCTK_REAL gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* sc ,
 const CCTK_REAL Bconsx ,
 const CCTK_REAL Bconsy ,
 const CCTK_REAL Bconsz ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval)
{
  if (!Con2PrimPolyM_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Con2PrimPolyM has not been provided by any active thorn.");
  }

  (*Con2PrimPolyM_C_Wrapper)(handle , gamma_eos , dens , sx , sy , sz , sc , Bconsx , Bconsy , Bconsz , rho , velx , vely , velz , epsilon , pressure , Bvecx , Bvecy , Bvecz , Bvecsq , w_lorentz , gxx , gxy , gxz , gyy , gyz , gzz , uxx , uxy , uxz , uyy , uyz , uzz , det , epsnegative , retval);
}

void CCTK_FCALL CCTK_FNAME(Con2PrimPolyM) (const CCTK_INT* handle ,
 const CCTK_REAL* gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* sc ,
 const CCTK_REAL* Bconsx ,
 const CCTK_REAL* Bconsy ,
 const CCTK_REAL* Bconsz ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval);
void CCTK_FCALL CCTK_FNAME(Con2PrimPolyM) (const CCTK_INT* handle ,
 const CCTK_REAL* gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* sc ,
 const CCTK_REAL* Bconsx ,
 const CCTK_REAL* Bconsy ,
 const CCTK_REAL* Bconsz ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval)
{
  if (!Con2PrimPolyM_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Con2PrimPolyM has not been provided by any active thorn.");
  }

  (*Con2PrimPolyM_F_Wrapper)(handle , gamma_eos , dens , sx , sy , sz , sc , Bconsx , Bconsy , Bconsz , rho , velx , vely , velz , epsilon , pressure , Bvecx , Bvecy , Bvecz , Bvecsq , w_lorentz , gxx , gxy , gxz , gyy , gyz , gzz , uxx , uxy , uxz , uyy , uyz , uzz , det , epsnegative , retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCon2PrimPolyM(void);
CCTK_INT IsAliasedCon2PrimPolyM(void)
{
  return (Con2PrimPolyM_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCon2PrimPolyM_C(void (*func)(const CCTK_INT handle ,
 const CCTK_REAL gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* sc ,
 const CCTK_REAL Bconsx ,
 const CCTK_REAL Bconsy ,
 const CCTK_REAL Bconsz ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval));
CCTK_INT AliasCon2PrimPolyM_C(void (*func)(const CCTK_INT handle ,
 const CCTK_REAL gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* sc ,
 const CCTK_REAL Bconsx ,
 const CCTK_REAL Bconsy ,
 const CCTK_REAL Bconsz ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL uxx ,
 const CCTK_REAL uxy ,
 const CCTK_REAL uxz ,
 const CCTK_REAL uyy ,
 const CCTK_REAL uyz ,
 const CCTK_REAL uzz ,
 const CCTK_REAL det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval))
{
  CCTK_INT aliased = Con2PrimPolyM_C_Wrapper != NULL;
  if (!aliased)
  {
    Con2PrimPolyM_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCon2PrimPolyM_F(void (*func)(const CCTK_INT* handle ,
 const CCTK_REAL* gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* sc ,
 const CCTK_REAL* Bconsx ,
 const CCTK_REAL* Bconsy ,
 const CCTK_REAL* Bconsz ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval));
CCTK_INT AliasCon2PrimPolyM_F(void (*func)(const CCTK_INT* handle ,
 const CCTK_REAL* gamma_eos ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* sc ,
 const CCTK_REAL* Bconsx ,
 const CCTK_REAL* Bconsy ,
 const CCTK_REAL* Bconsz ,
 CCTK_REAL* rho ,
 CCTK_REAL* velx ,
 CCTK_REAL* vely ,
 CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* pressure ,
 CCTK_REAL* Bvecx ,
 CCTK_REAL* Bvecy ,
 CCTK_REAL* Bvecz ,
 CCTK_REAL* Bvecsq ,
 CCTK_REAL* w_lorentz ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* uxx ,
 const CCTK_REAL* uxy ,
 const CCTK_REAL* uxz ,
 const CCTK_REAL* uyy ,
 const CCTK_REAL* uyz ,
 const CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 CCTK_INT* epsnegative ,
 CCTK_REAL* retval))
{
  CCTK_INT aliased = Con2PrimPolyM_C_Wrapper != NULL;
  if (!aliased)
  {
    Con2PrimPolyM_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*ConfToPhysInPlace_C_Wrapper) (const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz) = NULL;
static void (*ConfToPhysInPlace_F_Wrapper) (const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void ConfToPhysInPlace (const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz);
void ConfToPhysInPlace (const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz)
{
  if (!ConfToPhysInPlace_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConfToPhysInPlace has not been provided by any active thorn.");
  }

  (*ConfToPhysInPlace_C_Wrapper)(nx , ny , nz , psi , gxx , gxy , gxz , gyy , gyz , gzz);
}

void CCTK_FCALL CCTK_FNAME(ConfToPhysInPlace) (const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz);
void CCTK_FCALL CCTK_FNAME(ConfToPhysInPlace) (const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz)
{
  if (!ConfToPhysInPlace_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConfToPhysInPlace has not been provided by any active thorn.");
  }

  (*ConfToPhysInPlace_F_Wrapper)(nx , ny , nz , psi , gxx , gxy , gxz , gyy , gyz , gzz);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedConfToPhysInPlace(void);
CCTK_INT IsAliasedConfToPhysInPlace(void)
{
  return (ConfToPhysInPlace_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasConfToPhysInPlace_C(void (*func)(const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz));
CCTK_INT AliasConfToPhysInPlace_C(void (*func)(const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz))
{
  CCTK_INT aliased = ConfToPhysInPlace_C_Wrapper != NULL;
  if (!aliased)
  {
    ConfToPhysInPlace_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasConfToPhysInPlace_F(void (*func)(const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz));
CCTK_INT AliasConfToPhysInPlace_F(void (*func)(const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz))
{
  CCTK_INT aliased = ConfToPhysInPlace_C_Wrapper != NULL;
  if (!aliased)
  {
    ConfToPhysInPlace_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*ConvertFromExteriorBoundary_C_Wrapper) (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;
static CCTK_INT (*ConvertFromExteriorBoundary_F_Wrapper) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT ConvertFromExteriorBoundary (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT ConvertFromExteriorBoundary (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!ConvertFromExteriorBoundary_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConvertFromExteriorBoundary has not been provided by any active thorn.");
  }

  retval = (*ConvertFromExteriorBoundary_C_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(ConvertFromExteriorBoundary) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT CCTK_FCALL CCTK_FNAME(ConvertFromExteriorBoundary) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!ConvertFromExteriorBoundary_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConvertFromExteriorBoundary has not been provided by any active thorn.");
  }

  retval = (*ConvertFromExteriorBoundary_F_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedConvertFromExteriorBoundary(void);
CCTK_INT IsAliasedConvertFromExteriorBoundary(void)
{
  return (ConvertFromExteriorBoundary_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasConvertFromExteriorBoundary_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasConvertFromExteriorBoundary_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = ConvertFromExteriorBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    ConvertFromExteriorBoundary_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasConvertFromExteriorBoundary_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasConvertFromExteriorBoundary_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = ConvertFromExteriorBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    ConvertFromExteriorBoundary_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*ConvertFromInteriorBoundary_C_Wrapper) (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;
static CCTK_INT (*ConvertFromInteriorBoundary_F_Wrapper) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT ConvertFromInteriorBoundary (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT ConvertFromInteriorBoundary (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!ConvertFromInteriorBoundary_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConvertFromInteriorBoundary has not been provided by any active thorn.");
  }

  retval = (*ConvertFromInteriorBoundary_C_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(ConvertFromInteriorBoundary) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT CCTK_FCALL CCTK_FNAME(ConvertFromInteriorBoundary) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!ConvertFromInteriorBoundary_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConvertFromInteriorBoundary has not been provided by any active thorn.");
  }

  retval = (*ConvertFromInteriorBoundary_F_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedConvertFromInteriorBoundary(void);
CCTK_INT IsAliasedConvertFromInteriorBoundary(void)
{
  return (ConvertFromInteriorBoundary_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasConvertFromInteriorBoundary_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasConvertFromInteriorBoundary_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = ConvertFromInteriorBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    ConvertFromInteriorBoundary_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasConvertFromInteriorBoundary_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasConvertFromInteriorBoundary_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = ConvertFromInteriorBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    ConvertFromInteriorBoundary_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*ConvertFromPhysicalBoundary_C_Wrapper) (const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;
static CCTK_INT (*ConvertFromPhysicalBoundary_F_Wrapper) (const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT ConvertFromPhysicalBoundary (const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT ConvertFromPhysicalBoundary (const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!ConvertFromPhysicalBoundary_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConvertFromPhysicalBoundary has not been provided by any active thorn.");
  }

  retval = (*ConvertFromPhysicalBoundary_C_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(ConvertFromPhysicalBoundary) (const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT CCTK_FCALL CCTK_FNAME(ConvertFromPhysicalBoundary) (const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!ConvertFromPhysicalBoundary_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConvertFromPhysicalBoundary has not been provided by any active thorn.");
  }

  retval = (*ConvertFromPhysicalBoundary_F_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedConvertFromPhysicalBoundary(void);
CCTK_INT IsAliasedConvertFromPhysicalBoundary(void)
{
  return (ConvertFromPhysicalBoundary_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasConvertFromPhysicalBoundary_C(CCTK_INT (*func)(const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasConvertFromPhysicalBoundary_C(CCTK_INT (*func)(const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = ConvertFromPhysicalBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    ConvertFromPhysicalBoundary_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasConvertFromPhysicalBoundary_F(CCTK_INT (*func)(const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasConvertFromPhysicalBoundary_F(CCTK_INT (*func)(const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = ConvertFromPhysicalBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    ConvertFromPhysicalBoundary_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_CoordHandle_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING coordname, CCTK_STRING systemname) = NULL;
static CCTK_INT (*Coord_CoordHandle_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING coordname, CCTK_STRING systemname) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_CoordHandle (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING coordname, CCTK_STRING systemname);
CCTK_INT Coord_CoordHandle (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING coordname, CCTK_STRING systemname)
{
  CCTK_INT retval;

  if (!Coord_CoordHandle_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_CoordHandle has not been provided by any active thorn.");
  }

  retval = (*Coord_CoordHandle_C_Wrapper)(GH , coordname , systemname);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_CoordHandle) (const CCTK_POINTER_TO_CONST* GH ,
 TWO_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_CoordHandle) (const CCTK_POINTER_TO_CONST* GH ,
 TWO_FORTSTRING_ARG)
{
  CCTK_INT retval;

  TWO_FORTSTRING_CREATE(cctki_string1,cctki_string2)

  if (!Coord_CoordHandle_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_CoordHandle has not been provided by any active thorn.");
  }

  retval = (*Coord_CoordHandle_F_Wrapper)(GH , cctki_string1,cctki_string2);
  free(cctki_string1);
  free(cctki_string2);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_CoordHandle(void);
CCTK_INT IsAliasedCoord_CoordHandle(void)
{
  return (Coord_CoordHandle_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_CoordHandle_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING coordname, CCTK_STRING systemname));
CCTK_INT AliasCoord_CoordHandle_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING coordname, CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_CoordHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_CoordHandle_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_CoordHandle_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING coordname, CCTK_STRING systemname));
CCTK_INT AliasCoord_CoordHandle_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING coordname, CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_CoordHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_CoordHandle_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_CoordRegister_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemhandle ,
 const CCTK_INT direction ,
 CCTK_STRING coordname) = NULL;
static CCTK_INT (*Coord_CoordRegister_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemhandle ,
 const CCTK_INT* direction ,
 CCTK_STRING coordname) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_CoordRegister (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemhandle ,
 const CCTK_INT direction ,
 CCTK_STRING coordname);
CCTK_INT Coord_CoordRegister (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemhandle ,
 const CCTK_INT direction ,
 CCTK_STRING coordname)
{
  CCTK_INT retval;

  if (!Coord_CoordRegister_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_CoordRegister has not been provided by any active thorn.");
  }

  retval = (*Coord_CoordRegister_C_Wrapper)(GH , systemhandle , direction , coordname);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_CoordRegister) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemhandle ,
 const CCTK_INT* direction ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_CoordRegister) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemhandle ,
 const CCTK_INT* direction ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Coord_CoordRegister_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_CoordRegister has not been provided by any active thorn.");
  }

  retval = (*Coord_CoordRegister_F_Wrapper)(GH , systemhandle , direction , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_CoordRegister(void);
CCTK_INT IsAliasedCoord_CoordRegister(void)
{
  return (Coord_CoordRegister_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_CoordRegister_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemhandle ,
 const CCTK_INT direction ,
 CCTK_STRING coordname));
CCTK_INT AliasCoord_CoordRegister_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemhandle ,
 const CCTK_INT direction ,
 CCTK_STRING coordname))
{
  CCTK_INT aliased = Coord_CoordRegister_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_CoordRegister_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_CoordRegister_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemhandle ,
 const CCTK_INT* direction ,
 CCTK_STRING coordname));
CCTK_INT AliasCoord_CoordRegister_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemhandle ,
 const CCTK_INT* direction ,
 CCTK_STRING coordname))
{
  CCTK_INT aliased = Coord_CoordRegister_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_CoordRegister_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_GetDefaultSystem_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemdim) = NULL;
static CCTK_INT (*Coord_GetDefaultSystem_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemdim) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_GetDefaultSystem (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemdim);
CCTK_INT Coord_GetDefaultSystem (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemdim)
{
  CCTK_INT retval;

  if (!Coord_GetDefaultSystem_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_GetDefaultSystem has not been provided by any active thorn.");
  }

  retval = (*Coord_GetDefaultSystem_C_Wrapper)(GH , systemdim);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_GetDefaultSystem) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemdim);
CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_GetDefaultSystem) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemdim)
{
  CCTK_INT retval;

  if (!Coord_GetDefaultSystem_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_GetDefaultSystem has not been provided by any active thorn.");
  }

  retval = (*Coord_GetDefaultSystem_F_Wrapper)(GH , systemdim);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_GetDefaultSystem(void);
CCTK_INT IsAliasedCoord_GetDefaultSystem(void)
{
  return (Coord_GetDefaultSystem_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_GetDefaultSystem_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemdim));
CCTK_INT AliasCoord_GetDefaultSystem_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemdim))
{
  CCTK_INT aliased = Coord_GetDefaultSystem_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_GetDefaultSystem_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_GetDefaultSystem_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemdim));
CCTK_INT AliasCoord_GetDefaultSystem_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemdim))
{
  CCTK_INT aliased = Coord_GetDefaultSystem_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_GetDefaultSystem_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_GroupSystem_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING groupname) = NULL;
static CCTK_INT (*Coord_GroupSystem_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING groupname) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_GroupSystem (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING groupname);
CCTK_INT Coord_GroupSystem (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING groupname)
{
  CCTK_INT retval;

  if (!Coord_GroupSystem_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_GroupSystem has not been provided by any active thorn.");
  }

  retval = (*Coord_GroupSystem_C_Wrapper)(GH , groupname);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_GroupSystem) (const CCTK_POINTER_TO_CONST* GH ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_GroupSystem) (const CCTK_POINTER_TO_CONST* GH ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Coord_GroupSystem_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_GroupSystem has not been provided by any active thorn.");
  }

  retval = (*Coord_GroupSystem_F_Wrapper)(GH , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_GroupSystem(void);
CCTK_INT IsAliasedCoord_GroupSystem(void)
{
  return (Coord_GroupSystem_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_GroupSystem_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING groupname));
CCTK_INT AliasCoord_GroupSystem_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING groupname))
{
  CCTK_INT aliased = Coord_GroupSystem_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_GroupSystem_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_GroupSystem_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING groupname));
CCTK_INT AliasCoord_GroupSystem_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING groupname))
{
  CCTK_INT aliased = Coord_GroupSystem_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_GroupSystem_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_SetDefaultSystem_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname) = NULL;
static CCTK_INT (*Coord_SetDefaultSystem_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING systemname) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_SetDefaultSystem (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname);
CCTK_INT Coord_SetDefaultSystem (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname)
{
  CCTK_INT retval;

  if (!Coord_SetDefaultSystem_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_SetDefaultSystem has not been provided by any active thorn.");
  }

  retval = (*Coord_SetDefaultSystem_C_Wrapper)(GH , systemname);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_SetDefaultSystem) (const CCTK_POINTER_TO_CONST* GH ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_SetDefaultSystem) (const CCTK_POINTER_TO_CONST* GH ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Coord_SetDefaultSystem_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_SetDefaultSystem has not been provided by any active thorn.");
  }

  retval = (*Coord_SetDefaultSystem_F_Wrapper)(GH , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_SetDefaultSystem(void);
CCTK_INT IsAliasedCoord_SetDefaultSystem(void)
{
  return (Coord_SetDefaultSystem_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_SetDefaultSystem_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname));
CCTK_INT AliasCoord_SetDefaultSystem_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_SetDefaultSystem_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_SetDefaultSystem_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_SetDefaultSystem_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING systemname));
CCTK_INT AliasCoord_SetDefaultSystem_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_SetDefaultSystem_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_SetDefaultSystem_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_SystemHandle_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname) = NULL;
static CCTK_INT (*Coord_SystemHandle_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING systemname) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_SystemHandle (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname);
CCTK_INT Coord_SystemHandle (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname)
{
  CCTK_INT retval;

  if (!Coord_SystemHandle_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_SystemHandle has not been provided by any active thorn.");
  }

  retval = (*Coord_SystemHandle_C_Wrapper)(GH , systemname);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_SystemHandle) (const CCTK_POINTER_TO_CONST* GH ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_SystemHandle) (const CCTK_POINTER_TO_CONST* GH ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Coord_SystemHandle_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_SystemHandle has not been provided by any active thorn.");
  }

  retval = (*Coord_SystemHandle_F_Wrapper)(GH , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_SystemHandle(void);
CCTK_INT IsAliasedCoord_SystemHandle(void)
{
  return (Coord_SystemHandle_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_SystemHandle_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname));
CCTK_INT AliasCoord_SystemHandle_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_SystemHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_SystemHandle_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_SystemHandle_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING systemname));
CCTK_INT AliasCoord_SystemHandle_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_SystemHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_SystemHandle_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_SystemRegister_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT dim ,
 CCTK_STRING systemname) = NULL;
static CCTK_INT (*Coord_SystemRegister_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* dim ,
 CCTK_STRING systemname) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_SystemRegister (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT dim ,
 CCTK_STRING systemname);
CCTK_INT Coord_SystemRegister (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT dim ,
 CCTK_STRING systemname)
{
  CCTK_INT retval;

  if (!Coord_SystemRegister_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_SystemRegister has not been provided by any active thorn.");
  }

  retval = (*Coord_SystemRegister_C_Wrapper)(GH , dim , systemname);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_SystemRegister) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* dim ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_SystemRegister) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* dim ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Coord_SystemRegister_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_SystemRegister has not been provided by any active thorn.");
  }

  retval = (*Coord_SystemRegister_F_Wrapper)(GH , dim , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_SystemRegister(void);
CCTK_INT IsAliasedCoord_SystemRegister(void)
{
  return (Coord_SystemRegister_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_SystemRegister_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT dim ,
 CCTK_STRING systemname));
CCTK_INT AliasCoord_SystemRegister_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT dim ,
 CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_SystemRegister_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_SystemRegister_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_SystemRegister_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* dim ,
 CCTK_STRING systemname));
CCTK_INT AliasCoord_SystemRegister_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* dim ,
 CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_SystemRegister_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_SystemRegister_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Device_GetDevice_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*Device_GetDevice_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Device_GetDevice (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT Device_GetDevice (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!Device_GetDevice_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Device_GetDevice has not been provided by any active thorn.");
  }

  retval = (*Device_GetDevice_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Device_GetDevice) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(Device_GetDevice) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!Device_GetDevice_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Device_GetDevice has not been provided by any active thorn.");
  }

  retval = (*Device_GetDevice_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedDevice_GetDevice(void);
CCTK_INT IsAliasedDevice_GetDevice(void)
{
  return (Device_GetDevice_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasDevice_GetDevice_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasDevice_GetDevice_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = Device_GetDevice_C_Wrapper != NULL;
  if (!aliased)
  {
    Device_GetDevice_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasDevice_GetDevice_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasDevice_GetDevice_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = Device_GetDevice_C_Wrapper != NULL;
  if (!aliased)
  {
    Device_GetDevice_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*Diff2_coeff_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT table_handle) = NULL;
static void (*Diff2_coeff_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* table_handle) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void Diff2_coeff (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT table_handle);
void Diff2_coeff (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT table_handle)
{
  if (!Diff2_coeff_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Diff2_coeff has not been provided by any active thorn.");
  }

  (*Diff2_coeff_C_Wrapper)(cctkGH , dir , nsize , imin , imax , q , table_handle);
}

void CCTK_FCALL CCTK_FNAME(Diff2_coeff) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* table_handle);
void CCTK_FCALL CCTK_FNAME(Diff2_coeff) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* table_handle)
{
  if (!Diff2_coeff_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Diff2_coeff has not been provided by any active thorn.");
  }

  (*Diff2_coeff_F_Wrapper)(cctkGH , dir , nsize , imin , imax , q , table_handle);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedDiff2_coeff(void);
CCTK_INT IsAliasedDiff2_coeff(void)
{
  return (Diff2_coeff_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasDiff2_coeff_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT table_handle));
CCTK_INT AliasDiff2_coeff_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT table_handle))
{
  CCTK_INT aliased = Diff2_coeff_C_Wrapper != NULL;
  if (!aliased)
  {
    Diff2_coeff_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasDiff2_coeff_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* table_handle));
CCTK_INT AliasDiff2_coeff_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* table_handle))
{
  CCTK_INT aliased = Diff2_coeff_C_Wrapper != NULL;
  if (!aliased)
  {
    Diff2_coeff_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*Diff2_gv_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir1 ,
 const CCTK_INT dir2 ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT table_handle) = NULL;
static void (*Diff2_gv_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir1 ,
 const CCTK_INT* dir2 ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT* table_handle) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void Diff2_gv (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir1 ,
 const CCTK_INT dir2 ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT table_handle);
void Diff2_gv (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir1 ,
 const CCTK_INT dir2 ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT table_handle)
{
  if (!Diff2_gv_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Diff2_gv has not been provided by any active thorn.");
  }

  (*Diff2_gv_C_Wrapper)(cctkGH , dir1 , dir2 , var , dvar , table_handle);
}

void CCTK_FCALL CCTK_FNAME(Diff2_gv) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir1 ,
 const CCTK_INT* dir2 ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT* table_handle);
void CCTK_FCALL CCTK_FNAME(Diff2_gv) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir1 ,
 const CCTK_INT* dir2 ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT* table_handle)
{
  if (!Diff2_gv_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Diff2_gv has not been provided by any active thorn.");
  }

  (*Diff2_gv_F_Wrapper)(cctkGH , dir1 , dir2 , var , dvar , table_handle);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedDiff2_gv(void);
CCTK_INT IsAliasedDiff2_gv(void)
{
  return (Diff2_gv_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasDiff2_gv_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir1 ,
 const CCTK_INT dir2 ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT table_handle));
CCTK_INT AliasDiff2_gv_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir1 ,
 const CCTK_INT dir2 ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT table_handle))
{
  CCTK_INT aliased = Diff2_gv_C_Wrapper != NULL;
  if (!aliased)
  {
    Diff2_gv_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasDiff2_gv_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir1 ,
 const CCTK_INT* dir2 ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT* table_handle));
CCTK_INT AliasDiff2_gv_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir1 ,
 const CCTK_INT* dir2 ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT* table_handle))
{
  CCTK_INT aliased = Diff2_gv_C_Wrapper != NULL;
  if (!aliased)
  {
    Diff2_gv_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*Diff_coeff_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT table_handle) = NULL;
static void (*Diff_coeff_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* table_handle) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void Diff_coeff (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT table_handle);
void Diff_coeff (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT table_handle)
{
  if (!Diff_coeff_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Diff_coeff has not been provided by any active thorn.");
  }

  (*Diff_coeff_C_Wrapper)(cctkGH , dir , nsize , imin , imax , q , table_handle);
}

void CCTK_FCALL CCTK_FNAME(Diff_coeff) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* table_handle);
void CCTK_FCALL CCTK_FNAME(Diff_coeff) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* table_handle)
{
  if (!Diff_coeff_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Diff_coeff has not been provided by any active thorn.");
  }

  (*Diff_coeff_F_Wrapper)(cctkGH , dir , nsize , imin , imax , q , table_handle);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedDiff_coeff(void);
CCTK_INT IsAliasedDiff_coeff(void)
{
  return (Diff_coeff_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasDiff_coeff_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT table_handle));
CCTK_INT AliasDiff_coeff_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT table_handle))
{
  CCTK_INT aliased = Diff_coeff_C_Wrapper != NULL;
  if (!aliased)
  {
    Diff_coeff_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasDiff_coeff_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* table_handle));
CCTK_INT AliasDiff_coeff_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* table_handle))
{
  CCTK_INT aliased = Diff_coeff_C_Wrapper != NULL;
  if (!aliased)
  {
    Diff_coeff_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*Diff_gf_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 CCTK_STRING var_name, CCTK_STRING dvar_name) = NULL;
static void (*Diff_gf_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 CCTK_STRING var_name, CCTK_STRING dvar_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void Diff_gf (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 CCTK_STRING var_name, CCTK_STRING dvar_name);
void Diff_gf (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 CCTK_STRING var_name, CCTK_STRING dvar_name)
{
  if (!Diff_gf_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Diff_gf has not been provided by any active thorn.");
  }

  (*Diff_gf_C_Wrapper)(cctkGH , dir , var_name , dvar_name);
}

void CCTK_FCALL CCTK_FNAME(Diff_gf) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 TWO_FORTSTRING_ARG);
void CCTK_FCALL CCTK_FNAME(Diff_gf) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 TWO_FORTSTRING_ARG)
{
  TWO_FORTSTRING_CREATE(cctki_string1,cctki_string2)

  if (!Diff_gf_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Diff_gf has not been provided by any active thorn.");
  }

  (*Diff_gf_F_Wrapper)(cctkGH , dir , cctki_string1,cctki_string2);
  free(cctki_string1);
  free(cctki_string2);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedDiff_gf(void);
CCTK_INT IsAliasedDiff_gf(void)
{
  return (Diff_gf_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasDiff_gf_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 CCTK_STRING var_name, CCTK_STRING dvar_name));
CCTK_INT AliasDiff_gf_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 CCTK_STRING var_name, CCTK_STRING dvar_name))
{
  CCTK_INT aliased = Diff_gf_C_Wrapper != NULL;
  if (!aliased)
  {
    Diff_gf_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasDiff_gf_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 CCTK_STRING var_name, CCTK_STRING dvar_name));
CCTK_INT AliasDiff_gf_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 CCTK_STRING var_name, CCTK_STRING dvar_name))
{
  CCTK_INT aliased = Diff_gf_C_Wrapper != NULL;
  if (!aliased)
  {
    Diff_gf_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*Diff_gv_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT table_handle) = NULL;
static void (*Diff_gv_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT* table_handle) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void Diff_gv (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT table_handle);
void Diff_gv (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT table_handle)
{
  if (!Diff_gv_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Diff_gv has not been provided by any active thorn.");
  }

  (*Diff_gv_C_Wrapper)(cctkGH , dir , var , dvar , table_handle);
}

void CCTK_FCALL CCTK_FNAME(Diff_gv) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT* table_handle);
void CCTK_FCALL CCTK_FNAME(Diff_gv) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT* table_handle)
{
  if (!Diff_gv_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Diff_gv has not been provided by any active thorn.");
  }

  (*Diff_gv_F_Wrapper)(cctkGH , dir , var , dvar , table_handle);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedDiff_gv(void);
CCTK_INT IsAliasedDiff_gv(void)
{
  return (Diff_gv_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasDiff_gv_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT table_handle));
CCTK_INT AliasDiff_gv_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT table_handle))
{
  CCTK_INT aliased = Diff_gv_C_Wrapper != NULL;
  if (!aliased)
  {
    Diff_gv_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasDiff_gv_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT* table_handle));
CCTK_INT AliasDiff_gv_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_INT* table_handle))
{
  CCTK_INT aliased = Diff_gv_C_Wrapper != NULL;
  if (!aliased)
  {
    Diff_gv_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*Diff_up_coeff_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT up ,
 const CCTK_INT table_handle) = NULL;
static void (*Diff_up_coeff_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* up ,
 const CCTK_INT* table_handle) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void Diff_up_coeff (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT up ,
 const CCTK_INT table_handle);
void Diff_up_coeff (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT up ,
 const CCTK_INT table_handle)
{
  if (!Diff_up_coeff_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Diff_up_coeff has not been provided by any active thorn.");
  }

  (*Diff_up_coeff_C_Wrapper)(cctkGH , dir , nsize , imin , imax , q , up , table_handle);
}

void CCTK_FCALL CCTK_FNAME(Diff_up_coeff) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* up ,
 const CCTK_INT* table_handle);
void CCTK_FCALL CCTK_FNAME(Diff_up_coeff) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* up ,
 const CCTK_INT* table_handle)
{
  if (!Diff_up_coeff_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Diff_up_coeff has not been provided by any active thorn.");
  }

  (*Diff_up_coeff_F_Wrapper)(cctkGH , dir , nsize , imin , imax , q , up , table_handle);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedDiff_up_coeff(void);
CCTK_INT IsAliasedDiff_up_coeff(void)
{
  return (Diff_up_coeff_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasDiff_up_coeff_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT up ,
 const CCTK_INT table_handle));
CCTK_INT AliasDiff_up_coeff_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT up ,
 const CCTK_INT table_handle))
{
  CCTK_INT aliased = Diff_up_coeff_C_Wrapper != NULL;
  if (!aliased)
  {
    Diff_up_coeff_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasDiff_up_coeff_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* up ,
 const CCTK_INT* table_handle));
CCTK_INT AliasDiff_up_coeff_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* up ,
 const CCTK_INT* table_handle))
{
  CCTK_INT aliased = Diff_up_coeff_C_Wrapper != NULL;
  if (!aliased)
  {
    Diff_up_coeff_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*Diff_up_gv_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_REAL* up ,
 const CCTK_INT table_handle) = NULL;
static void (*Diff_up_gv_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_REAL* up ,
 const CCTK_INT* table_handle) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void Diff_up_gv (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_REAL* up ,
 const CCTK_INT table_handle);
void Diff_up_gv (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_REAL* up ,
 const CCTK_INT table_handle)
{
  if (!Diff_up_gv_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Diff_up_gv has not been provided by any active thorn.");
  }

  (*Diff_up_gv_C_Wrapper)(cctkGH , dir , var , dvar , up , table_handle);
}

void CCTK_FCALL CCTK_FNAME(Diff_up_gv) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_REAL* up ,
 const CCTK_INT* table_handle);
void CCTK_FCALL CCTK_FNAME(Diff_up_gv) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_REAL* up ,
 const CCTK_INT* table_handle)
{
  if (!Diff_up_gv_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Diff_up_gv has not been provided by any active thorn.");
  }

  (*Diff_up_gv_F_Wrapper)(cctkGH , dir , var , dvar , up , table_handle);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedDiff_up_gv(void);
CCTK_INT IsAliasedDiff_up_gv(void)
{
  return (Diff_up_gv_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasDiff_up_gv_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_REAL* up ,
 const CCTK_INT table_handle));
CCTK_INT AliasDiff_up_gv_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_REAL* up ,
 const CCTK_INT table_handle))
{
  CCTK_INT aliased = Diff_up_gv_C_Wrapper != NULL;
  if (!aliased)
  {
    Diff_up_gv_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasDiff_up_gv_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_REAL* up ,
 const CCTK_INT* table_handle));
CCTK_INT AliasDiff_up_gv_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_REAL* var ,
 CCTK_REAL* dvar ,
 const CCTK_REAL* up ,
 const CCTK_INT* table_handle))
{
  CCTK_INT aliased = Diff_up_gv_C_Wrapper != NULL;
  if (!aliased)
  {
    Diff_up_gv_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*DriverInterpolate_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays) = NULL;
static CCTK_INT (*DriverInterpolate_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT DriverInterpolate (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays);
CCTK_INT DriverInterpolate (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays)
{
  CCTK_INT retval;

  if (!DriverInterpolate_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function DriverInterpolate has not been provided by any active thorn.");
  }

  retval = (*DriverInterpolate_C_Wrapper)(cctkGH , N_dims , local_interp_handle , param_table_handle , coord_system_handle , N_interp_points , interp_coords_type , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_array_types , output_arrays);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(DriverInterpolate) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays);
CCTK_INT CCTK_FCALL CCTK_FNAME(DriverInterpolate) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays)
{
  CCTK_INT retval;

  if (!DriverInterpolate_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function DriverInterpolate has not been provided by any active thorn.");
  }

  retval = (*DriverInterpolate_F_Wrapper)(cctkGH , N_dims , local_interp_handle , param_table_handle , coord_system_handle , N_interp_points , interp_coords_type , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_array_types , output_arrays);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedDriverInterpolate(void);
CCTK_INT IsAliasedDriverInterpolate(void)
{
  return (DriverInterpolate_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasDriverInterpolate_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays));
CCTK_INT AliasDriverInterpolate_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays))
{
  CCTK_INT aliased = DriverInterpolate_C_Wrapper != NULL;
  if (!aliased)
  {
    DriverInterpolate_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasDriverInterpolate_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays));
CCTK_INT AliasDriverInterpolate_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays))
{
  CCTK_INT aliased = DriverInterpolate_C_Wrapper != NULL;
  if (!aliased)
  {
    DriverInterpolate_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*EOS_Omni_DEpsByDRho_DEpsByDPress_C_Wrapper) (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* DEpsByDRho ,
 CCTK_REAL* DEpsByDPress ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;
static void (*EOS_Omni_DEpsByDRho_DEpsByDPress_F_Wrapper) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* DEpsByDRho ,
 CCTK_REAL* DEpsByDPress ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void EOS_Omni_DEpsByDRho_DEpsByDPress (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* DEpsByDRho ,
 CCTK_REAL* DEpsByDPress ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void EOS_Omni_DEpsByDRho_DEpsByDPress (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* DEpsByDRho ,
 CCTK_REAL* DEpsByDPress ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_DEpsByDRho_DEpsByDPress_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_DEpsByDRho_DEpsByDPress has not been provided by any active thorn.");
  }

  (*EOS_Omni_DEpsByDRho_DEpsByDPress_C_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , DEpsByDRho , DEpsByDPress , keyerr , anyerr);
}

void CCTK_FCALL CCTK_FNAME(EOS_Omni_DEpsByDRho_DEpsByDPress) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* DEpsByDRho ,
 CCTK_REAL* DEpsByDPress ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void CCTK_FCALL CCTK_FNAME(EOS_Omni_DEpsByDRho_DEpsByDPress) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* DEpsByDRho ,
 CCTK_REAL* DEpsByDPress ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_DEpsByDRho_DEpsByDPress_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_DEpsByDRho_DEpsByDPress has not been provided by any active thorn.");
  }

  (*EOS_Omni_DEpsByDRho_DEpsByDPress_F_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , DEpsByDRho , DEpsByDPress , keyerr , anyerr);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEOS_Omni_DEpsByDRho_DEpsByDPress(void);
CCTK_INT IsAliasedEOS_Omni_DEpsByDRho_DEpsByDPress(void)
{
  return (EOS_Omni_DEpsByDRho_DEpsByDPress_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEOS_Omni_DEpsByDRho_DEpsByDPress_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* DEpsByDRho ,
 CCTK_REAL* DEpsByDPress ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_DEpsByDRho_DEpsByDPress_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* DEpsByDRho ,
 CCTK_REAL* DEpsByDPress ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_DEpsByDRho_DEpsByDPress_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_DEpsByDRho_DEpsByDPress_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEOS_Omni_DEpsByDRho_DEpsByDPress_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* DEpsByDRho ,
 CCTK_REAL* DEpsByDPress ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_DEpsByDRho_DEpsByDPress_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* DEpsByDRho ,
 CCTK_REAL* DEpsByDPress ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_DEpsByDRho_DEpsByDPress_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_DEpsByDRho_DEpsByDPress_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*EOS_Omni_DPressByDEps_C_Wrapper) (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdepsrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;
static void (*EOS_Omni_DPressByDEps_F_Wrapper) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdepsrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void EOS_Omni_DPressByDEps (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdepsrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void EOS_Omni_DPressByDEps (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdepsrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_DPressByDEps_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_DPressByDEps has not been provided by any active thorn.");
  }

  (*EOS_Omni_DPressByDEps_C_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , dpdepsrho , keyerr , anyerr);
}

void CCTK_FCALL CCTK_FNAME(EOS_Omni_DPressByDEps) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdepsrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void CCTK_FCALL CCTK_FNAME(EOS_Omni_DPressByDEps) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdepsrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_DPressByDEps_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_DPressByDEps has not been provided by any active thorn.");
  }

  (*EOS_Omni_DPressByDEps_F_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , dpdepsrho , keyerr , anyerr);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEOS_Omni_DPressByDEps(void);
CCTK_INT IsAliasedEOS_Omni_DPressByDEps(void)
{
  return (EOS_Omni_DPressByDEps_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEOS_Omni_DPressByDEps_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdepsrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_DPressByDEps_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdepsrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_DPressByDEps_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_DPressByDEps_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEOS_Omni_DPressByDEps_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdepsrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_DPressByDEps_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdepsrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_DPressByDEps_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_DPressByDEps_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*EOS_Omni_DPressByDRho_C_Wrapper) (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdrhoeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;
static void (*EOS_Omni_DPressByDRho_F_Wrapper) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdrhoeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void EOS_Omni_DPressByDRho (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdrhoeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void EOS_Omni_DPressByDRho (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdrhoeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_DPressByDRho_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_DPressByDRho has not been provided by any active thorn.");
  }

  (*EOS_Omni_DPressByDRho_C_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , dpdrhoeps , keyerr , anyerr);
}

void CCTK_FCALL CCTK_FNAME(EOS_Omni_DPressByDRho) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdrhoeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void CCTK_FCALL CCTK_FNAME(EOS_Omni_DPressByDRho) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdrhoeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_DPressByDRho_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_DPressByDRho has not been provided by any active thorn.");
  }

  (*EOS_Omni_DPressByDRho_F_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , dpdrhoeps , keyerr , anyerr);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEOS_Omni_DPressByDRho(void);
CCTK_INT IsAliasedEOS_Omni_DPressByDRho(void)
{
  return (EOS_Omni_DPressByDRho_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEOS_Omni_DPressByDRho_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdrhoeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_DPressByDRho_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdrhoeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_DPressByDRho_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_DPressByDRho_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEOS_Omni_DPressByDRho_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdrhoeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_DPressByDRho_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdrhoeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_DPressByDRho_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_DPressByDRho_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*EOS_Omni_EpsFromPress_C_Wrapper) (const CCTK_INT eoshandle ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_REAL* xeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;
static void (*EOS_Omni_EpsFromPress_F_Wrapper) (const CCTK_INT* eoshandle ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_REAL* xeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void EOS_Omni_EpsFromPress (const CCTK_INT eoshandle ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_REAL* xeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void EOS_Omni_EpsFromPress (const CCTK_INT eoshandle ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_REAL* xeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_EpsFromPress_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_EpsFromPress has not been provided by any active thorn.");
  }

  (*EOS_Omni_EpsFromPress_C_Wrapper)(eoshandle , havetemp , rf_precision , npoints , rho , eps , temp , ye , press , xeps , keyerr , anyerr);
}

void CCTK_FCALL CCTK_FNAME(EOS_Omni_EpsFromPress) (const CCTK_INT* eoshandle ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_REAL* xeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void CCTK_FCALL CCTK_FNAME(EOS_Omni_EpsFromPress) (const CCTK_INT* eoshandle ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_REAL* xeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_EpsFromPress_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_EpsFromPress has not been provided by any active thorn.");
  }

  (*EOS_Omni_EpsFromPress_F_Wrapper)(eoshandle , havetemp , rf_precision , npoints , rho , eps , temp , ye , press , xeps , keyerr , anyerr);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEOS_Omni_EpsFromPress(void);
CCTK_INT IsAliasedEOS_Omni_EpsFromPress(void)
{
  return (EOS_Omni_EpsFromPress_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEOS_Omni_EpsFromPress_C(void (*func)(const CCTK_INT eoshandle ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_REAL* xeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_EpsFromPress_C(void (*func)(const CCTK_INT eoshandle ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_REAL* xeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_EpsFromPress_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_EpsFromPress_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEOS_Omni_EpsFromPress_F(void (*func)(const CCTK_INT* eoshandle ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_REAL* xeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_EpsFromPress_F(void (*func)(const CCTK_INT* eoshandle ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_REAL* xeps ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_EpsFromPress_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_EpsFromPress_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*EOS_Omni_GetHandle_C_Wrapper) (CCTK_STRING name) = NULL;
static CCTK_INT (*EOS_Omni_GetHandle_F_Wrapper) (CCTK_STRING name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT EOS_Omni_GetHandle (CCTK_STRING name);
CCTK_INT EOS_Omni_GetHandle (CCTK_STRING name)
{
  CCTK_INT retval;

  if (!EOS_Omni_GetHandle_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_GetHandle has not been provided by any active thorn.");
  }

  retval = (*EOS_Omni_GetHandle_C_Wrapper)(name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(EOS_Omni_GetHandle) (ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(EOS_Omni_GetHandle) (ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!EOS_Omni_GetHandle_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_GetHandle has not been provided by any active thorn.");
  }

  retval = (*EOS_Omni_GetHandle_F_Wrapper)(cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEOS_Omni_GetHandle(void);
CCTK_INT IsAliasedEOS_Omni_GetHandle(void)
{
  return (EOS_Omni_GetHandle_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEOS_Omni_GetHandle_C(CCTK_INT (*func)(CCTK_STRING name));
CCTK_INT AliasEOS_Omni_GetHandle_C(CCTK_INT (*func)(CCTK_STRING name))
{
  CCTK_INT aliased = EOS_Omni_GetHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_GetHandle_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEOS_Omni_GetHandle_F(CCTK_INT (*func)(CCTK_STRING name));
CCTK_INT AliasEOS_Omni_GetHandle_F(CCTK_INT (*func)(CCTK_STRING name))
{
  CCTK_INT aliased = EOS_Omni_GetHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_GetHandle_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*EOS_Omni_PressEpsTempYe_from_Rho_C_Wrapper) (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;
static void (*EOS_Omni_PressEpsTempYe_from_Rho_F_Wrapper) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void EOS_Omni_PressEpsTempYe_from_Rho (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void EOS_Omni_PressEpsTempYe_from_Rho (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_PressEpsTempYe_from_Rho_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_PressEpsTempYe_from_Rho has not been provided by any active thorn.");
  }

  (*EOS_Omni_PressEpsTempYe_from_Rho_C_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , press , keyerr , anyerr);
}

void CCTK_FCALL CCTK_FNAME(EOS_Omni_PressEpsTempYe_from_Rho) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void CCTK_FCALL CCTK_FNAME(EOS_Omni_PressEpsTempYe_from_Rho) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_PressEpsTempYe_from_Rho_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_PressEpsTempYe_from_Rho has not been provided by any active thorn.");
  }

  (*EOS_Omni_PressEpsTempYe_from_Rho_F_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , press , keyerr , anyerr);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEOS_Omni_PressEpsTempYe_from_Rho(void);
CCTK_INT IsAliasedEOS_Omni_PressEpsTempYe_from_Rho(void)
{
  return (EOS_Omni_PressEpsTempYe_from_Rho_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEOS_Omni_PressEpsTempYe_from_Rho_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_PressEpsTempYe_from_Rho_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_PressEpsTempYe_from_Rho_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_PressEpsTempYe_from_Rho_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEOS_Omni_PressEpsTempYe_from_Rho_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_PressEpsTempYe_from_Rho_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_PressEpsTempYe_from_Rho_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_PressEpsTempYe_from_Rho_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*EOS_Omni_RhoFromPressEpsTempEnt_C_Wrapper) (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ent ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;
static void (*EOS_Omni_RhoFromPressEpsTempEnt_F_Wrapper) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ent ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void EOS_Omni_RhoFromPressEpsTempEnt (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ent ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void EOS_Omni_RhoFromPressEpsTempEnt (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ent ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_RhoFromPressEpsTempEnt_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_RhoFromPressEpsTempEnt has not been provided by any active thorn.");
  }

  (*EOS_Omni_RhoFromPressEpsTempEnt_C_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ent , ye , press , keyerr , anyerr);
}

void CCTK_FCALL CCTK_FNAME(EOS_Omni_RhoFromPressEpsTempEnt) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ent ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void CCTK_FCALL CCTK_FNAME(EOS_Omni_RhoFromPressEpsTempEnt) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ent ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_RhoFromPressEpsTempEnt_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_RhoFromPressEpsTempEnt has not been provided by any active thorn.");
  }

  (*EOS_Omni_RhoFromPressEpsTempEnt_F_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ent , ye , press , keyerr , anyerr);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEOS_Omni_RhoFromPressEpsTempEnt(void);
CCTK_INT IsAliasedEOS_Omni_RhoFromPressEpsTempEnt(void)
{
  return (EOS_Omni_RhoFromPressEpsTempEnt_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEOS_Omni_RhoFromPressEpsTempEnt_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ent ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_RhoFromPressEpsTempEnt_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ent ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_RhoFromPressEpsTempEnt_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_RhoFromPressEpsTempEnt_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEOS_Omni_RhoFromPressEpsTempEnt_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ent ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_RhoFromPressEpsTempEnt_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 CCTK_REAL* ent ,
 const CCTK_REAL* ye ,
 const CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_RhoFromPressEpsTempEnt_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_RhoFromPressEpsTempEnt_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*EOS_Omni_cs2_C_Wrapper) (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;
static void (*EOS_Omni_cs2_F_Wrapper) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void EOS_Omni_cs2 (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void EOS_Omni_cs2 (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_cs2_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_cs2 has not been provided by any active thorn.");
  }

  (*EOS_Omni_cs2_C_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , cs2 , keyerr , anyerr);
}

void CCTK_FCALL CCTK_FNAME(EOS_Omni_cs2) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void CCTK_FCALL CCTK_FNAME(EOS_Omni_cs2) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_cs2_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_cs2 has not been provided by any active thorn.");
  }

  (*EOS_Omni_cs2_F_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , cs2 , keyerr , anyerr);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEOS_Omni_cs2(void);
CCTK_INT IsAliasedEOS_Omni_cs2(void)
{
  return (EOS_Omni_cs2_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEOS_Omni_cs2_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_cs2_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_cs2_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_cs2_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEOS_Omni_cs2_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_cs2_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_cs2_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_cs2_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*EOS_Omni_dpderho_dpdrhoe_C_Wrapper) (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;
static void (*EOS_Omni_dpderho_dpdrhoe_F_Wrapper) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void EOS_Omni_dpderho_dpdrhoe (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void EOS_Omni_dpderho_dpdrhoe (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_dpderho_dpdrhoe_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_dpderho_dpdrhoe has not been provided by any active thorn.");
  }

  (*EOS_Omni_dpderho_dpdrhoe_C_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , dpderho , dpdrhoe , keyerr , anyerr);
}

void CCTK_FCALL CCTK_FNAME(EOS_Omni_dpderho_dpdrhoe) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void CCTK_FCALL CCTK_FNAME(EOS_Omni_dpderho_dpdrhoe) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_dpderho_dpdrhoe_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_dpderho_dpdrhoe has not been provided by any active thorn.");
  }

  (*EOS_Omni_dpderho_dpdrhoe_F_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , dpderho , dpdrhoe , keyerr , anyerr);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEOS_Omni_dpderho_dpdrhoe(void);
CCTK_INT IsAliasedEOS_Omni_dpderho_dpdrhoe(void)
{
  return (EOS_Omni_dpderho_dpdrhoe_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEOS_Omni_dpderho_dpdrhoe_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_dpderho_dpdrhoe_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_dpderho_dpdrhoe_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_dpderho_dpdrhoe_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEOS_Omni_dpderho_dpdrhoe_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_dpderho_dpdrhoe_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_dpderho_dpdrhoe_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_dpderho_dpdrhoe_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*EOS_Omni_dpdhrho_f_hrho_v2_rhoW_C_Wrapper) (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdhrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;
static void (*EOS_Omni_dpdhrho_f_hrho_v2_rhoW_F_Wrapper) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdhrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void EOS_Omni_dpdhrho_f_hrho_v2_rhoW (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdhrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void EOS_Omni_dpdhrho_f_hrho_v2_rhoW (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdhrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_dpdhrho_f_hrho_v2_rhoW_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_dpdhrho_f_hrho_v2_rhoW has not been provided by any active thorn.");
  }

  (*EOS_Omni_dpdhrho_f_hrho_v2_rhoW_C_Wrapper)(eoskey , havetemp , rf_precision , npoints , hrho , v2 , rhoW , eps , temp , ye , dpdhrho , keyerr , anyerr);
}

void CCTK_FCALL CCTK_FNAME(EOS_Omni_dpdhrho_f_hrho_v2_rhoW) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdhrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void CCTK_FCALL CCTK_FNAME(EOS_Omni_dpdhrho_f_hrho_v2_rhoW) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdhrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_dpdhrho_f_hrho_v2_rhoW_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_dpdhrho_f_hrho_v2_rhoW has not been provided by any active thorn.");
  }

  (*EOS_Omni_dpdhrho_f_hrho_v2_rhoW_F_Wrapper)(eoskey , havetemp , rf_precision , npoints , hrho , v2 , rhoW , eps , temp , ye , dpdhrho , keyerr , anyerr);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEOS_Omni_dpdhrho_f_hrho_v2_rhoW(void);
CCTK_INT IsAliasedEOS_Omni_dpdhrho_f_hrho_v2_rhoW(void)
{
  return (EOS_Omni_dpdhrho_f_hrho_v2_rhoW_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEOS_Omni_dpdhrho_f_hrho_v2_rhoW_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdhrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_dpdhrho_f_hrho_v2_rhoW_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdhrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_dpdhrho_f_hrho_v2_rhoW_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_dpdhrho_f_hrho_v2_rhoW_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEOS_Omni_dpdhrho_f_hrho_v2_rhoW_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdhrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_dpdhrho_f_hrho_v2_rhoW_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdhrho ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_dpdhrho_f_hrho_v2_rhoW_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_dpdhrho_f_hrho_v2_rhoW_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*EOS_Omni_dpdv2_f_hrho_v2_rhoW_C_Wrapper) (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdv2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;
static void (*EOS_Omni_dpdv2_f_hrho_v2_rhoW_F_Wrapper) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdv2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void EOS_Omni_dpdv2_f_hrho_v2_rhoW (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdv2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void EOS_Omni_dpdv2_f_hrho_v2_rhoW (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdv2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_dpdv2_f_hrho_v2_rhoW_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_dpdv2_f_hrho_v2_rhoW has not been provided by any active thorn.");
  }

  (*EOS_Omni_dpdv2_f_hrho_v2_rhoW_C_Wrapper)(eoskey , havetemp , rf_precision , npoints , hrho , v2 , rhoW , eps , temp , ye , dpdv2 , keyerr , anyerr);
}

void CCTK_FCALL CCTK_FNAME(EOS_Omni_dpdv2_f_hrho_v2_rhoW) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdv2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void CCTK_FCALL CCTK_FNAME(EOS_Omni_dpdv2_f_hrho_v2_rhoW) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdv2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_dpdv2_f_hrho_v2_rhoW_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_dpdv2_f_hrho_v2_rhoW has not been provided by any active thorn.");
  }

  (*EOS_Omni_dpdv2_f_hrho_v2_rhoW_F_Wrapper)(eoskey , havetemp , rf_precision , npoints , hrho , v2 , rhoW , eps , temp , ye , dpdv2 , keyerr , anyerr);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEOS_Omni_dpdv2_f_hrho_v2_rhoW(void);
CCTK_INT IsAliasedEOS_Omni_dpdv2_f_hrho_v2_rhoW(void)
{
  return (EOS_Omni_dpdv2_f_hrho_v2_rhoW_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEOS_Omni_dpdv2_f_hrho_v2_rhoW_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdv2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_dpdv2_f_hrho_v2_rhoW_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdv2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_dpdv2_f_hrho_v2_rhoW_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_dpdv2_f_hrho_v2_rhoW_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEOS_Omni_dpdv2_f_hrho_v2_rhoW_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdv2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_dpdv2_f_hrho_v2_rhoW_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* dpdv2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_dpdv2_f_hrho_v2_rhoW_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_dpdv2_f_hrho_v2_rhoW_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*EOS_Omni_full_C_Wrapper) (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* xa ,
 CCTK_REAL* xh ,
 CCTK_REAL* xn ,
 CCTK_REAL* xp ,
 CCTK_REAL* abar ,
 CCTK_REAL* zbar ,
 CCTK_REAL* mue ,
 CCTK_REAL* mun ,
 CCTK_REAL* mup ,
 CCTK_REAL* muhat ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;
static void (*EOS_Omni_full_F_Wrapper) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* xa ,
 CCTK_REAL* xh ,
 CCTK_REAL* xn ,
 CCTK_REAL* xp ,
 CCTK_REAL* abar ,
 CCTK_REAL* zbar ,
 CCTK_REAL* mue ,
 CCTK_REAL* mun ,
 CCTK_REAL* mup ,
 CCTK_REAL* muhat ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void EOS_Omni_full (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* xa ,
 CCTK_REAL* xh ,
 CCTK_REAL* xn ,
 CCTK_REAL* xp ,
 CCTK_REAL* abar ,
 CCTK_REAL* zbar ,
 CCTK_REAL* mue ,
 CCTK_REAL* mun ,
 CCTK_REAL* mup ,
 CCTK_REAL* muhat ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void EOS_Omni_full (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* xa ,
 CCTK_REAL* xh ,
 CCTK_REAL* xn ,
 CCTK_REAL* xp ,
 CCTK_REAL* abar ,
 CCTK_REAL* zbar ,
 CCTK_REAL* mue ,
 CCTK_REAL* mun ,
 CCTK_REAL* mup ,
 CCTK_REAL* muhat ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_full_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_full has not been provided by any active thorn.");
  }

  (*EOS_Omni_full_C_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , press , entropy , cs2 , dedt , dpderho , dpdrhoe , xa , xh , xn , xp , abar , zbar , mue , mun , mup , muhat , keyerr , anyerr);
}

void CCTK_FCALL CCTK_FNAME(EOS_Omni_full) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* xa ,
 CCTK_REAL* xh ,
 CCTK_REAL* xn ,
 CCTK_REAL* xp ,
 CCTK_REAL* abar ,
 CCTK_REAL* zbar ,
 CCTK_REAL* mue ,
 CCTK_REAL* mun ,
 CCTK_REAL* mup ,
 CCTK_REAL* muhat ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void CCTK_FCALL CCTK_FNAME(EOS_Omni_full) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* xa ,
 CCTK_REAL* xh ,
 CCTK_REAL* xn ,
 CCTK_REAL* xp ,
 CCTK_REAL* abar ,
 CCTK_REAL* zbar ,
 CCTK_REAL* mue ,
 CCTK_REAL* mun ,
 CCTK_REAL* mup ,
 CCTK_REAL* muhat ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_full_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_full has not been provided by any active thorn.");
  }

  (*EOS_Omni_full_F_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , press , entropy , cs2 , dedt , dpderho , dpdrhoe , xa , xh , xn , xp , abar , zbar , mue , mun , mup , muhat , keyerr , anyerr);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEOS_Omni_full(void);
CCTK_INT IsAliasedEOS_Omni_full(void)
{
  return (EOS_Omni_full_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEOS_Omni_full_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* xa ,
 CCTK_REAL* xh ,
 CCTK_REAL* xn ,
 CCTK_REAL* xp ,
 CCTK_REAL* abar ,
 CCTK_REAL* zbar ,
 CCTK_REAL* mue ,
 CCTK_REAL* mun ,
 CCTK_REAL* mup ,
 CCTK_REAL* muhat ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_full_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* xa ,
 CCTK_REAL* xh ,
 CCTK_REAL* xn ,
 CCTK_REAL* xp ,
 CCTK_REAL* abar ,
 CCTK_REAL* zbar ,
 CCTK_REAL* mue ,
 CCTK_REAL* mun ,
 CCTK_REAL* mup ,
 CCTK_REAL* muhat ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_full_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_full_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEOS_Omni_full_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* xa ,
 CCTK_REAL* xh ,
 CCTK_REAL* xn ,
 CCTK_REAL* xp ,
 CCTK_REAL* abar ,
 CCTK_REAL* zbar ,
 CCTK_REAL* mue ,
 CCTK_REAL* mun ,
 CCTK_REAL* mup ,
 CCTK_REAL* muhat ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_full_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* xa ,
 CCTK_REAL* xh ,
 CCTK_REAL* xn ,
 CCTK_REAL* xp ,
 CCTK_REAL* abar ,
 CCTK_REAL* zbar ,
 CCTK_REAL* mue ,
 CCTK_REAL* mun ,
 CCTK_REAL* mup ,
 CCTK_REAL* muhat ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_full_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_full_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*EOS_Omni_press_C_Wrapper) (const CCTK_INT eoshandle ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;
static void (*EOS_Omni_press_F_Wrapper) (const CCTK_INT* eoshandle ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void EOS_Omni_press (const CCTK_INT eoshandle ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void EOS_Omni_press (const CCTK_INT eoshandle ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_press_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_press has not been provided by any active thorn.");
  }

  (*EOS_Omni_press_C_Wrapper)(eoshandle , havetemp , rf_precision , npoints , rho , eps , temp , ye , press , keyerr , anyerr);
}

void CCTK_FCALL CCTK_FNAME(EOS_Omni_press) (const CCTK_INT* eoshandle ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void CCTK_FCALL CCTK_FNAME(EOS_Omni_press) (const CCTK_INT* eoshandle ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_press_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_press has not been provided by any active thorn.");
  }

  (*EOS_Omni_press_F_Wrapper)(eoshandle , havetemp , rf_precision , npoints , rho , eps , temp , ye , press , keyerr , anyerr);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEOS_Omni_press(void);
CCTK_INT IsAliasedEOS_Omni_press(void)
{
  return (EOS_Omni_press_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEOS_Omni_press_C(void (*func)(const CCTK_INT eoshandle ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_press_C(void (*func)(const CCTK_INT eoshandle ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_press_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_press_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEOS_Omni_press_F(void (*func)(const CCTK_INT* eoshandle ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_press_F(void (*func)(const CCTK_INT* eoshandle ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_press_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_press_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*EOS_Omni_pressOMP_C_Wrapper) (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;
static void (*EOS_Omni_pressOMP_F_Wrapper) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void EOS_Omni_pressOMP (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void EOS_Omni_pressOMP (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_pressOMP_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_pressOMP has not been provided by any active thorn.");
  }

  (*EOS_Omni_pressOMP_C_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , press , keyerr , anyerr);
}

void CCTK_FCALL CCTK_FNAME(EOS_Omni_pressOMP) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void CCTK_FCALL CCTK_FNAME(EOS_Omni_pressOMP) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_pressOMP_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_pressOMP has not been provided by any active thorn.");
  }

  (*EOS_Omni_pressOMP_F_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , press , keyerr , anyerr);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEOS_Omni_pressOMP(void);
CCTK_INT IsAliasedEOS_Omni_pressOMP(void)
{
  return (EOS_Omni_pressOMP_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEOS_Omni_pressOMP_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_pressOMP_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_pressOMP_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_pressOMP_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEOS_Omni_pressOMP_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_pressOMP_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_pressOMP_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_pressOMP_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*EOS_Omni_press_cs2_C_Wrapper) (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;
static void (*EOS_Omni_press_cs2_F_Wrapper) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void EOS_Omni_press_cs2 (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void EOS_Omni_press_cs2 (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_press_cs2_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_press_cs2 has not been provided by any active thorn.");
  }

  (*EOS_Omni_press_cs2_C_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , press , cs2 , keyerr , anyerr);
}

void CCTK_FCALL CCTK_FNAME(EOS_Omni_press_cs2) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void CCTK_FCALL CCTK_FNAME(EOS_Omni_press_cs2) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_press_cs2_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_press_cs2 has not been provided by any active thorn.");
  }

  (*EOS_Omni_press_cs2_F_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , press , cs2 , keyerr , anyerr);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEOS_Omni_press_cs2(void);
CCTK_INT IsAliasedEOS_Omni_press_cs2(void)
{
  return (EOS_Omni_press_cs2_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEOS_Omni_press_cs2_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_press_cs2_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_press_cs2_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_press_cs2_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEOS_Omni_press_cs2_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_press_cs2_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* cs2 ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_press_cs2_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_press_cs2_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*EOS_Omni_press_f_hrho_v2_rhoW_C_Wrapper) (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;
static void (*EOS_Omni_press_f_hrho_v2_rhoW_F_Wrapper) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void EOS_Omni_press_f_hrho_v2_rhoW (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void EOS_Omni_press_f_hrho_v2_rhoW (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_press_f_hrho_v2_rhoW_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_press_f_hrho_v2_rhoW has not been provided by any active thorn.");
  }

  (*EOS_Omni_press_f_hrho_v2_rhoW_C_Wrapper)(eoskey , havetemp , rf_precision , npoints , hrho , v2 , rhoW , eps , temp , ye , press , keyerr , anyerr);
}

void CCTK_FCALL CCTK_FNAME(EOS_Omni_press_f_hrho_v2_rhoW) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void CCTK_FCALL CCTK_FNAME(EOS_Omni_press_f_hrho_v2_rhoW) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_press_f_hrho_v2_rhoW_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_press_f_hrho_v2_rhoW has not been provided by any active thorn.");
  }

  (*EOS_Omni_press_f_hrho_v2_rhoW_F_Wrapper)(eoskey , havetemp , rf_precision , npoints , hrho , v2 , rhoW , eps , temp , ye , press , keyerr , anyerr);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEOS_Omni_press_f_hrho_v2_rhoW(void);
CCTK_INT IsAliasedEOS_Omni_press_f_hrho_v2_rhoW(void)
{
  return (EOS_Omni_press_f_hrho_v2_rhoW_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEOS_Omni_press_f_hrho_v2_rhoW_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_press_f_hrho_v2_rhoW_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_press_f_hrho_v2_rhoW_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_press_f_hrho_v2_rhoW_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEOS_Omni_press_f_hrho_v2_rhoW_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_press_f_hrho_v2_rhoW_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* hrho ,
 const CCTK_REAL* v2 ,
 const CCTK_REAL* rhoW ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_press_f_hrho_v2_rhoW_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_press_f_hrho_v2_rhoW_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*EOS_Omni_short_C_Wrapper) (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* munu ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;
static void (*EOS_Omni_short_F_Wrapper) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* munu ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void EOS_Omni_short (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* munu ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void EOS_Omni_short (const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* munu ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_short_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_short has not been provided by any active thorn.");
  }

  (*EOS_Omni_short_C_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , press , entropy , cs2 , dedt , dpderho , dpdrhoe , munu , keyerr , anyerr);
}

void CCTK_FCALL CCTK_FNAME(EOS_Omni_short) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* munu ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr);
void CCTK_FCALL CCTK_FNAME(EOS_Omni_short) (const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* munu ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr)
{
  if (!EOS_Omni_short_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EOS_Omni_short has not been provided by any active thorn.");
  }

  (*EOS_Omni_short_F_Wrapper)(eoskey , havetemp , rf_precision , npoints , rho , eps , temp , ye , press , entropy , cs2 , dedt , dpderho , dpdrhoe , munu , keyerr , anyerr);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEOS_Omni_short(void);
CCTK_INT IsAliasedEOS_Omni_short(void)
{
  return (EOS_Omni_short_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEOS_Omni_short_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* munu ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_short_C(void (*func)(const CCTK_INT eoskey ,
 const CCTK_INT havetemp ,
 const CCTK_REAL rf_precision ,
 const CCTK_INT npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* munu ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_short_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_short_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEOS_Omni_short_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* munu ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr));
CCTK_INT AliasEOS_Omni_short_F(void (*func)(const CCTK_INT* eoskey ,
 const CCTK_INT* havetemp ,
 const CCTK_REAL* rf_precision ,
 const CCTK_INT* npoints ,
 const CCTK_REAL* rho ,
 CCTK_REAL* eps ,
 CCTK_REAL* temp ,
 const CCTK_REAL* ye ,
 CCTK_REAL* press ,
 CCTK_REAL* entropy ,
 CCTK_REAL* cs2 ,
 CCTK_REAL* dedt ,
 CCTK_REAL* dpderho ,
 CCTK_REAL* dpdrhoe ,
 CCTK_REAL* munu ,
 CCTK_INT* keyerr ,
 CCTK_INT* anyerr))
{
  CCTK_INT aliased = EOS_Omni_short_C_Wrapper != NULL;
  if (!aliased)
  {
    EOS_Omni_short_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*EnableProlongating_C_Wrapper) (const CCTK_INT Status) = NULL;
static CCTK_INT (*EnableProlongating_F_Wrapper) (const CCTK_INT* Status) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT EnableProlongating (const CCTK_INT Status);
CCTK_INT EnableProlongating (const CCTK_INT Status)
{
  CCTK_INT retval;

  if (!EnableProlongating_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EnableProlongating has not been provided by any active thorn.");
  }

  retval = (*EnableProlongating_C_Wrapper)(Status);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(EnableProlongating) (const CCTK_INT* Status);
CCTK_INT CCTK_FCALL CCTK_FNAME(EnableProlongating) (const CCTK_INT* Status)
{
  CCTK_INT retval;

  if (!EnableProlongating_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EnableProlongating has not been provided by any active thorn.");
  }

  retval = (*EnableProlongating_F_Wrapper)(Status);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEnableProlongating(void);
CCTK_INT IsAliasedEnableProlongating(void)
{
  return (EnableProlongating_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEnableProlongating_C(CCTK_INT (*func)(const CCTK_INT Status));
CCTK_INT AliasEnableProlongating_C(CCTK_INT (*func)(const CCTK_INT Status))
{
  CCTK_INT aliased = EnableProlongating_C_Wrapper != NULL;
  if (!aliased)
  {
    EnableProlongating_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEnableProlongating_F(CCTK_INT (*func)(const CCTK_INT* Status));
CCTK_INT AliasEnableProlongating_F(CCTK_INT (*func)(const CCTK_INT* Status))
{
  CCTK_INT aliased = EnableProlongating_C_Wrapper != NULL;
  if (!aliased)
  {
    EnableProlongating_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*ExtrapolateGammas_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_REAL* var) = NULL;
static CCTK_INT (*ExtrapolateGammas_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_REAL* var) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT ExtrapolateGammas (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_REAL* var);
CCTK_INT ExtrapolateGammas (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_REAL* var)
{
  CCTK_INT retval;

  if (!ExtrapolateGammas_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ExtrapolateGammas has not been provided by any active thorn.");
  }

  retval = (*ExtrapolateGammas_C_Wrapper)(cctkGH , var);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(ExtrapolateGammas) (const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_REAL* var);
CCTK_INT CCTK_FCALL CCTK_FNAME(ExtrapolateGammas) (const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_REAL* var)
{
  CCTK_INT retval;

  if (!ExtrapolateGammas_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ExtrapolateGammas has not been provided by any active thorn.");
  }

  retval = (*ExtrapolateGammas_F_Wrapper)(cctkGH , var);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedExtrapolateGammas(void);
CCTK_INT IsAliasedExtrapolateGammas(void)
{
  return (ExtrapolateGammas_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasExtrapolateGammas_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_REAL* var));
CCTK_INT AliasExtrapolateGammas_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_REAL* var))
{
  CCTK_INT aliased = ExtrapolateGammas_C_Wrapper != NULL;
  if (!aliased)
  {
    ExtrapolateGammas_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasExtrapolateGammas_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_REAL* var));
CCTK_INT AliasExtrapolateGammas_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_REAL* var))
{
  CCTK_INT aliased = ExtrapolateGammas_C_Wrapper != NULL;
  if (!aliased)
  {
    ExtrapolateGammas_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GZPatchSystem_patch_number_from_global_XYZ_C_Wrapper) (const CCTK_INT psn ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z) = NULL;
static CCTK_INT (*GZPatchSystem_patch_number_from_global_XYZ_F_Wrapper) (const CCTK_INT* psn ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GZPatchSystem_patch_number_from_global_XYZ (const CCTK_INT psn ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z);
CCTK_INT GZPatchSystem_patch_number_from_global_XYZ (const CCTK_INT psn ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z)
{
  CCTK_INT retval;

  if (!GZPatchSystem_patch_number_from_global_XYZ_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GZPatchSystem_patch_number_from_global_XYZ has not been provided by any active thorn.");
  }

  retval = (*GZPatchSystem_patch_number_from_global_XYZ_C_Wrapper)(psn , x , y , z);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GZPatchSystem_patch_number_from_global_XYZ) (const CCTK_INT* psn ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z);
CCTK_INT CCTK_FCALL CCTK_FNAME(GZPatchSystem_patch_number_from_global_XYZ) (const CCTK_INT* psn ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z)
{
  CCTK_INT retval;

  if (!GZPatchSystem_patch_number_from_global_XYZ_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GZPatchSystem_patch_number_from_global_XYZ has not been provided by any active thorn.");
  }

  retval = (*GZPatchSystem_patch_number_from_global_XYZ_F_Wrapper)(psn , x , y , z);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGZPatchSystem_patch_number_from_global_XYZ(void);
CCTK_INT IsAliasedGZPatchSystem_patch_number_from_global_XYZ(void)
{
  return (GZPatchSystem_patch_number_from_global_XYZ_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGZPatchSystem_patch_number_from_global_XYZ_C(CCTK_INT (*func)(const CCTK_INT psn ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z));
CCTK_INT AliasGZPatchSystem_patch_number_from_global_XYZ_C(CCTK_INT (*func)(const CCTK_INT psn ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z))
{
  CCTK_INT aliased = GZPatchSystem_patch_number_from_global_XYZ_C_Wrapper != NULL;
  if (!aliased)
  {
    GZPatchSystem_patch_number_from_global_XYZ_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGZPatchSystem_patch_number_from_global_XYZ_F(CCTK_INT (*func)(const CCTK_INT* psn ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z));
CCTK_INT AliasGZPatchSystem_patch_number_from_global_XYZ_F(CCTK_INT (*func)(const CCTK_INT* psn ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z))
{
  CCTK_INT aliased = GZPatchSystem_patch_number_from_global_XYZ_C_Wrapper != NULL;
  if (!aliased)
  {
    GZPatchSystem_patch_number_from_global_XYZ_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*GZPatchSystem_sync_groups_C_Wrapper) (const CCTK_POINTER GH ,
 const CCTK_INT N_groups_to_sync ,
 const CCTK_POINTER_TO_CONST* group_names ,
 const CCTK_INT psn ,
 const CCTK_INT min_jwr ,
 const CCTK_INT max_jwr) = NULL;
static void (*GZPatchSystem_sync_groups_F_Wrapper) (const CCTK_POINTER* GH ,
 const CCTK_INT* N_groups_to_sync ,
 const CCTK_POINTER_TO_CONST* group_names ,
 const CCTK_INT* psn ,
 const CCTK_INT* min_jwr ,
 const CCTK_INT* max_jwr) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void GZPatchSystem_sync_groups (const CCTK_POINTER GH ,
 const CCTK_INT N_groups_to_sync ,
 const CCTK_POINTER_TO_CONST* group_names ,
 const CCTK_INT psn ,
 const CCTK_INT min_jwr ,
 const CCTK_INT max_jwr);
void GZPatchSystem_sync_groups (const CCTK_POINTER GH ,
 const CCTK_INT N_groups_to_sync ,
 const CCTK_POINTER_TO_CONST* group_names ,
 const CCTK_INT psn ,
 const CCTK_INT min_jwr ,
 const CCTK_INT max_jwr)
{
  if (!GZPatchSystem_sync_groups_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GZPatchSystem_sync_groups has not been provided by any active thorn.");
  }

  (*GZPatchSystem_sync_groups_C_Wrapper)(GH , N_groups_to_sync , group_names , psn , min_jwr , max_jwr);
}

void CCTK_FCALL CCTK_FNAME(GZPatchSystem_sync_groups) (const CCTK_POINTER* GH ,
 const CCTK_INT* N_groups_to_sync ,
 const CCTK_POINTER_TO_CONST* group_names ,
 const CCTK_INT* psn ,
 const CCTK_INT* min_jwr ,
 const CCTK_INT* max_jwr);
void CCTK_FCALL CCTK_FNAME(GZPatchSystem_sync_groups) (const CCTK_POINTER* GH ,
 const CCTK_INT* N_groups_to_sync ,
 const CCTK_POINTER_TO_CONST* group_names ,
 const CCTK_INT* psn ,
 const CCTK_INT* min_jwr ,
 const CCTK_INT* max_jwr)
{
  if (!GZPatchSystem_sync_groups_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GZPatchSystem_sync_groups has not been provided by any active thorn.");
  }

  (*GZPatchSystem_sync_groups_F_Wrapper)(GH , N_groups_to_sync , group_names , psn , min_jwr , max_jwr);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGZPatchSystem_sync_groups(void);
CCTK_INT IsAliasedGZPatchSystem_sync_groups(void)
{
  return (GZPatchSystem_sync_groups_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGZPatchSystem_sync_groups_C(void (*func)(const CCTK_POINTER GH ,
 const CCTK_INT N_groups_to_sync ,
 const CCTK_POINTER_TO_CONST* group_names ,
 const CCTK_INT psn ,
 const CCTK_INT min_jwr ,
 const CCTK_INT max_jwr));
CCTK_INT AliasGZPatchSystem_sync_groups_C(void (*func)(const CCTK_POINTER GH ,
 const CCTK_INT N_groups_to_sync ,
 const CCTK_POINTER_TO_CONST* group_names ,
 const CCTK_INT psn ,
 const CCTK_INT min_jwr ,
 const CCTK_INT max_jwr))
{
  CCTK_INT aliased = GZPatchSystem_sync_groups_C_Wrapper != NULL;
  if (!aliased)
  {
    GZPatchSystem_sync_groups_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGZPatchSystem_sync_groups_F(void (*func)(const CCTK_POINTER* GH ,
 const CCTK_INT* N_groups_to_sync ,
 const CCTK_POINTER_TO_CONST* group_names ,
 const CCTK_INT* psn ,
 const CCTK_INT* min_jwr ,
 const CCTK_INT* max_jwr));
CCTK_INT AliasGZPatchSystem_sync_groups_F(void (*func)(const CCTK_POINTER* GH ,
 const CCTK_INT* N_groups_to_sync ,
 const CCTK_POINTER_TO_CONST* group_names ,
 const CCTK_INT* psn ,
 const CCTK_INT* min_jwr ,
 const CCTK_INT* max_jwr))
{
  CCTK_INT aliased = GZPatchSystem_sync_groups_C_Wrapper != NULL;
  if (!aliased)
  {
    GZPatchSystem_sync_groups_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*GetBoundWidth_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_INT* bsize ,
 const CCTK_INT table_handle) = NULL;
static void (*GetBoundWidth_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_INT* bsize ,
 const CCTK_INT* table_handle) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void GetBoundWidth (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_INT* bsize ,
 const CCTK_INT table_handle);
void GetBoundWidth (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_INT* bsize ,
 const CCTK_INT table_handle)
{
  if (!GetBoundWidth_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetBoundWidth has not been provided by any active thorn.");
  }

  (*GetBoundWidth_C_Wrapper)(cctkGH , bsize , table_handle);
}

void CCTK_FCALL CCTK_FNAME(GetBoundWidth) (const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_INT* bsize ,
 const CCTK_INT* table_handle);
void CCTK_FCALL CCTK_FNAME(GetBoundWidth) (const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_INT* bsize ,
 const CCTK_INT* table_handle)
{
  if (!GetBoundWidth_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetBoundWidth has not been provided by any active thorn.");
  }

  (*GetBoundWidth_F_Wrapper)(cctkGH , bsize , table_handle);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetBoundWidth(void);
CCTK_INT IsAliasedGetBoundWidth(void)
{
  return (GetBoundWidth_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetBoundWidth_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_INT* bsize ,
 const CCTK_INT table_handle));
CCTK_INT AliasGetBoundWidth_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_INT* bsize ,
 const CCTK_INT table_handle))
{
  CCTK_INT aliased = GetBoundWidth_C_Wrapper != NULL;
  if (!aliased)
  {
    GetBoundWidth_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetBoundWidth_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_INT* bsize ,
 const CCTK_INT* table_handle));
CCTK_INT AliasGetBoundWidth_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_INT* bsize ,
 const CCTK_INT* table_handle))
{
  CCTK_INT aliased = GetBoundWidth_C_Wrapper != NULL;
  if (!aliased)
  {
    GetBoundWidth_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetBoundarySizesAndTypes_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd) = NULL;
static CCTK_INT (*GetBoundarySizesAndTypes_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetBoundarySizesAndTypes (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd);
CCTK_INT GetBoundarySizesAndTypes (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd)
{
  CCTK_INT retval;

  if (!GetBoundarySizesAndTypes_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetBoundarySizesAndTypes has not been provided by any active thorn.");
  }

  retval = (*GetBoundarySizesAndTypes_C_Wrapper)(cctkGH , size , bndsize , is_ghostbnd , is_symbnd , is_physbnd);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetBoundarySizesAndTypes) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetBoundarySizesAndTypes) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd)
{
  CCTK_INT retval;

  if (!GetBoundarySizesAndTypes_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetBoundarySizesAndTypes has not been provided by any active thorn.");
  }

  retval = (*GetBoundarySizesAndTypes_F_Wrapper)(cctkGH , size , bndsize , is_ghostbnd , is_symbnd , is_physbnd);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetBoundarySizesAndTypes(void);
CCTK_INT IsAliasedGetBoundarySizesAndTypes(void)
{
  return (GetBoundarySizesAndTypes_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetBoundarySizesAndTypes_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd));
CCTK_INT AliasGetBoundarySizesAndTypes_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd))
{
  CCTK_INT aliased = GetBoundarySizesAndTypes_C_Wrapper != NULL;
  if (!aliased)
  {
    GetBoundarySizesAndTypes_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetBoundarySizesAndTypes_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd));
CCTK_INT AliasGetBoundarySizesAndTypes_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd))
{
  CCTK_INT aliased = GetBoundarySizesAndTypes_C_Wrapper != NULL;
  if (!aliased)
  {
    GetBoundarySizesAndTypes_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetBoundarySpecification_C_Wrapper) (const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout) = NULL;
static CCTK_INT (*GetBoundarySpecification_F_Wrapper) (const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetBoundarySpecification (const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout);
CCTK_INT GetBoundarySpecification (const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout)
{
  CCTK_INT retval;

  if (!GetBoundarySpecification_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetBoundarySpecification has not been provided by any active thorn.");
  }

  retval = (*GetBoundarySpecification_C_Wrapper)(size , nboundaryzones , is_internal , is_staggered , shiftout);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetBoundarySpecification) (const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetBoundarySpecification) (const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout)
{
  CCTK_INT retval;

  if (!GetBoundarySpecification_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetBoundarySpecification has not been provided by any active thorn.");
  }

  retval = (*GetBoundarySpecification_F_Wrapper)(size , nboundaryzones , is_internal , is_staggered , shiftout);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetBoundarySpecification(void);
CCTK_INT IsAliasedGetBoundarySpecification(void)
{
  return (GetBoundarySpecification_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetBoundarySpecification_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout));
CCTK_INT AliasGetBoundarySpecification_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout))
{
  CCTK_INT aliased = GetBoundarySpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    GetBoundarySpecification_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetBoundarySpecification_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout));
CCTK_INT AliasGetBoundarySpecification_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout))
{
  CCTK_INT aliased = GetBoundarySpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    GetBoundarySpecification_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetCacheInfo1_C_Wrapper) (CCTK_POINTER_TO_CONST* names ,
 CCTK_INT* types ,
 CCTK_POINTER_TO_CONST* sizes ,
 CCTK_INT* linesizes ,
 CCTK_INT* strides ,
 CCTK_INT* num_puss ,
 const CCTK_INT max_num_cache_levels) = NULL;
static CCTK_INT (*GetCacheInfo1_F_Wrapper) (CCTK_POINTER_TO_CONST* names ,
 CCTK_INT* types ,
 CCTK_POINTER_TO_CONST* sizes ,
 CCTK_INT* linesizes ,
 CCTK_INT* strides ,
 CCTK_INT* num_puss ,
 const CCTK_INT* max_num_cache_levels) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetCacheInfo1 (CCTK_POINTER_TO_CONST* names ,
 CCTK_INT* types ,
 CCTK_POINTER_TO_CONST* sizes ,
 CCTK_INT* linesizes ,
 CCTK_INT* strides ,
 CCTK_INT* num_puss ,
 const CCTK_INT max_num_cache_levels);
CCTK_INT GetCacheInfo1 (CCTK_POINTER_TO_CONST* names ,
 CCTK_INT* types ,
 CCTK_POINTER_TO_CONST* sizes ,
 CCTK_INT* linesizes ,
 CCTK_INT* strides ,
 CCTK_INT* num_puss ,
 const CCTK_INT max_num_cache_levels)
{
  CCTK_INT retval;

  if (!GetCacheInfo1_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetCacheInfo1 has not been provided by any active thorn.");
  }

  retval = (*GetCacheInfo1_C_Wrapper)(names , types , sizes , linesizes , strides , num_puss , max_num_cache_levels);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetCacheInfo1) (CCTK_POINTER_TO_CONST* names ,
 CCTK_INT* types ,
 CCTK_POINTER_TO_CONST* sizes ,
 CCTK_INT* linesizes ,
 CCTK_INT* strides ,
 CCTK_INT* num_puss ,
 const CCTK_INT* max_num_cache_levels);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetCacheInfo1) (CCTK_POINTER_TO_CONST* names ,
 CCTK_INT* types ,
 CCTK_POINTER_TO_CONST* sizes ,
 CCTK_INT* linesizes ,
 CCTK_INT* strides ,
 CCTK_INT* num_puss ,
 const CCTK_INT* max_num_cache_levels)
{
  CCTK_INT retval;

  if (!GetCacheInfo1_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetCacheInfo1 has not been provided by any active thorn.");
  }

  retval = (*GetCacheInfo1_F_Wrapper)(names , types , sizes , linesizes , strides , num_puss , max_num_cache_levels);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetCacheInfo1(void);
CCTK_INT IsAliasedGetCacheInfo1(void)
{
  return (GetCacheInfo1_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetCacheInfo1_C(CCTK_INT (*func)(CCTK_POINTER_TO_CONST* names ,
 CCTK_INT* types ,
 CCTK_POINTER_TO_CONST* sizes ,
 CCTK_INT* linesizes ,
 CCTK_INT* strides ,
 CCTK_INT* num_puss ,
 const CCTK_INT max_num_cache_levels));
CCTK_INT AliasGetCacheInfo1_C(CCTK_INT (*func)(CCTK_POINTER_TO_CONST* names ,
 CCTK_INT* types ,
 CCTK_POINTER_TO_CONST* sizes ,
 CCTK_INT* linesizes ,
 CCTK_INT* strides ,
 CCTK_INT* num_puss ,
 const CCTK_INT max_num_cache_levels))
{
  CCTK_INT aliased = GetCacheInfo1_C_Wrapper != NULL;
  if (!aliased)
  {
    GetCacheInfo1_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetCacheInfo1_F(CCTK_INT (*func)(CCTK_POINTER_TO_CONST* names ,
 CCTK_INT* types ,
 CCTK_POINTER_TO_CONST* sizes ,
 CCTK_INT* linesizes ,
 CCTK_INT* strides ,
 CCTK_INT* num_puss ,
 const CCTK_INT* max_num_cache_levels));
CCTK_INT AliasGetCacheInfo1_F(CCTK_INT (*func)(CCTK_POINTER_TO_CONST* names ,
 CCTK_INT* types ,
 CCTK_POINTER_TO_CONST* sizes ,
 CCTK_INT* linesizes ,
 CCTK_INT* strides ,
 CCTK_INT* num_puss ,
 const CCTK_INT* max_num_cache_levels))
{
  CCTK_INT aliased = GetCacheInfo1_C_Wrapper != NULL;
  if (!aliased)
  {
    GetCacheInfo1_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetCoordRange_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT m ,
 const CCTK_INT ml ,
 const CCTK_INT size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta) = NULL;
static CCTK_INT (*GetCoordRange_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* m ,
 const CCTK_INT* ml ,
 const CCTK_INT* size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetCoordRange (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT m ,
 const CCTK_INT ml ,
 const CCTK_INT size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta);
CCTK_INT GetCoordRange (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT m ,
 const CCTK_INT ml ,
 const CCTK_INT size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta)
{
  CCTK_INT retval;

  if (!GetCoordRange_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetCoordRange has not been provided by any active thorn.");
  }

  retval = (*GetCoordRange_C_Wrapper)(cctkGH , m , ml , size , gsh , lower , upper , delta);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetCoordRange) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* m ,
 const CCTK_INT* ml ,
 const CCTK_INT* size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetCoordRange) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* m ,
 const CCTK_INT* ml ,
 const CCTK_INT* size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta)
{
  CCTK_INT retval;

  if (!GetCoordRange_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetCoordRange has not been provided by any active thorn.");
  }

  retval = (*GetCoordRange_F_Wrapper)(cctkGH , m , ml , size , gsh , lower , upper , delta);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetCoordRange(void);
CCTK_INT IsAliasedGetCoordRange(void)
{
  return (GetCoordRange_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetCoordRange_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT m ,
 const CCTK_INT ml ,
 const CCTK_INT size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta));
CCTK_INT AliasGetCoordRange_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT m ,
 const CCTK_INT ml ,
 const CCTK_INT size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta))
{
  CCTK_INT aliased = GetCoordRange_C_Wrapper != NULL;
  if (!aliased)
  {
    GetCoordRange_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetCoordRange_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* m ,
 const CCTK_INT* ml ,
 const CCTK_INT* size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta));
CCTK_INT AliasGetCoordRange_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* m ,
 const CCTK_INT* ml ,
 const CCTK_INT* size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta))
{
  CCTK_INT aliased = GetCoordRange_C_Wrapper != NULL;
  if (!aliased)
  {
    GetCoordRange_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetCurrentExtractionCoefs_C_Wrapper) (const CCTK_INT l ,
 const CCTK_INT m ,
 CCTK_REAL* reC ,
 CCTK_REAL* imC ,
 CCTK_REAL* reCr ,
 CCTK_REAL* imCr ,
 CCTK_REAL* reCt ,
 CCTK_REAL* imCt) = NULL;
static CCTK_INT (*GetCurrentExtractionCoefs_F_Wrapper) (const CCTK_INT* l ,
 const CCTK_INT* m ,
 CCTK_REAL* reC ,
 CCTK_REAL* imC ,
 CCTK_REAL* reCr ,
 CCTK_REAL* imCr ,
 CCTK_REAL* reCt ,
 CCTK_REAL* imCt) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetCurrentExtractionCoefs (const CCTK_INT l ,
 const CCTK_INT m ,
 CCTK_REAL* reC ,
 CCTK_REAL* imC ,
 CCTK_REAL* reCr ,
 CCTK_REAL* imCr ,
 CCTK_REAL* reCt ,
 CCTK_REAL* imCt);
CCTK_INT GetCurrentExtractionCoefs (const CCTK_INT l ,
 const CCTK_INT m ,
 CCTK_REAL* reC ,
 CCTK_REAL* imC ,
 CCTK_REAL* reCr ,
 CCTK_REAL* imCr ,
 CCTK_REAL* reCt ,
 CCTK_REAL* imCt)
{
  CCTK_INT retval;

  if (!GetCurrentExtractionCoefs_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetCurrentExtractionCoefs has not been provided by any active thorn.");
  }

  retval = (*GetCurrentExtractionCoefs_C_Wrapper)(l , m , reC , imC , reCr , imCr , reCt , imCt);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetCurrentExtractionCoefs) (const CCTK_INT* l ,
 const CCTK_INT* m ,
 CCTK_REAL* reC ,
 CCTK_REAL* imC ,
 CCTK_REAL* reCr ,
 CCTK_REAL* imCr ,
 CCTK_REAL* reCt ,
 CCTK_REAL* imCt);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetCurrentExtractionCoefs) (const CCTK_INT* l ,
 const CCTK_INT* m ,
 CCTK_REAL* reC ,
 CCTK_REAL* imC ,
 CCTK_REAL* reCr ,
 CCTK_REAL* imCr ,
 CCTK_REAL* reCt ,
 CCTK_REAL* imCt)
{
  CCTK_INT retval;

  if (!GetCurrentExtractionCoefs_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetCurrentExtractionCoefs has not been provided by any active thorn.");
  }

  retval = (*GetCurrentExtractionCoefs_F_Wrapper)(l , m , reC , imC , reCr , imCr , reCt , imCt);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetCurrentExtractionCoefs(void);
CCTK_INT IsAliasedGetCurrentExtractionCoefs(void)
{
  return (GetCurrentExtractionCoefs_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetCurrentExtractionCoefs_C(CCTK_INT (*func)(const CCTK_INT l ,
 const CCTK_INT m ,
 CCTK_REAL* reC ,
 CCTK_REAL* imC ,
 CCTK_REAL* reCr ,
 CCTK_REAL* imCr ,
 CCTK_REAL* reCt ,
 CCTK_REAL* imCt));
CCTK_INT AliasGetCurrentExtractionCoefs_C(CCTK_INT (*func)(const CCTK_INT l ,
 const CCTK_INT m ,
 CCTK_REAL* reC ,
 CCTK_REAL* imC ,
 CCTK_REAL* reCr ,
 CCTK_REAL* imCr ,
 CCTK_REAL* reCt ,
 CCTK_REAL* imCt))
{
  CCTK_INT aliased = GetCurrentExtractionCoefs_C_Wrapper != NULL;
  if (!aliased)
  {
    GetCurrentExtractionCoefs_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetCurrentExtractionCoefs_F(CCTK_INT (*func)(const CCTK_INT* l ,
 const CCTK_INT* m ,
 CCTK_REAL* reC ,
 CCTK_REAL* imC ,
 CCTK_REAL* reCr ,
 CCTK_REAL* imCr ,
 CCTK_REAL* reCt ,
 CCTK_REAL* imCt));
CCTK_INT AliasGetCurrentExtractionCoefs_F(CCTK_INT (*func)(const CCTK_INT* l ,
 const CCTK_INT* m ,
 CCTK_REAL* reC ,
 CCTK_REAL* imC ,
 CCTK_REAL* reCr ,
 CCTK_REAL* imCr ,
 CCTK_REAL* reCt ,
 CCTK_REAL* imCt))
{
  CCTK_INT aliased = GetCurrentExtractionCoefs_C_Wrapper != NULL;
  if (!aliased)
  {
    GetCurrentExtractionCoefs_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetDomainSpecification_C_Wrapper) (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing) = NULL;
static CCTK_INT (*GetDomainSpecification_F_Wrapper) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetDomainSpecification (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing);
CCTK_INT GetDomainSpecification (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!GetDomainSpecification_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetDomainSpecification has not been provided by any active thorn.");
  }

  retval = (*GetDomainSpecification_C_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetDomainSpecification) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetDomainSpecification) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!GetDomainSpecification_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetDomainSpecification has not been provided by any active thorn.");
  }

  retval = (*GetDomainSpecification_F_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetDomainSpecification(void);
CCTK_INT IsAliasedGetDomainSpecification(void)
{
  return (GetDomainSpecification_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetDomainSpecification_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing));
CCTK_INT AliasGetDomainSpecification_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing))
{
  CCTK_INT aliased = GetDomainSpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    GetDomainSpecification_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetDomainSpecification_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing));
CCTK_INT AliasGetDomainSpecification_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing))
{
  CCTK_INT aliased = GetDomainSpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    GetDomainSpecification_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetExtractionParameters_C_Wrapper) (CCTK_INT* lmax ,
 CCTK_REAL* r_inner ,
 CCTK_REAL* r_outer) = NULL;
static CCTK_INT (*GetExtractionParameters_F_Wrapper) (CCTK_INT* lmax ,
 CCTK_REAL* r_inner ,
 CCTK_REAL* r_outer) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetExtractionParameters (CCTK_INT* lmax ,
 CCTK_REAL* r_inner ,
 CCTK_REAL* r_outer);
CCTK_INT GetExtractionParameters (CCTK_INT* lmax ,
 CCTK_REAL* r_inner ,
 CCTK_REAL* r_outer)
{
  CCTK_INT retval;

  if (!GetExtractionParameters_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetExtractionParameters has not been provided by any active thorn.");
  }

  retval = (*GetExtractionParameters_C_Wrapper)(lmax , r_inner , r_outer);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetExtractionParameters) (CCTK_INT* lmax ,
 CCTK_REAL* r_inner ,
 CCTK_REAL* r_outer);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetExtractionParameters) (CCTK_INT* lmax ,
 CCTK_REAL* r_inner ,
 CCTK_REAL* r_outer)
{
  CCTK_INT retval;

  if (!GetExtractionParameters_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetExtractionParameters has not been provided by any active thorn.");
  }

  retval = (*GetExtractionParameters_F_Wrapper)(lmax , r_inner , r_outer);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetExtractionParameters(void);
CCTK_INT IsAliasedGetExtractionParameters(void)
{
  return (GetExtractionParameters_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetExtractionParameters_C(CCTK_INT (*func)(CCTK_INT* lmax ,
 CCTK_REAL* r_inner ,
 CCTK_REAL* r_outer));
CCTK_INT AliasGetExtractionParameters_C(CCTK_INT (*func)(CCTK_INT* lmax ,
 CCTK_REAL* r_inner ,
 CCTK_REAL* r_outer))
{
  CCTK_INT aliased = GetExtractionParameters_C_Wrapper != NULL;
  if (!aliased)
  {
    GetExtractionParameters_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetExtractionParameters_F(CCTK_INT (*func)(CCTK_INT* lmax ,
 CCTK_REAL* r_inner ,
 CCTK_REAL* r_outer));
CCTK_INT AliasGetExtractionParameters_F(CCTK_INT (*func)(CCTK_INT* lmax ,
 CCTK_REAL* r_inner ,
 CCTK_REAL* r_outer))
{
  CCTK_INT aliased = GetExtractionParameters_C_Wrapper != NULL;
  if (!aliased)
  {
    GetExtractionParameters_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetLocalComponent_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*GetLocalComponent_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetLocalComponent (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT GetLocalComponent (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!GetLocalComponent_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetLocalComponent has not been provided by any active thorn.");
  }

  retval = (*GetLocalComponent_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetLocalComponent) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetLocalComponent) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!GetLocalComponent_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetLocalComponent has not been provided by any active thorn.");
  }

  retval = (*GetLocalComponent_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetLocalComponent(void);
CCTK_INT IsAliasedGetLocalComponent(void)
{
  return (GetLocalComponent_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetLocalComponent_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasGetLocalComponent_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = GetLocalComponent_C_Wrapper != NULL;
  if (!aliased)
  {
    GetLocalComponent_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetLocalComponent_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasGetLocalComponent_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = GetLocalComponent_C_Wrapper != NULL;
  if (!aliased)
  {
    GetLocalComponent_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetLocalComponents_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*GetLocalComponents_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetLocalComponents (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT GetLocalComponents (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!GetLocalComponents_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetLocalComponents has not been provided by any active thorn.");
  }

  retval = (*GetLocalComponents_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetLocalComponents) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetLocalComponents) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!GetLocalComponents_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetLocalComponents has not been provided by any active thorn.");
  }

  retval = (*GetLocalComponents_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetLocalComponents(void);
CCTK_INT IsAliasedGetLocalComponents(void)
{
  return (GetLocalComponents_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetLocalComponents_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasGetLocalComponents_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = GetLocalComponents_C_Wrapper != NULL;
  if (!aliased)
  {
    GetLocalComponents_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetLocalComponents_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasGetLocalComponents_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = GetLocalComponents_C_Wrapper != NULL;
  if (!aliased)
  {
    GetLocalComponents_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*GetLshIndexRanges_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_INT* imin ,
 CCTK_INT* imax) = NULL;
static void (*GetLshIndexRanges_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_INT* imin ,
 CCTK_INT* imax) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void GetLshIndexRanges (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_INT* imin ,
 CCTK_INT* imax);
void GetLshIndexRanges (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_INT* imin ,
 CCTK_INT* imax)
{
  if (!GetLshIndexRanges_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetLshIndexRanges has not been provided by any active thorn.");
  }

  (*GetLshIndexRanges_C_Wrapper)(cctkGH , imin , imax);
}

void CCTK_FCALL CCTK_FNAME(GetLshIndexRanges) (const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_INT* imin ,
 CCTK_INT* imax);
void CCTK_FCALL CCTK_FNAME(GetLshIndexRanges) (const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_INT* imin ,
 CCTK_INT* imax)
{
  if (!GetLshIndexRanges_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetLshIndexRanges has not been provided by any active thorn.");
  }

  (*GetLshIndexRanges_F_Wrapper)(cctkGH , imin , imax);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetLshIndexRanges(void);
CCTK_INT IsAliasedGetLshIndexRanges(void)
{
  return (GetLshIndexRanges_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetLshIndexRanges_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_INT* imin ,
 CCTK_INT* imax));
CCTK_INT AliasGetLshIndexRanges_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_INT* imin ,
 CCTK_INT* imax))
{
  CCTK_INT aliased = GetLshIndexRanges_C_Wrapper != NULL;
  if (!aliased)
  {
    GetLshIndexRanges_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetLshIndexRanges_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_INT* imin ,
 CCTK_INT* imax));
CCTK_INT AliasGetLshIndexRanges_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_INT* imin ,
 CCTK_INT* imax))
{
  CCTK_INT aliased = GetLshIndexRanges_C_Wrapper != NULL;
  if (!aliased)
  {
    GetLshIndexRanges_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_POINTER_TO_CONST (*GetMPICommUniverse_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_POINTER_TO_CONST (*GetMPICommUniverse_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_POINTER_TO_CONST GetMPICommUniverse (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_POINTER_TO_CONST GetMPICommUniverse (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!GetMPICommUniverse_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetMPICommUniverse has not been provided by any active thorn.");
  }

  retval = (*GetMPICommUniverse_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(GetMPICommUniverse) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(GetMPICommUniverse) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!GetMPICommUniverse_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetMPICommUniverse has not been provided by any active thorn.");
  }

  retval = (*GetMPICommUniverse_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetMPICommUniverse(void);
CCTK_INT IsAliasedGetMPICommUniverse(void)
{
  return (GetMPICommUniverse_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetMPICommUniverse_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasGetMPICommUniverse_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = GetMPICommUniverse_C_Wrapper != NULL;
  if (!aliased)
  {
    GetMPICommUniverse_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetMPICommUniverse_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasGetMPICommUniverse_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = GetMPICommUniverse_C_Wrapper != NULL;
  if (!aliased)
  {
    GetMPICommUniverse_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_POINTER_TO_CONST (*GetMPICommWorld_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_POINTER_TO_CONST (*GetMPICommWorld_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_POINTER_TO_CONST GetMPICommWorld (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_POINTER_TO_CONST GetMPICommWorld (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!GetMPICommWorld_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetMPICommWorld has not been provided by any active thorn.");
  }

  retval = (*GetMPICommWorld_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(GetMPICommWorld) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(GetMPICommWorld) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!GetMPICommWorld_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetMPICommWorld has not been provided by any active thorn.");
  }

  retval = (*GetMPICommWorld_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetMPICommWorld(void);
CCTK_INT IsAliasedGetMPICommWorld(void)
{
  return (GetMPICommWorld_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetMPICommWorld_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasGetMPICommWorld_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = GetMPICommWorld_C_Wrapper != NULL;
  if (!aliased)
  {
    GetMPICommWorld_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetMPICommWorld_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasGetMPICommWorld_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = GetMPICommWorld_C_Wrapper != NULL;
  if (!aliased)
  {
    GetMPICommWorld_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetMPIProcessInfo_C_Wrapper) (CCTK_INT* mpi_num_procs ,
 CCTK_INT* mpi_proc_num ,
 CCTK_INT* mpi_num_hosts ,
 CCTK_INT* mpi_host_num ,
 CCTK_INT* mpi_num_procs_on_host ,
 CCTK_INT* mpi_proc_num_on_host) = NULL;
static CCTK_INT (*GetMPIProcessInfo_F_Wrapper) (CCTK_INT* mpi_num_procs ,
 CCTK_INT* mpi_proc_num ,
 CCTK_INT* mpi_num_hosts ,
 CCTK_INT* mpi_host_num ,
 CCTK_INT* mpi_num_procs_on_host ,
 CCTK_INT* mpi_proc_num_on_host) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetMPIProcessInfo (CCTK_INT* mpi_num_procs ,
 CCTK_INT* mpi_proc_num ,
 CCTK_INT* mpi_num_hosts ,
 CCTK_INT* mpi_host_num ,
 CCTK_INT* mpi_num_procs_on_host ,
 CCTK_INT* mpi_proc_num_on_host);
CCTK_INT GetMPIProcessInfo (CCTK_INT* mpi_num_procs ,
 CCTK_INT* mpi_proc_num ,
 CCTK_INT* mpi_num_hosts ,
 CCTK_INT* mpi_host_num ,
 CCTK_INT* mpi_num_procs_on_host ,
 CCTK_INT* mpi_proc_num_on_host)
{
  CCTK_INT retval;

  if (!GetMPIProcessInfo_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetMPIProcessInfo has not been provided by any active thorn.");
  }

  retval = (*GetMPIProcessInfo_C_Wrapper)(mpi_num_procs , mpi_proc_num , mpi_num_hosts , mpi_host_num , mpi_num_procs_on_host , mpi_proc_num_on_host);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetMPIProcessInfo) (CCTK_INT* mpi_num_procs ,
 CCTK_INT* mpi_proc_num ,
 CCTK_INT* mpi_num_hosts ,
 CCTK_INT* mpi_host_num ,
 CCTK_INT* mpi_num_procs_on_host ,
 CCTK_INT* mpi_proc_num_on_host);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetMPIProcessInfo) (CCTK_INT* mpi_num_procs ,
 CCTK_INT* mpi_proc_num ,
 CCTK_INT* mpi_num_hosts ,
 CCTK_INT* mpi_host_num ,
 CCTK_INT* mpi_num_procs_on_host ,
 CCTK_INT* mpi_proc_num_on_host)
{
  CCTK_INT retval;

  if (!GetMPIProcessInfo_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetMPIProcessInfo has not been provided by any active thorn.");
  }

  retval = (*GetMPIProcessInfo_F_Wrapper)(mpi_num_procs , mpi_proc_num , mpi_num_hosts , mpi_host_num , mpi_num_procs_on_host , mpi_proc_num_on_host);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetMPIProcessInfo(void);
CCTK_INT IsAliasedGetMPIProcessInfo(void)
{
  return (GetMPIProcessInfo_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetMPIProcessInfo_C(CCTK_INT (*func)(CCTK_INT* mpi_num_procs ,
 CCTK_INT* mpi_proc_num ,
 CCTK_INT* mpi_num_hosts ,
 CCTK_INT* mpi_host_num ,
 CCTK_INT* mpi_num_procs_on_host ,
 CCTK_INT* mpi_proc_num_on_host));
CCTK_INT AliasGetMPIProcessInfo_C(CCTK_INT (*func)(CCTK_INT* mpi_num_procs ,
 CCTK_INT* mpi_proc_num ,
 CCTK_INT* mpi_num_hosts ,
 CCTK_INT* mpi_host_num ,
 CCTK_INT* mpi_num_procs_on_host ,
 CCTK_INT* mpi_proc_num_on_host))
{
  CCTK_INT aliased = GetMPIProcessInfo_C_Wrapper != NULL;
  if (!aliased)
  {
    GetMPIProcessInfo_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetMPIProcessInfo_F(CCTK_INT (*func)(CCTK_INT* mpi_num_procs ,
 CCTK_INT* mpi_proc_num ,
 CCTK_INT* mpi_num_hosts ,
 CCTK_INT* mpi_host_num ,
 CCTK_INT* mpi_num_procs_on_host ,
 CCTK_INT* mpi_proc_num_on_host));
CCTK_INT AliasGetMPIProcessInfo_F(CCTK_INT (*func)(CCTK_INT* mpi_num_procs ,
 CCTK_INT* mpi_proc_num ,
 CCTK_INT* mpi_num_hosts ,
 CCTK_INT* mpi_host_num ,
 CCTK_INT* mpi_num_procs_on_host ,
 CCTK_INT* mpi_proc_num_on_host))
{
  CCTK_INT aliased = GetMPIProcessInfo_C_Wrapper != NULL;
  if (!aliased)
  {
    GetMPIProcessInfo_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetMap_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*GetMap_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetMap (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT GetMap (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!GetMap_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetMap has not been provided by any active thorn.");
  }

  retval = (*GetMap_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetMap) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetMap) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!GetMap_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetMap has not been provided by any active thorn.");
  }

  retval = (*GetMap_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetMap(void);
CCTK_INT IsAliasedGetMap(void)
{
  return (GetMap_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetMap_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasGetMap_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = GetMap_C_Wrapper != NULL;
  if (!aliased)
  {
    GetMap_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetMap_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasGetMap_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = GetMap_C_Wrapper != NULL;
  if (!aliased)
  {
    GetMap_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetMaps_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*GetMaps_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetMaps (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT GetMaps (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!GetMaps_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetMaps has not been provided by any active thorn.");
  }

  retval = (*GetMaps_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetMaps) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetMaps) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!GetMaps_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetMaps has not been provided by any active thorn.");
  }

  retval = (*GetMaps_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetMaps(void);
CCTK_INT IsAliasedGetMaps(void)
{
  return (GetMaps_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetMaps_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasGetMaps_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = GetMaps_C_Wrapper != NULL;
  if (!aliased)
  {
    GetMaps_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetMaps_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasGetMaps_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = GetMaps_C_Wrapper != NULL;
  if (!aliased)
  {
    GetMaps_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetMaxRefinementLevels_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*GetMaxRefinementLevels_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetMaxRefinementLevels (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT GetMaxRefinementLevels (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!GetMaxRefinementLevels_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetMaxRefinementLevels has not been provided by any active thorn.");
  }

  retval = (*GetMaxRefinementLevels_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetMaxRefinementLevels) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetMaxRefinementLevels) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!GetMaxRefinementLevels_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetMaxRefinementLevels has not been provided by any active thorn.");
  }

  retval = (*GetMaxRefinementLevels_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetMaxRefinementLevels(void);
CCTK_INT IsAliasedGetMaxRefinementLevels(void)
{
  return (GetMaxRefinementLevels_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetMaxRefinementLevels_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasGetMaxRefinementLevels_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = GetMaxRefinementLevels_C_Wrapper != NULL;
  if (!aliased)
  {
    GetMaxRefinementLevels_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetMaxRefinementLevels_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasGetMaxRefinementLevels_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = GetMaxRefinementLevels_C_Wrapper != NULL;
  if (!aliased)
  {
    GetMaxRefinementLevels_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetMaxSMTThreads_C_Wrapper) (void) = NULL;
static CCTK_INT (*GetMaxSMTThreads_F_Wrapper) (void) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetMaxSMTThreads (void);
CCTK_INT GetMaxSMTThreads (void)
{
  CCTK_INT retval;

  if (!GetMaxSMTThreads_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetMaxSMTThreads has not been provided by any active thorn.");
  }

  retval = (*GetMaxSMTThreads_C_Wrapper)();
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetMaxSMTThreads) (void);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetMaxSMTThreads) (void)
{
  CCTK_INT retval;

  if (!GetMaxSMTThreads_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetMaxSMTThreads has not been provided by any active thorn.");
  }

  retval = (*GetMaxSMTThreads_F_Wrapper)();
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetMaxSMTThreads(void);
CCTK_INT IsAliasedGetMaxSMTThreads(void)
{
  return (GetMaxSMTThreads_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetMaxSMTThreads_C(CCTK_INT (*func)(void));
CCTK_INT AliasGetMaxSMTThreads_C(CCTK_INT (*func)(void))
{
  CCTK_INT aliased = GetMaxSMTThreads_C_Wrapper != NULL;
  if (!aliased)
  {
    GetMaxSMTThreads_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetMaxSMTThreads_F(CCTK_INT (*func)(void));
CCTK_INT AliasGetMaxSMTThreads_F(CCTK_INT (*func)(void))
{
  CCTK_INT aliased = GetMaxSMTThreads_C_Wrapper != NULL;
  if (!aliased)
  {
    GetMaxSMTThreads_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetNumSMTThreads_C_Wrapper) (void) = NULL;
static CCTK_INT (*GetNumSMTThreads_F_Wrapper) (void) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetNumSMTThreads (void);
CCTK_INT GetNumSMTThreads (void)
{
  CCTK_INT retval;

  if (!GetNumSMTThreads_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetNumSMTThreads has not been provided by any active thorn.");
  }

  retval = (*GetNumSMTThreads_C_Wrapper)();
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetNumSMTThreads) (void);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetNumSMTThreads) (void)
{
  CCTK_INT retval;

  if (!GetNumSMTThreads_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetNumSMTThreads has not been provided by any active thorn.");
  }

  retval = (*GetNumSMTThreads_F_Wrapper)();
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetNumSMTThreads(void);
CCTK_INT IsAliasedGetNumSMTThreads(void)
{
  return (GetNumSMTThreads_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetNumSMTThreads_C(CCTK_INT (*func)(void));
CCTK_INT AliasGetNumSMTThreads_C(CCTK_INT (*func)(void))
{
  CCTK_INT aliased = GetNumSMTThreads_C_Wrapper != NULL;
  if (!aliased)
  {
    GetNumSMTThreads_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetNumSMTThreads_F(CCTK_INT (*func)(void));
CCTK_INT AliasGetNumSMTThreads_F(CCTK_INT (*func)(void))
{
  CCTK_INT aliased = GetNumSMTThreads_C_Wrapper != NULL;
  if (!aliased)
  {
    GetNumSMTThreads_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetRefinementLevel_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*GetRefinementLevel_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetRefinementLevel (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT GetRefinementLevel (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!GetRefinementLevel_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetRefinementLevel has not been provided by any active thorn.");
  }

  retval = (*GetRefinementLevel_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetRefinementLevel) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetRefinementLevel) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!GetRefinementLevel_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetRefinementLevel has not been provided by any active thorn.");
  }

  retval = (*GetRefinementLevel_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetRefinementLevel(void);
CCTK_INT IsAliasedGetRefinementLevel(void)
{
  return (GetRefinementLevel_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetRefinementLevel_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasGetRefinementLevel_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = GetRefinementLevel_C_Wrapper != NULL;
  if (!aliased)
  {
    GetRefinementLevel_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetRefinementLevel_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasGetRefinementLevel_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = GetRefinementLevel_C_Wrapper != NULL;
  if (!aliased)
  {
    GetRefinementLevel_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetRefinementLevels_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*GetRefinementLevels_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetRefinementLevels (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT GetRefinementLevels (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!GetRefinementLevels_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetRefinementLevels has not been provided by any active thorn.");
  }

  retval = (*GetRefinementLevels_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetRefinementLevels) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetRefinementLevels) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!GetRefinementLevels_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetRefinementLevels has not been provided by any active thorn.");
  }

  retval = (*GetRefinementLevels_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetRefinementLevels(void);
CCTK_INT IsAliasedGetRefinementLevels(void)
{
  return (GetRefinementLevels_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetRefinementLevels_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasGetRefinementLevels_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = GetRefinementLevels_C_Wrapper != NULL;
  if (!aliased)
  {
    GetRefinementLevels_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetRefinementLevels_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasGetRefinementLevels_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = GetRefinementLevels_C_Wrapper != NULL;
  if (!aliased)
  {
    GetRefinementLevels_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetRegriddingEpoch_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*GetRegriddingEpoch_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetRegriddingEpoch (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT GetRegriddingEpoch (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!GetRegriddingEpoch_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetRegriddingEpoch has not been provided by any active thorn.");
  }

  retval = (*GetRegriddingEpoch_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetRegriddingEpoch) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetRegriddingEpoch) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!GetRegriddingEpoch_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetRegriddingEpoch has not been provided by any active thorn.");
  }

  retval = (*GetRegriddingEpoch_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetRegriddingEpoch(void);
CCTK_INT IsAliasedGetRegriddingEpoch(void)
{
  return (GetRegriddingEpoch_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetRegriddingEpoch_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasGetRegriddingEpoch_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = GetRegriddingEpoch_C_Wrapper != NULL;
  if (!aliased)
  {
    GetRegriddingEpoch_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetRegriddingEpoch_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasGetRegriddingEpoch_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = GetRegriddingEpoch_C_Wrapper != NULL;
  if (!aliased)
  {
    GetRegriddingEpoch_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetRegriddingEpochs_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* epochs) = NULL;
static CCTK_INT (*GetRegriddingEpochs_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* epochs) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetRegriddingEpochs (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* epochs);
CCTK_INT GetRegriddingEpochs (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* epochs)
{
  CCTK_INT retval;

  if (!GetRegriddingEpochs_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetRegriddingEpochs has not been provided by any active thorn.");
  }

  retval = (*GetRegriddingEpochs_C_Wrapper)(cctkGH , size , epochs);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetRegriddingEpochs) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* epochs);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetRegriddingEpochs) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* epochs)
{
  CCTK_INT retval;

  if (!GetRegriddingEpochs_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetRegriddingEpochs has not been provided by any active thorn.");
  }

  retval = (*GetRegriddingEpochs_F_Wrapper)(cctkGH , size , epochs);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetRegriddingEpochs(void);
CCTK_INT IsAliasedGetRegriddingEpochs(void)
{
  return (GetRegriddingEpochs_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetRegriddingEpochs_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* epochs));
CCTK_INT AliasGetRegriddingEpochs_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* epochs))
{
  CCTK_INT aliased = GetRegriddingEpochs_C_Wrapper != NULL;
  if (!aliased)
  {
    GetRegriddingEpochs_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetRegriddingEpochs_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* epochs));
CCTK_INT AliasGetRegriddingEpochs_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* epochs))
{
  CCTK_INT aliased = GetRegriddingEpochs_C_Wrapper != NULL;
  if (!aliased)
  {
    GetRegriddingEpochs_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_REAL (*GetScalProdCoeff_C_Wrapper) (void) = NULL;
static CCTK_REAL (*GetScalProdCoeff_F_Wrapper) (void) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_REAL GetScalProdCoeff (void);
CCTK_REAL GetScalProdCoeff (void)
{
  CCTK_REAL retval;

  if (!GetScalProdCoeff_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetScalProdCoeff has not been provided by any active thorn.");
  }

  retval = (*GetScalProdCoeff_C_Wrapper)();
  return (retval);
}

CCTK_REAL CCTK_FCALL CCTK_FNAME(GetScalProdCoeff) (void);
CCTK_REAL CCTK_FCALL CCTK_FNAME(GetScalProdCoeff) (void)
{
  CCTK_REAL retval;

  if (!GetScalProdCoeff_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetScalProdCoeff has not been provided by any active thorn.");
  }

  retval = (*GetScalProdCoeff_F_Wrapper)();
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetScalProdCoeff(void);
CCTK_INT IsAliasedGetScalProdCoeff(void)
{
  return (GetScalProdCoeff_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetScalProdCoeff_C(CCTK_REAL (*func)(void));
CCTK_INT AliasGetScalProdCoeff_C(CCTK_REAL (*func)(void))
{
  CCTK_INT aliased = GetScalProdCoeff_C_Wrapper != NULL;
  if (!aliased)
  {
    GetScalProdCoeff_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetScalProdCoeff_F(CCTK_REAL (*func)(void));
CCTK_INT AliasGetScalProdCoeff_F(CCTK_REAL (*func)(void))
{
  CCTK_INT aliased = GetScalProdCoeff_C_Wrapper != NULL;
  if (!aliased)
  {
    GetScalProdCoeff_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*GetScalProdDiag_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_REAL* sigmad) = NULL;
static void (*GetScalProdDiag_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_REAL* sigmad) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void GetScalProdDiag (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_REAL* sigmad);
void GetScalProdDiag (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_REAL* sigmad)
{
  if (!GetScalProdDiag_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetScalProdDiag has not been provided by any active thorn.");
  }

  (*GetScalProdDiag_C_Wrapper)(cctkGH , dir , nsize , sigmad);
}

void CCTK_FCALL CCTK_FNAME(GetScalProdDiag) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_REAL* sigmad);
void CCTK_FCALL CCTK_FNAME(GetScalProdDiag) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_REAL* sigmad)
{
  if (!GetScalProdDiag_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetScalProdDiag has not been provided by any active thorn.");
  }

  (*GetScalProdDiag_F_Wrapper)(cctkGH , dir , nsize , sigmad);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetScalProdDiag(void);
CCTK_INT IsAliasedGetScalProdDiag(void)
{
  return (GetScalProdDiag_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetScalProdDiag_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_REAL* sigmad));
CCTK_INT AliasGetScalProdDiag_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_REAL* sigmad))
{
  CCTK_INT aliased = GetScalProdDiag_C_Wrapper != NULL;
  if (!aliased)
  {
    GetScalProdDiag_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetScalProdDiag_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_REAL* sigmad));
CCTK_INT AliasGetScalProdDiag_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_REAL* sigmad))
{
  CCTK_INT aliased = GetScalProdDiag_C_Wrapper != NULL;
  if (!aliased)
  {
    GetScalProdDiag_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetSymmetryBoundaries_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* symbnd) = NULL;
static CCTK_INT (*GetSymmetryBoundaries_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* symbnd) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetSymmetryBoundaries (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* symbnd);
CCTK_INT GetSymmetryBoundaries (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* symbnd)
{
  CCTK_INT retval;

  if (!GetSymmetryBoundaries_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetSymmetryBoundaries has not been provided by any active thorn.");
  }

  retval = (*GetSymmetryBoundaries_C_Wrapper)(cctkGH , size , symbnd);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetSymmetryBoundaries) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* symbnd);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetSymmetryBoundaries) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* symbnd)
{
  CCTK_INT retval;

  if (!GetSymmetryBoundaries_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetSymmetryBoundaries has not been provided by any active thorn.");
  }

  retval = (*GetSymmetryBoundaries_F_Wrapper)(cctkGH , size , symbnd);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetSymmetryBoundaries(void);
CCTK_INT IsAliasedGetSymmetryBoundaries(void)
{
  return (GetSymmetryBoundaries_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetSymmetryBoundaries_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* symbnd));
CCTK_INT AliasGetSymmetryBoundaries_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* symbnd))
{
  CCTK_INT aliased = GetSymmetryBoundaries_C_Wrapper != NULL;
  if (!aliased)
  {
    GetSymmetryBoundaries_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetSymmetryBoundaries_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* symbnd));
CCTK_INT AliasGetSymmetryBoundaries_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* symbnd))
{
  CCTK_INT aliased = GetSymmetryBoundaries_C_Wrapper != NULL;
  if (!aliased)
  {
    GetSymmetryBoundaries_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetTimeLevel_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*GetTimeLevel_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetTimeLevel (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT GetTimeLevel (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!GetTimeLevel_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetTimeLevel has not been provided by any active thorn.");
  }

  retval = (*GetTimeLevel_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetTimeLevel) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetTimeLevel) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!GetTimeLevel_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetTimeLevel has not been provided by any active thorn.");
  }

  retval = (*GetTimeLevel_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetTimeLevel(void);
CCTK_INT IsAliasedGetTimeLevel(void)
{
  return (GetTimeLevel_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetTimeLevel_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasGetTimeLevel_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = GetTimeLevel_C_Wrapper != NULL;
  if (!aliased)
  {
    GetTimeLevel_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetTimeLevel_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasGetTimeLevel_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = GetTimeLevel_C_Wrapper != NULL;
  if (!aliased)
  {
    GetTimeLevel_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetTimeLevelOffset_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*GetTimeLevelOffset_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetTimeLevelOffset (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT GetTimeLevelOffset (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!GetTimeLevelOffset_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetTimeLevelOffset has not been provided by any active thorn.");
  }

  retval = (*GetTimeLevelOffset_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetTimeLevelOffset) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetTimeLevelOffset) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!GetTimeLevelOffset_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetTimeLevelOffset has not been provided by any active thorn.");
  }

  retval = (*GetTimeLevelOffset_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetTimeLevelOffset(void);
CCTK_INT IsAliasedGetTimeLevelOffset(void)
{
  return (GetTimeLevelOffset_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetTimeLevelOffset_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasGetTimeLevelOffset_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = GetTimeLevelOffset_C_Wrapper != NULL;
  if (!aliased)
  {
    GetTimeLevelOffset_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetTimeLevelOffset_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasGetTimeLevelOffset_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = GetTimeLevelOffset_C_Wrapper != NULL;
  if (!aliased)
  {
    GetTimeLevelOffset_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*HorizonCentroid_C_Wrapper) (const CCTK_INT horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z) = NULL;
static CCTK_INT (*HorizonCentroid_F_Wrapper) (const CCTK_INT* horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT HorizonCentroid (const CCTK_INT horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z);
CCTK_INT HorizonCentroid (const CCTK_INT horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z)
{
  CCTK_INT retval;

  if (!HorizonCentroid_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function HorizonCentroid has not been provided by any active thorn.");
  }

  retval = (*HorizonCentroid_C_Wrapper)(horizon_number , centroid_x , centroid_y , centroid_z);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(HorizonCentroid) (const CCTK_INT* horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z);
CCTK_INT CCTK_FCALL CCTK_FNAME(HorizonCentroid) (const CCTK_INT* horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z)
{
  CCTK_INT retval;

  if (!HorizonCentroid_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function HorizonCentroid has not been provided by any active thorn.");
  }

  retval = (*HorizonCentroid_F_Wrapper)(horizon_number , centroid_x , centroid_y , centroid_z);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHorizonCentroid(void);
CCTK_INT IsAliasedHorizonCentroid(void)
{
  return (HorizonCentroid_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHorizonCentroid_C(CCTK_INT (*func)(const CCTK_INT horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z));
CCTK_INT AliasHorizonCentroid_C(CCTK_INT (*func)(const CCTK_INT horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z))
{
  CCTK_INT aliased = HorizonCentroid_C_Wrapper != NULL;
  if (!aliased)
  {
    HorizonCentroid_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHorizonCentroid_F(CCTK_INT (*func)(const CCTK_INT* horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z));
CCTK_INT AliasHorizonCentroid_F(CCTK_INT (*func)(const CCTK_INT* horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z))
{
  CCTK_INT aliased = HorizonCentroid_C_Wrapper != NULL;
  if (!aliased)
  {
    HorizonCentroid_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*HorizonLocalCoordinateOrigin_C_Wrapper) (const CCTK_INT horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z) = NULL;
static CCTK_INT (*HorizonLocalCoordinateOrigin_F_Wrapper) (const CCTK_INT* horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT HorizonLocalCoordinateOrigin (const CCTK_INT horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z);
CCTK_INT HorizonLocalCoordinateOrigin (const CCTK_INT horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z)
{
  CCTK_INT retval;

  if (!HorizonLocalCoordinateOrigin_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function HorizonLocalCoordinateOrigin has not been provided by any active thorn.");
  }

  retval = (*HorizonLocalCoordinateOrigin_C_Wrapper)(horizon_number , origin_x , origin_y , origin_z);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(HorizonLocalCoordinateOrigin) (const CCTK_INT* horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z);
CCTK_INT CCTK_FCALL CCTK_FNAME(HorizonLocalCoordinateOrigin) (const CCTK_INT* horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z)
{
  CCTK_INT retval;

  if (!HorizonLocalCoordinateOrigin_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function HorizonLocalCoordinateOrigin has not been provided by any active thorn.");
  }

  retval = (*HorizonLocalCoordinateOrigin_F_Wrapper)(horizon_number , origin_x , origin_y , origin_z);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHorizonLocalCoordinateOrigin(void);
CCTK_INT IsAliasedHorizonLocalCoordinateOrigin(void)
{
  return (HorizonLocalCoordinateOrigin_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHorizonLocalCoordinateOrigin_C(CCTK_INT (*func)(const CCTK_INT horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z));
CCTK_INT AliasHorizonLocalCoordinateOrigin_C(CCTK_INT (*func)(const CCTK_INT horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z))
{
  CCTK_INT aliased = HorizonLocalCoordinateOrigin_C_Wrapper != NULL;
  if (!aliased)
  {
    HorizonLocalCoordinateOrigin_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHorizonLocalCoordinateOrigin_F(CCTK_INT (*func)(const CCTK_INT* horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z));
CCTK_INT AliasHorizonLocalCoordinateOrigin_F(CCTK_INT (*func)(const CCTK_INT* horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z))
{
  CCTK_INT aliased = HorizonLocalCoordinateOrigin_C_Wrapper != NULL;
  if (!aliased)
  {
    HorizonLocalCoordinateOrigin_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*HorizonRadiusInDirection_C_Wrapper) (const CCTK_INT horizon_number ,
 const CCTK_INT N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius) = NULL;
static CCTK_INT (*HorizonRadiusInDirection_F_Wrapper) (const CCTK_INT* horizon_number ,
 const CCTK_INT* N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT HorizonRadiusInDirection (const CCTK_INT horizon_number ,
 const CCTK_INT N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius);
CCTK_INT HorizonRadiusInDirection (const CCTK_INT horizon_number ,
 const CCTK_INT N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius)
{
  CCTK_INT retval;

  if (!HorizonRadiusInDirection_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function HorizonRadiusInDirection has not been provided by any active thorn.");
  }

  retval = (*HorizonRadiusInDirection_C_Wrapper)(horizon_number , N_points , x , y , z , radius);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(HorizonRadiusInDirection) (const CCTK_INT* horizon_number ,
 const CCTK_INT* N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius);
CCTK_INT CCTK_FCALL CCTK_FNAME(HorizonRadiusInDirection) (const CCTK_INT* horizon_number ,
 const CCTK_INT* N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius)
{
  CCTK_INT retval;

  if (!HorizonRadiusInDirection_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function HorizonRadiusInDirection has not been provided by any active thorn.");
  }

  retval = (*HorizonRadiusInDirection_F_Wrapper)(horizon_number , N_points , x , y , z , radius);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHorizonRadiusInDirection(void);
CCTK_INT IsAliasedHorizonRadiusInDirection(void)
{
  return (HorizonRadiusInDirection_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHorizonRadiusInDirection_C(CCTK_INT (*func)(const CCTK_INT horizon_number ,
 const CCTK_INT N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius));
CCTK_INT AliasHorizonRadiusInDirection_C(CCTK_INT (*func)(const CCTK_INT horizon_number ,
 const CCTK_INT N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius))
{
  CCTK_INT aliased = HorizonRadiusInDirection_C_Wrapper != NULL;
  if (!aliased)
  {
    HorizonRadiusInDirection_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHorizonRadiusInDirection_F(CCTK_INT (*func)(const CCTK_INT* horizon_number ,
 const CCTK_INT* N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius));
CCTK_INT AliasHorizonRadiusInDirection_F(CCTK_INT (*func)(const CCTK_INT* horizon_number ,
 const CCTK_INT* N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius))
{
  CCTK_INT aliased = HorizonRadiusInDirection_C_Wrapper != NULL;
  if (!aliased)
  {
    HorizonRadiusInDirection_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*HorizonWasFound_C_Wrapper) (const CCTK_INT horizon_number) = NULL;
static CCTK_INT (*HorizonWasFound_F_Wrapper) (const CCTK_INT* horizon_number) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT HorizonWasFound (const CCTK_INT horizon_number);
CCTK_INT HorizonWasFound (const CCTK_INT horizon_number)
{
  CCTK_INT retval;

  if (!HorizonWasFound_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function HorizonWasFound has not been provided by any active thorn.");
  }

  retval = (*HorizonWasFound_C_Wrapper)(horizon_number);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(HorizonWasFound) (const CCTK_INT* horizon_number);
CCTK_INT CCTK_FCALL CCTK_FNAME(HorizonWasFound) (const CCTK_INT* horizon_number)
{
  CCTK_INT retval;

  if (!HorizonWasFound_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function HorizonWasFound has not been provided by any active thorn.");
  }

  retval = (*HorizonWasFound_F_Wrapper)(horizon_number);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHorizonWasFound(void);
CCTK_INT IsAliasedHorizonWasFound(void)
{
  return (HorizonWasFound_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHorizonWasFound_C(CCTK_INT (*func)(const CCTK_INT horizon_number));
CCTK_INT AliasHorizonWasFound_C(CCTK_INT (*func)(const CCTK_INT horizon_number))
{
  CCTK_INT aliased = HorizonWasFound_C_Wrapper != NULL;
  if (!aliased)
  {
    HorizonWasFound_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHorizonWasFound_F(CCTK_INT (*func)(const CCTK_INT* horizon_number));
CCTK_INT AliasHorizonWasFound_F(CCTK_INT (*func)(const CCTK_INT* horizon_number))
{
  CCTK_INT aliased = HorizonWasFound_C_Wrapper != NULL;
  if (!aliased)
  {
    HorizonWasFound_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Hyperslab_FreeMapping_C_Wrapper) (const CCTK_INT mapping_handle) = NULL;
static CCTK_INT (*Hyperslab_FreeMapping_F_Wrapper) (const CCTK_INT* mapping_handle) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Hyperslab_FreeMapping (const CCTK_INT mapping_handle);
CCTK_INT Hyperslab_FreeMapping (const CCTK_INT mapping_handle)
{
  CCTK_INT retval;

  if (!Hyperslab_FreeMapping_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_FreeMapping has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_FreeMapping_C_Wrapper)(mapping_handle);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_FreeMapping) (const CCTK_INT* mapping_handle);
CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_FreeMapping) (const CCTK_INT* mapping_handle)
{
  CCTK_INT retval;

  if (!Hyperslab_FreeMapping_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_FreeMapping has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_FreeMapping_F_Wrapper)(mapping_handle);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHyperslab_FreeMapping(void);
CCTK_INT IsAliasedHyperslab_FreeMapping(void)
{
  return (Hyperslab_FreeMapping_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHyperslab_FreeMapping_C(CCTK_INT (*func)(const CCTK_INT mapping_handle));
CCTK_INT AliasHyperslab_FreeMapping_C(CCTK_INT (*func)(const CCTK_INT mapping_handle))
{
  CCTK_INT aliased = Hyperslab_FreeMapping_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_FreeMapping_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHyperslab_FreeMapping_F(CCTK_INT (*func)(const CCTK_INT* mapping_handle));
CCTK_INT AliasHyperslab_FreeMapping_F(CCTK_INT (*func)(const CCTK_INT* mapping_handle))
{
  CCTK_INT aliased = Hyperslab_FreeMapping_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_FreeMapping_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Hyperslab_Get_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT proc ,
 const CCTK_INT vindex ,
 const CCTK_INT timelevel ,
 const CCTK_INT hdatatype ,
 const CCTK_POINTER hdata) = NULL;
static CCTK_INT (*Hyperslab_Get_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* proc ,
 const CCTK_INT* vindex ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* hdatatype ,
 const CCTK_POINTER* hdata) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Hyperslab_Get (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT proc ,
 const CCTK_INT vindex ,
 const CCTK_INT timelevel ,
 const CCTK_INT hdatatype ,
 const CCTK_POINTER hdata);
CCTK_INT Hyperslab_Get (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT proc ,
 const CCTK_INT vindex ,
 const CCTK_INT timelevel ,
 const CCTK_INT hdatatype ,
 const CCTK_POINTER hdata)
{
  CCTK_INT retval;

  if (!Hyperslab_Get_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_Get has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_Get_C_Wrapper)(cctkGH , mapping_handle , proc , vindex , timelevel , hdatatype , hdata);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_Get) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* proc ,
 const CCTK_INT* vindex ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* hdatatype ,
 const CCTK_POINTER* hdata);
CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_Get) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* proc ,
 const CCTK_INT* vindex ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* hdatatype ,
 const CCTK_POINTER* hdata)
{
  CCTK_INT retval;

  if (!Hyperslab_Get_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_Get has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_Get_F_Wrapper)(cctkGH , mapping_handle , proc , vindex , timelevel , hdatatype , hdata);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHyperslab_Get(void);
CCTK_INT IsAliasedHyperslab_Get(void)
{
  return (Hyperslab_Get_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHyperslab_Get_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT proc ,
 const CCTK_INT vindex ,
 const CCTK_INT timelevel ,
 const CCTK_INT hdatatype ,
 const CCTK_POINTER hdata));
CCTK_INT AliasHyperslab_Get_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT proc ,
 const CCTK_INT vindex ,
 const CCTK_INT timelevel ,
 const CCTK_INT hdatatype ,
 const CCTK_POINTER hdata))
{
  CCTK_INT aliased = Hyperslab_Get_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_Get_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHyperslab_Get_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* proc ,
 const CCTK_INT* vindex ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* hdatatype ,
 const CCTK_POINTER* hdata));
CCTK_INT AliasHyperslab_Get_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* proc ,
 const CCTK_INT* vindex ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* hdatatype ,
 const CCTK_POINTER* hdata))
{
  CCTK_INT aliased = Hyperslab_Get_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_Get_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Hyperslab_GetList_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals) = NULL;
static CCTK_INT (*Hyperslab_GetList_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Hyperslab_GetList (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals);
CCTK_INT Hyperslab_GetList (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals)
{
  CCTK_INT retval;

  if (!Hyperslab_GetList_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_GetList has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_GetList_C_Wrapper)(cctkGH , mapping_handle , num_arrays , procs , vindices , timelevels , hdatatypes , hdata , retvals);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_GetList) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals);
CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_GetList) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals)
{
  CCTK_INT retval;

  if (!Hyperslab_GetList_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_GetList has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_GetList_F_Wrapper)(cctkGH , mapping_handle , num_arrays , procs , vindices , timelevels , hdatatypes , hdata , retvals);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHyperslab_GetList(void);
CCTK_INT IsAliasedHyperslab_GetList(void)
{
  return (Hyperslab_GetList_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHyperslab_GetList_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals));
CCTK_INT AliasHyperslab_GetList_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals))
{
  CCTK_INT aliased = Hyperslab_GetList_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_GetList_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHyperslab_GetList_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals));
CCTK_INT AliasHyperslab_GetList_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals))
{
  CCTK_INT aliased = Hyperslab_GetList_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_GetList_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Hyperslab_GlobalMappingByIndex_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize) = NULL;
static CCTK_INT (*Hyperslab_GlobalMappingByIndex_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Hyperslab_GlobalMappingByIndex (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize);
CCTK_INT Hyperslab_GlobalMappingByIndex (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize)
{
  CCTK_INT retval;

  if (!Hyperslab_GlobalMappingByIndex_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_GlobalMappingByIndex has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_GlobalMappingByIndex_C_Wrapper)(cctkGH , vindex , hdim , direction , origin , extent , downsample , table_handle , conversion_fn , hsize);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_GlobalMappingByIndex) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize);
CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_GlobalMappingByIndex) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize)
{
  CCTK_INT retval;

  if (!Hyperslab_GlobalMappingByIndex_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_GlobalMappingByIndex has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_GlobalMappingByIndex_F_Wrapper)(cctkGH , vindex , hdim , direction , origin , extent , downsample , table_handle , conversion_fn , hsize);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHyperslab_GlobalMappingByIndex(void);
CCTK_INT IsAliasedHyperslab_GlobalMappingByIndex(void)
{
  return (Hyperslab_GlobalMappingByIndex_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHyperslab_GlobalMappingByIndex_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize));
CCTK_INT AliasHyperslab_GlobalMappingByIndex_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize))
{
  CCTK_INT aliased = Hyperslab_GlobalMappingByIndex_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_GlobalMappingByIndex_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHyperslab_GlobalMappingByIndex_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize));
CCTK_INT AliasHyperslab_GlobalMappingByIndex_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize))
{
  CCTK_INT aliased = Hyperslab_GlobalMappingByIndex_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_GlobalMappingByIndex_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Hyperslab_LocalMappingByIndex_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global) = NULL;
static CCTK_INT (*Hyperslab_LocalMappingByIndex_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Hyperslab_LocalMappingByIndex (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global);
CCTK_INT Hyperslab_LocalMappingByIndex (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global)
{
  CCTK_INT retval;

  if (!Hyperslab_LocalMappingByIndex_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_LocalMappingByIndex has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_LocalMappingByIndex_C_Wrapper)(cctkGH , vindex , hdim , direction , origin , extent , downsample , table_handle , conversion_fn , hsize_local , hsize_global , hoffset_global);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_LocalMappingByIndex) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global);
CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_LocalMappingByIndex) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global)
{
  CCTK_INT retval;

  if (!Hyperslab_LocalMappingByIndex_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_LocalMappingByIndex has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_LocalMappingByIndex_F_Wrapper)(cctkGH , vindex , hdim , direction , origin , extent , downsample , table_handle , conversion_fn , hsize_local , hsize_global , hoffset_global);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHyperslab_LocalMappingByIndex(void);
CCTK_INT IsAliasedHyperslab_LocalMappingByIndex(void)
{
  return (Hyperslab_LocalMappingByIndex_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHyperslab_LocalMappingByIndex_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global));
CCTK_INT AliasHyperslab_LocalMappingByIndex_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global))
{
  CCTK_INT aliased = Hyperslab_LocalMappingByIndex_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_LocalMappingByIndex_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHyperslab_LocalMappingByIndex_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global));
CCTK_INT AliasHyperslab_LocalMappingByIndex_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global))
{
  CCTK_INT aliased = Hyperslab_LocalMappingByIndex_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_LocalMappingByIndex_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*IO_SetCheckpointGroups_C_Wrapper) (const CCTK_INT* groups ,
 const CCTK_INT ngroups) = NULL;
static CCTK_INT (*IO_SetCheckpointGroups_F_Wrapper) (const CCTK_INT* groups ,
 const CCTK_INT* ngroups) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT IO_SetCheckpointGroups (const CCTK_INT* groups ,
 const CCTK_INT ngroups);
CCTK_INT IO_SetCheckpointGroups (const CCTK_INT* groups ,
 const CCTK_INT ngroups)
{
  CCTK_INT retval;

  if (!IO_SetCheckpointGroups_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function IO_SetCheckpointGroups has not been provided by any active thorn.");
  }

  retval = (*IO_SetCheckpointGroups_C_Wrapper)(groups , ngroups);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(IO_SetCheckpointGroups) (const CCTK_INT* groups ,
 const CCTK_INT* ngroups);
CCTK_INT CCTK_FCALL CCTK_FNAME(IO_SetCheckpointGroups) (const CCTK_INT* groups ,
 const CCTK_INT* ngroups)
{
  CCTK_INT retval;

  if (!IO_SetCheckpointGroups_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function IO_SetCheckpointGroups has not been provided by any active thorn.");
  }

  retval = (*IO_SetCheckpointGroups_F_Wrapper)(groups , ngroups);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedIO_SetCheckpointGroups(void);
CCTK_INT IsAliasedIO_SetCheckpointGroups(void)
{
  return (IO_SetCheckpointGroups_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasIO_SetCheckpointGroups_C(CCTK_INT (*func)(const CCTK_INT* groups ,
 const CCTK_INT ngroups));
CCTK_INT AliasIO_SetCheckpointGroups_C(CCTK_INT (*func)(const CCTK_INT* groups ,
 const CCTK_INT ngroups))
{
  CCTK_INT aliased = IO_SetCheckpointGroups_C_Wrapper != NULL;
  if (!aliased)
  {
    IO_SetCheckpointGroups_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasIO_SetCheckpointGroups_F(CCTK_INT (*func)(const CCTK_INT* groups ,
 const CCTK_INT* ngroups));
CCTK_INT AliasIO_SetCheckpointGroups_F(CCTK_INT (*func)(const CCTK_INT* groups ,
 const CCTK_INT* ngroups))
{
  CCTK_INT aliased = IO_SetCheckpointGroups_C_Wrapper != NULL;
  if (!aliased)
  {
    IO_SetCheckpointGroups_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*IO_TruncateOutputFiles_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*IO_TruncateOutputFiles_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT IO_TruncateOutputFiles (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT IO_TruncateOutputFiles (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!IO_TruncateOutputFiles_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function IO_TruncateOutputFiles has not been provided by any active thorn.");
  }

  retval = (*IO_TruncateOutputFiles_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(IO_TruncateOutputFiles) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(IO_TruncateOutputFiles) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!IO_TruncateOutputFiles_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function IO_TruncateOutputFiles has not been provided by any active thorn.");
  }

  retval = (*IO_TruncateOutputFiles_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedIO_TruncateOutputFiles(void);
CCTK_INT IsAliasedIO_TruncateOutputFiles(void)
{
  return (IO_TruncateOutputFiles_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasIO_TruncateOutputFiles_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasIO_TruncateOutputFiles_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = IO_TruncateOutputFiles_C_Wrapper != NULL;
  if (!aliased)
  {
    IO_TruncateOutputFiles_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasIO_TruncateOutputFiles_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasIO_TruncateOutputFiles_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = IO_TruncateOutputFiles_C_Wrapper != NULL;
  if (!aliased)
  {
    IO_TruncateOutputFiles_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Interp2GridArrays_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST interp_handle ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_POINTER output_arrays) = NULL;
static CCTK_INT (*Interp2GridArrays_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* interp_handle ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_POINTER* output_arrays) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Interp2GridArrays (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST interp_handle ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_POINTER output_arrays);
CCTK_INT Interp2GridArrays (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST interp_handle ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_POINTER output_arrays)
{
  CCTK_INT retval;

  if (!Interp2GridArrays_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Interp2GridArrays has not been provided by any active thorn.");
  }

  retval = (*Interp2GridArrays_C_Wrapper)(cctkGH , interp_handle , N_input_arrays , input_array_indices , N_output_arrays , output_arrays);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Interp2GridArrays) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* interp_handle ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_POINTER* output_arrays);
CCTK_INT CCTK_FCALL CCTK_FNAME(Interp2GridArrays) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* interp_handle ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_POINTER* output_arrays)
{
  CCTK_INT retval;

  if (!Interp2GridArrays_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Interp2GridArrays has not been provided by any active thorn.");
  }

  retval = (*Interp2GridArrays_F_Wrapper)(cctkGH , interp_handle , N_input_arrays , input_array_indices , N_output_arrays , output_arrays);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedInterp2GridArrays(void);
CCTK_INT IsAliasedInterp2GridArrays(void)
{
  return (Interp2GridArrays_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasInterp2GridArrays_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST interp_handle ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_POINTER output_arrays));
CCTK_INT AliasInterp2GridArrays_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST interp_handle ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_POINTER output_arrays))
{
  CCTK_INT aliased = Interp2GridArrays_C_Wrapper != NULL;
  if (!aliased)
  {
    Interp2GridArrays_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasInterp2GridArrays_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* interp_handle ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_POINTER* output_arrays));
CCTK_INT AliasInterp2GridArrays_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* interp_handle ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_POINTER* output_arrays))
{
  CCTK_INT aliased = Interp2GridArrays_C_Wrapper != NULL;
  if (!aliased)
  {
    Interp2GridArrays_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Interp2GridArraysFree_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER interp_handle) = NULL;
static CCTK_INT (*Interp2GridArraysFree_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* interp_handle) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Interp2GridArraysFree (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER interp_handle);
CCTK_INT Interp2GridArraysFree (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER interp_handle)
{
  CCTK_INT retval;

  if (!Interp2GridArraysFree_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Interp2GridArraysFree has not been provided by any active thorn.");
  }

  retval = (*Interp2GridArraysFree_C_Wrapper)(cctkGH , interp_handle);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Interp2GridArraysFree) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* interp_handle);
CCTK_INT CCTK_FCALL CCTK_FNAME(Interp2GridArraysFree) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* interp_handle)
{
  CCTK_INT retval;

  if (!Interp2GridArraysFree_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Interp2GridArraysFree has not been provided by any active thorn.");
  }

  retval = (*Interp2GridArraysFree_F_Wrapper)(cctkGH , interp_handle);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedInterp2GridArraysFree(void);
CCTK_INT IsAliasedInterp2GridArraysFree(void)
{
  return (Interp2GridArraysFree_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasInterp2GridArraysFree_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER interp_handle));
CCTK_INT AliasInterp2GridArraysFree_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER interp_handle))
{
  CCTK_INT aliased = Interp2GridArraysFree_C_Wrapper != NULL;
  if (!aliased)
  {
    Interp2GridArraysFree_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasInterp2GridArraysFree_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* interp_handle));
CCTK_INT AliasInterp2GridArraysFree_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* interp_handle))
{
  CCTK_INT aliased = Interp2GridArraysFree_C_Wrapper != NULL;
  if (!aliased)
  {
    Interp2GridArraysFree_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_POINTER (*Interp2GridArraysSetup_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT order ,
 const CCTK_INT N_interp_points ,
 const CCTK_POINTER_TO_CONST interp_coords) = NULL;
static CCTK_POINTER (*Interp2GridArraysSetup_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* order ,
 const CCTK_INT* N_interp_points ,
 const CCTK_POINTER_TO_CONST* interp_coords) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_POINTER Interp2GridArraysSetup (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT order ,
 const CCTK_INT N_interp_points ,
 const CCTK_POINTER_TO_CONST interp_coords);
CCTK_POINTER Interp2GridArraysSetup (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT order ,
 const CCTK_INT N_interp_points ,
 const CCTK_POINTER_TO_CONST interp_coords)
{
  CCTK_POINTER retval;

  if (!Interp2GridArraysSetup_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Interp2GridArraysSetup has not been provided by any active thorn.");
  }

  retval = (*Interp2GridArraysSetup_C_Wrapper)(cctkGH , N_dims , order , N_interp_points , interp_coords);
  return (retval);
}

CCTK_POINTER CCTK_FCALL CCTK_FNAME(Interp2GridArraysSetup) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* order ,
 const CCTK_INT* N_interp_points ,
 const CCTK_POINTER_TO_CONST* interp_coords);
CCTK_POINTER CCTK_FCALL CCTK_FNAME(Interp2GridArraysSetup) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* order ,
 const CCTK_INT* N_interp_points ,
 const CCTK_POINTER_TO_CONST* interp_coords)
{
  CCTK_POINTER retval;

  if (!Interp2GridArraysSetup_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Interp2GridArraysSetup has not been provided by any active thorn.");
  }

  retval = (*Interp2GridArraysSetup_F_Wrapper)(cctkGH , N_dims , order , N_interp_points , interp_coords);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedInterp2GridArraysSetup(void);
CCTK_INT IsAliasedInterp2GridArraysSetup(void)
{
  return (Interp2GridArraysSetup_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasInterp2GridArraysSetup_C(CCTK_POINTER (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT order ,
 const CCTK_INT N_interp_points ,
 const CCTK_POINTER_TO_CONST interp_coords));
CCTK_INT AliasInterp2GridArraysSetup_C(CCTK_POINTER (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT order ,
 const CCTK_INT N_interp_points ,
 const CCTK_POINTER_TO_CONST interp_coords))
{
  CCTK_INT aliased = Interp2GridArraysSetup_C_Wrapper != NULL;
  if (!aliased)
  {
    Interp2GridArraysSetup_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasInterp2GridArraysSetup_F(CCTK_POINTER (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* order ,
 const CCTK_INT* N_interp_points ,
 const CCTK_POINTER_TO_CONST* interp_coords));
CCTK_INT AliasInterp2GridArraysSetup_F(CCTK_POINTER (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* order ,
 const CCTK_INT* N_interp_points ,
 const CCTK_POINTER_TO_CONST* interp_coords))
{
  CCTK_INT aliased = Interp2GridArraysSetup_C_Wrapper != NULL;
  if (!aliased)
  {
    Interp2GridArraysSetup_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*InterpGridArrays_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT order ,
 const CCTK_INT N_interp_points ,
 const CCTK_POINTER_TO_CONST interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_POINTER output_arrays) = NULL;
static CCTK_INT (*InterpGridArrays_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* order ,
 const CCTK_INT* N_interp_points ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_POINTER* output_arrays) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT InterpGridArrays (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT order ,
 const CCTK_INT N_interp_points ,
 const CCTK_POINTER_TO_CONST interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_POINTER output_arrays);
CCTK_INT InterpGridArrays (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT order ,
 const CCTK_INT N_interp_points ,
 const CCTK_POINTER_TO_CONST interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_POINTER output_arrays)
{
  CCTK_INT retval;

  if (!InterpGridArrays_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function InterpGridArrays has not been provided by any active thorn.");
  }

  retval = (*InterpGridArrays_C_Wrapper)(cctkGH , N_dims , order , N_interp_points , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_arrays);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(InterpGridArrays) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* order ,
 const CCTK_INT* N_interp_points ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_POINTER* output_arrays);
CCTK_INT CCTK_FCALL CCTK_FNAME(InterpGridArrays) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* order ,
 const CCTK_INT* N_interp_points ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_POINTER* output_arrays)
{
  CCTK_INT retval;

  if (!InterpGridArrays_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function InterpGridArrays has not been provided by any active thorn.");
  }

  retval = (*InterpGridArrays_F_Wrapper)(cctkGH , N_dims , order , N_interp_points , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_arrays);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedInterpGridArrays(void);
CCTK_INT IsAliasedInterpGridArrays(void)
{
  return (InterpGridArrays_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasInterpGridArrays_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT order ,
 const CCTK_INT N_interp_points ,
 const CCTK_POINTER_TO_CONST interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_POINTER output_arrays));
CCTK_INT AliasInterpGridArrays_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT order ,
 const CCTK_INT N_interp_points ,
 const CCTK_POINTER_TO_CONST interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_POINTER output_arrays))
{
  CCTK_INT aliased = InterpGridArrays_C_Wrapper != NULL;
  if (!aliased)
  {
    InterpGridArrays_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasInterpGridArrays_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* order ,
 const CCTK_INT* N_interp_points ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_POINTER* output_arrays));
CCTK_INT AliasInterpGridArrays_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* order ,
 const CCTK_INT* N_interp_points ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_POINTER* output_arrays))
{
  CCTK_INT aliased = InterpGridArrays_C_Wrapper != NULL;
  if (!aliased)
  {
    InterpGridArrays_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*LinearCombination_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT var ,
 const CCTK_INT rl ,
 const CCTK_INT tl ,
 const CCTK_REAL scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT nsrcs) = NULL;
static CCTK_INT (*LinearCombination_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* var ,
 const CCTK_INT* rl ,
 const CCTK_INT* tl ,
 const CCTK_REAL* scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT* nsrcs) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT LinearCombination (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT var ,
 const CCTK_INT rl ,
 const CCTK_INT tl ,
 const CCTK_REAL scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT nsrcs);
CCTK_INT LinearCombination (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT var ,
 const CCTK_INT rl ,
 const CCTK_INT tl ,
 const CCTK_REAL scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT nsrcs)
{
  CCTK_INT retval;

  if (!LinearCombination_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function LinearCombination has not been provided by any active thorn.");
  }

  retval = (*LinearCombination_C_Wrapper)(cctkGH , var , rl , tl , scale , srcs , tls , facts , nsrcs);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(LinearCombination) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* var ,
 const CCTK_INT* rl ,
 const CCTK_INT* tl ,
 const CCTK_REAL* scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT* nsrcs);
CCTK_INT CCTK_FCALL CCTK_FNAME(LinearCombination) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* var ,
 const CCTK_INT* rl ,
 const CCTK_INT* tl ,
 const CCTK_REAL* scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT* nsrcs)
{
  CCTK_INT retval;

  if (!LinearCombination_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function LinearCombination has not been provided by any active thorn.");
  }

  retval = (*LinearCombination_F_Wrapper)(cctkGH , var , rl , tl , scale , srcs , tls , facts , nsrcs);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedLinearCombination(void);
CCTK_INT IsAliasedLinearCombination(void)
{
  return (LinearCombination_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasLinearCombination_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT var ,
 const CCTK_INT rl ,
 const CCTK_INT tl ,
 const CCTK_REAL scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT nsrcs));
CCTK_INT AliasLinearCombination_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT var ,
 const CCTK_INT rl ,
 const CCTK_INT tl ,
 const CCTK_REAL scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT nsrcs))
{
  CCTK_INT aliased = LinearCombination_C_Wrapper != NULL;
  if (!aliased)
  {
    LinearCombination_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasLinearCombination_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* var ,
 const CCTK_INT* rl ,
 const CCTK_INT* tl ,
 const CCTK_REAL* scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT* nsrcs));
CCTK_INT AliasLinearCombination_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* var ,
 const CCTK_INT* rl ,
 const CCTK_INT* tl ,
 const CCTK_REAL* scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT* nsrcs))
{
  CCTK_INT aliased = LinearCombination_C_Wrapper != NULL;
  if (!aliased)
  {
    LinearCombination_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLChangeToConstrained_C_Wrapper) (const CCTK_INT ConstrainedIndex) = NULL;
static CCTK_INT (*MoLChangeToConstrained_F_Wrapper) (const CCTK_INT* ConstrainedIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLChangeToConstrained (const CCTK_INT ConstrainedIndex);
CCTK_INT MoLChangeToConstrained (const CCTK_INT ConstrainedIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToConstrained_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToConstrained has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToConstrained_C_Wrapper)(ConstrainedIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLChangeToConstrained) (const CCTK_INT* ConstrainedIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLChangeToConstrained) (const CCTK_INT* ConstrainedIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToConstrained_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToConstrained has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToConstrained_F_Wrapper)(ConstrainedIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLChangeToConstrained(void);
CCTK_INT IsAliasedMoLChangeToConstrained(void)
{
  return (MoLChangeToConstrained_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLChangeToConstrained_C(CCTK_INT (*func)(const CCTK_INT ConstrainedIndex));
CCTK_INT AliasMoLChangeToConstrained_C(CCTK_INT (*func)(const CCTK_INT ConstrainedIndex))
{
  CCTK_INT aliased = MoLChangeToConstrained_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToConstrained_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLChangeToConstrained_F(CCTK_INT (*func)(const CCTK_INT* ConstrainedIndex));
CCTK_INT AliasMoLChangeToConstrained_F(CCTK_INT (*func)(const CCTK_INT* ConstrainedIndex))
{
  CCTK_INT aliased = MoLChangeToConstrained_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToConstrained_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLChangeToEvolved_C_Wrapper) (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex) = NULL;
static CCTK_INT (*MoLChangeToEvolved_F_Wrapper) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLChangeToEvolved (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex);
CCTK_INT MoLChangeToEvolved (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToEvolved_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToEvolved has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToEvolved_C_Wrapper)(EvolvedIndex , RHSIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLChangeToEvolved) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLChangeToEvolved) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToEvolved_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToEvolved has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToEvolved_F_Wrapper)(EvolvedIndex , RHSIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLChangeToEvolved(void);
CCTK_INT IsAliasedMoLChangeToEvolved(void)
{
  return (MoLChangeToEvolved_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLChangeToEvolved_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex));
CCTK_INT AliasMoLChangeToEvolved_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex))
{
  CCTK_INT aliased = MoLChangeToEvolved_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToEvolved_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLChangeToEvolved_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex));
CCTK_INT AliasMoLChangeToEvolved_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex))
{
  CCTK_INT aliased = MoLChangeToEvolved_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToEvolved_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLChangeToEvolvedSlow_C_Wrapper) (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow) = NULL;
static CCTK_INT (*MoLChangeToEvolvedSlow_F_Wrapper) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLChangeToEvolvedSlow (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow);
CCTK_INT MoLChangeToEvolvedSlow (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow)
{
  CCTK_INT retval;

  if (!MoLChangeToEvolvedSlow_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToEvolvedSlow has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToEvolvedSlow_C_Wrapper)(EvolvedIndex , RHSIndexSlow);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLChangeToEvolvedSlow) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLChangeToEvolvedSlow) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow)
{
  CCTK_INT retval;

  if (!MoLChangeToEvolvedSlow_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToEvolvedSlow has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToEvolvedSlow_F_Wrapper)(EvolvedIndex , RHSIndexSlow);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLChangeToEvolvedSlow(void);
CCTK_INT IsAliasedMoLChangeToEvolvedSlow(void)
{
  return (MoLChangeToEvolvedSlow_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLChangeToEvolvedSlow_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow));
CCTK_INT AliasMoLChangeToEvolvedSlow_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow))
{
  CCTK_INT aliased = MoLChangeToEvolvedSlow_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToEvolvedSlow_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLChangeToEvolvedSlow_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow));
CCTK_INT AliasMoLChangeToEvolvedSlow_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow))
{
  CCTK_INT aliased = MoLChangeToEvolvedSlow_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToEvolvedSlow_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLChangeToNone_C_Wrapper) (const CCTK_INT RemoveIndex) = NULL;
static CCTK_INT (*MoLChangeToNone_F_Wrapper) (const CCTK_INT* RemoveIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLChangeToNone (const CCTK_INT RemoveIndex);
CCTK_INT MoLChangeToNone (const CCTK_INT RemoveIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToNone_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToNone has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToNone_C_Wrapper)(RemoveIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLChangeToNone) (const CCTK_INT* RemoveIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLChangeToNone) (const CCTK_INT* RemoveIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToNone_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToNone has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToNone_F_Wrapper)(RemoveIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLChangeToNone(void);
CCTK_INT IsAliasedMoLChangeToNone(void)
{
  return (MoLChangeToNone_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLChangeToNone_C(CCTK_INT (*func)(const CCTK_INT RemoveIndex));
CCTK_INT AliasMoLChangeToNone_C(CCTK_INT (*func)(const CCTK_INT RemoveIndex))
{
  CCTK_INT aliased = MoLChangeToNone_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToNone_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLChangeToNone_F(CCTK_INT (*func)(const CCTK_INT* RemoveIndex));
CCTK_INT AliasMoLChangeToNone_F(CCTK_INT (*func)(const CCTK_INT* RemoveIndex))
{
  CCTK_INT aliased = MoLChangeToNone_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToNone_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLChangeToSaveAndRestore_C_Wrapper) (const CCTK_INT SandRIndex) = NULL;
static CCTK_INT (*MoLChangeToSaveAndRestore_F_Wrapper) (const CCTK_INT* SandRIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLChangeToSaveAndRestore (const CCTK_INT SandRIndex);
CCTK_INT MoLChangeToSaveAndRestore (const CCTK_INT SandRIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToSaveAndRestore_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToSaveAndRestore has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToSaveAndRestore_C_Wrapper)(SandRIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLChangeToSaveAndRestore) (const CCTK_INT* SandRIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLChangeToSaveAndRestore) (const CCTK_INT* SandRIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToSaveAndRestore_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToSaveAndRestore has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToSaveAndRestore_F_Wrapper)(SandRIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLChangeToSaveAndRestore(void);
CCTK_INT IsAliasedMoLChangeToSaveAndRestore(void)
{
  return (MoLChangeToSaveAndRestore_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLChangeToSaveAndRestore_C(CCTK_INT (*func)(const CCTK_INT SandRIndex));
CCTK_INT AliasMoLChangeToSaveAndRestore_C(CCTK_INT (*func)(const CCTK_INT SandRIndex))
{
  CCTK_INT aliased = MoLChangeToSaveAndRestore_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToSaveAndRestore_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLChangeToSaveAndRestore_F(CCTK_INT (*func)(const CCTK_INT* SandRIndex));
CCTK_INT AliasMoLChangeToSaveAndRestore_F(CCTK_INT (*func)(const CCTK_INT* SandRIndex))
{
  CCTK_INT aliased = MoLChangeToSaveAndRestore_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToSaveAndRestore_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLNumIntegratorSubsteps_C_Wrapper) (void) = NULL;
static CCTK_INT (*MoLNumIntegratorSubsteps_F_Wrapper) (void) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLNumIntegratorSubsteps (void);
CCTK_INT MoLNumIntegratorSubsteps (void)
{
  CCTK_INT retval;

  if (!MoLNumIntegratorSubsteps_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLNumIntegratorSubsteps has not been provided by any active thorn.");
  }

  retval = (*MoLNumIntegratorSubsteps_C_Wrapper)();
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLNumIntegratorSubsteps) (void);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLNumIntegratorSubsteps) (void)
{
  CCTK_INT retval;

  if (!MoLNumIntegratorSubsteps_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLNumIntegratorSubsteps has not been provided by any active thorn.");
  }

  retval = (*MoLNumIntegratorSubsteps_F_Wrapper)();
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLNumIntegratorSubsteps(void);
CCTK_INT IsAliasedMoLNumIntegratorSubsteps(void)
{
  return (MoLNumIntegratorSubsteps_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLNumIntegratorSubsteps_C(CCTK_INT (*func)(void));
CCTK_INT AliasMoLNumIntegratorSubsteps_C(CCTK_INT (*func)(void))
{
  CCTK_INT aliased = MoLNumIntegratorSubsteps_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLNumIntegratorSubsteps_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLNumIntegratorSubsteps_F(CCTK_INT (*func)(void));
CCTK_INT AliasMoLNumIntegratorSubsteps_F(CCTK_INT (*func)(void))
{
  CCTK_INT aliased = MoLNumIntegratorSubsteps_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLNumIntegratorSubsteps_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLQueryEvolvedRHS_C_Wrapper) (const CCTK_INT EvolvedIndex) = NULL;
static CCTK_INT (*MoLQueryEvolvedRHS_F_Wrapper) (const CCTK_INT* EvolvedIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLQueryEvolvedRHS (const CCTK_INT EvolvedIndex);
CCTK_INT MoLQueryEvolvedRHS (const CCTK_INT EvolvedIndex)
{
  CCTK_INT retval;

  if (!MoLQueryEvolvedRHS_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLQueryEvolvedRHS has not been provided by any active thorn.");
  }

  retval = (*MoLQueryEvolvedRHS_C_Wrapper)(EvolvedIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLQueryEvolvedRHS) (const CCTK_INT* EvolvedIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLQueryEvolvedRHS) (const CCTK_INT* EvolvedIndex)
{
  CCTK_INT retval;

  if (!MoLQueryEvolvedRHS_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLQueryEvolvedRHS has not been provided by any active thorn.");
  }

  retval = (*MoLQueryEvolvedRHS_F_Wrapper)(EvolvedIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLQueryEvolvedRHS(void);
CCTK_INT IsAliasedMoLQueryEvolvedRHS(void)
{
  return (MoLQueryEvolvedRHS_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLQueryEvolvedRHS_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex));
CCTK_INT AliasMoLQueryEvolvedRHS_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex))
{
  CCTK_INT aliased = MoLQueryEvolvedRHS_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLQueryEvolvedRHS_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLQueryEvolvedRHS_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex));
CCTK_INT AliasMoLQueryEvolvedRHS_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex))
{
  CCTK_INT aliased = MoLQueryEvolvedRHS_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLQueryEvolvedRHS_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterConstrained_C_Wrapper) (const CCTK_INT ConstrainedIndex) = NULL;
static CCTK_INT (*MoLRegisterConstrained_F_Wrapper) (const CCTK_INT* ConstrainedIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterConstrained (const CCTK_INT ConstrainedIndex);
CCTK_INT MoLRegisterConstrained (const CCTK_INT ConstrainedIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterConstrained_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterConstrained has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterConstrained_C_Wrapper)(ConstrainedIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterConstrained) (const CCTK_INT* ConstrainedIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterConstrained) (const CCTK_INT* ConstrainedIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterConstrained_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterConstrained has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterConstrained_F_Wrapper)(ConstrainedIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterConstrained(void);
CCTK_INT IsAliasedMoLRegisterConstrained(void)
{
  return (MoLRegisterConstrained_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterConstrained_C(CCTK_INT (*func)(const CCTK_INT ConstrainedIndex));
CCTK_INT AliasMoLRegisterConstrained_C(CCTK_INT (*func)(const CCTK_INT ConstrainedIndex))
{
  CCTK_INT aliased = MoLRegisterConstrained_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterConstrained_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterConstrained_F(CCTK_INT (*func)(const CCTK_INT* ConstrainedIndex));
CCTK_INT AliasMoLRegisterConstrained_F(CCTK_INT (*func)(const CCTK_INT* ConstrainedIndex))
{
  CCTK_INT aliased = MoLRegisterConstrained_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterConstrained_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterConstrainedGroup_C_Wrapper) (const CCTK_INT ConstrainedIndex) = NULL;
static CCTK_INT (*MoLRegisterConstrainedGroup_F_Wrapper) (const CCTK_INT* ConstrainedIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterConstrainedGroup (const CCTK_INT ConstrainedIndex);
CCTK_INT MoLRegisterConstrainedGroup (const CCTK_INT ConstrainedIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterConstrainedGroup_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterConstrainedGroup has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterConstrainedGroup_C_Wrapper)(ConstrainedIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterConstrainedGroup) (const CCTK_INT* ConstrainedIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterConstrainedGroup) (const CCTK_INT* ConstrainedIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterConstrainedGroup_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterConstrainedGroup has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterConstrainedGroup_F_Wrapper)(ConstrainedIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterConstrainedGroup(void);
CCTK_INT IsAliasedMoLRegisterConstrainedGroup(void)
{
  return (MoLRegisterConstrainedGroup_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterConstrainedGroup_C(CCTK_INT (*func)(const CCTK_INT ConstrainedIndex));
CCTK_INT AliasMoLRegisterConstrainedGroup_C(CCTK_INT (*func)(const CCTK_INT ConstrainedIndex))
{
  CCTK_INT aliased = MoLRegisterConstrainedGroup_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterConstrainedGroup_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterConstrainedGroup_F(CCTK_INT (*func)(const CCTK_INT* ConstrainedIndex));
CCTK_INT AliasMoLRegisterConstrainedGroup_F(CCTK_INT (*func)(const CCTK_INT* ConstrainedIndex))
{
  CCTK_INT aliased = MoLRegisterConstrainedGroup_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterConstrainedGroup_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterEvolved_C_Wrapper) (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex) = NULL;
static CCTK_INT (*MoLRegisterEvolved_F_Wrapper) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterEvolved (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex);
CCTK_INT MoLRegisterEvolved (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolved_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolved has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterEvolved_C_Wrapper)(EvolvedIndex , RHSIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterEvolved) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterEvolved) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolved_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolved has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterEvolved_F_Wrapper)(EvolvedIndex , RHSIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterEvolved(void);
CCTK_INT IsAliasedMoLRegisterEvolved(void)
{
  return (MoLRegisterEvolved_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterEvolved_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex));
CCTK_INT AliasMoLRegisterEvolved_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex))
{
  CCTK_INT aliased = MoLRegisterEvolved_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolved_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterEvolved_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex));
CCTK_INT AliasMoLRegisterEvolved_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex))
{
  CCTK_INT aliased = MoLRegisterEvolved_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolved_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterEvolvedGroup_C_Wrapper) (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex) = NULL;
static CCTK_INT (*MoLRegisterEvolvedGroup_F_Wrapper) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterEvolvedGroup (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex);
CCTK_INT MoLRegisterEvolvedGroup (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolvedGroup_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolvedGroup has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterEvolvedGroup_C_Wrapper)(EvolvedIndex , RHSIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterEvolvedGroup) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterEvolvedGroup) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolvedGroup_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolvedGroup has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterEvolvedGroup_F_Wrapper)(EvolvedIndex , RHSIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterEvolvedGroup(void);
CCTK_INT IsAliasedMoLRegisterEvolvedGroup(void)
{
  return (MoLRegisterEvolvedGroup_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterEvolvedGroup_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex));
CCTK_INT AliasMoLRegisterEvolvedGroup_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex))
{
  CCTK_INT aliased = MoLRegisterEvolvedGroup_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolvedGroup_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterEvolvedGroup_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex));
CCTK_INT AliasMoLRegisterEvolvedGroup_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex))
{
  CCTK_INT aliased = MoLRegisterEvolvedGroup_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolvedGroup_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterEvolvedGroupSlow_C_Wrapper) (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow) = NULL;
static CCTK_INT (*MoLRegisterEvolvedGroupSlow_F_Wrapper) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterEvolvedGroupSlow (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow);
CCTK_INT MoLRegisterEvolvedGroupSlow (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolvedGroupSlow_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolvedGroupSlow has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterEvolvedGroupSlow_C_Wrapper)(EvolvedIndex , RHSIndexSlow);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterEvolvedGroupSlow) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterEvolvedGroupSlow) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolvedGroupSlow_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolvedGroupSlow has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterEvolvedGroupSlow_F_Wrapper)(EvolvedIndex , RHSIndexSlow);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterEvolvedGroupSlow(void);
CCTK_INT IsAliasedMoLRegisterEvolvedGroupSlow(void)
{
  return (MoLRegisterEvolvedGroupSlow_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterEvolvedGroupSlow_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow));
CCTK_INT AliasMoLRegisterEvolvedGroupSlow_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow))
{
  CCTK_INT aliased = MoLRegisterEvolvedGroupSlow_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolvedGroupSlow_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterEvolvedGroupSlow_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow));
CCTK_INT AliasMoLRegisterEvolvedGroupSlow_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow))
{
  CCTK_INT aliased = MoLRegisterEvolvedGroupSlow_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolvedGroupSlow_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterEvolvedSlow_C_Wrapper) (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow) = NULL;
static CCTK_INT (*MoLRegisterEvolvedSlow_F_Wrapper) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterEvolvedSlow (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow);
CCTK_INT MoLRegisterEvolvedSlow (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolvedSlow_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolvedSlow has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterEvolvedSlow_C_Wrapper)(EvolvedIndex , RHSIndexSlow);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterEvolvedSlow) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterEvolvedSlow) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolvedSlow_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolvedSlow has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterEvolvedSlow_F_Wrapper)(EvolvedIndex , RHSIndexSlow);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterEvolvedSlow(void);
CCTK_INT IsAliasedMoLRegisterEvolvedSlow(void)
{
  return (MoLRegisterEvolvedSlow_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterEvolvedSlow_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow));
CCTK_INT AliasMoLRegisterEvolvedSlow_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow))
{
  CCTK_INT aliased = MoLRegisterEvolvedSlow_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolvedSlow_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterEvolvedSlow_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow));
CCTK_INT AliasMoLRegisterEvolvedSlow_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow))
{
  CCTK_INT aliased = MoLRegisterEvolvedSlow_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolvedSlow_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterSaveAndRestore_C_Wrapper) (const CCTK_INT SandRIndex) = NULL;
static CCTK_INT (*MoLRegisterSaveAndRestore_F_Wrapper) (const CCTK_INT* SandRIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterSaveAndRestore (const CCTK_INT SandRIndex);
CCTK_INT MoLRegisterSaveAndRestore (const CCTK_INT SandRIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterSaveAndRestore_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterSaveAndRestore has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterSaveAndRestore_C_Wrapper)(SandRIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterSaveAndRestore) (const CCTK_INT* SandRIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterSaveAndRestore) (const CCTK_INT* SandRIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterSaveAndRestore_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterSaveAndRestore has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterSaveAndRestore_F_Wrapper)(SandRIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterSaveAndRestore(void);
CCTK_INT IsAliasedMoLRegisterSaveAndRestore(void)
{
  return (MoLRegisterSaveAndRestore_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterSaveAndRestore_C(CCTK_INT (*func)(const CCTK_INT SandRIndex));
CCTK_INT AliasMoLRegisterSaveAndRestore_C(CCTK_INT (*func)(const CCTK_INT SandRIndex))
{
  CCTK_INT aliased = MoLRegisterSaveAndRestore_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterSaveAndRestore_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterSaveAndRestore_F(CCTK_INT (*func)(const CCTK_INT* SandRIndex));
CCTK_INT AliasMoLRegisterSaveAndRestore_F(CCTK_INT (*func)(const CCTK_INT* SandRIndex))
{
  CCTK_INT aliased = MoLRegisterSaveAndRestore_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterSaveAndRestore_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterSaveAndRestoreGroup_C_Wrapper) (const CCTK_INT SandRIndex) = NULL;
static CCTK_INT (*MoLRegisterSaveAndRestoreGroup_F_Wrapper) (const CCTK_INT* SandRIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterSaveAndRestoreGroup (const CCTK_INT SandRIndex);
CCTK_INT MoLRegisterSaveAndRestoreGroup (const CCTK_INT SandRIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterSaveAndRestoreGroup_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterSaveAndRestoreGroup has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterSaveAndRestoreGroup_C_Wrapper)(SandRIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterSaveAndRestoreGroup) (const CCTK_INT* SandRIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterSaveAndRestoreGroup) (const CCTK_INT* SandRIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterSaveAndRestoreGroup_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterSaveAndRestoreGroup has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterSaveAndRestoreGroup_F_Wrapper)(SandRIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterSaveAndRestoreGroup(void);
CCTK_INT IsAliasedMoLRegisterSaveAndRestoreGroup(void)
{
  return (MoLRegisterSaveAndRestoreGroup_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterSaveAndRestoreGroup_C(CCTK_INT (*func)(const CCTK_INT SandRIndex));
CCTK_INT AliasMoLRegisterSaveAndRestoreGroup_C(CCTK_INT (*func)(const CCTK_INT SandRIndex))
{
  CCTK_INT aliased = MoLRegisterSaveAndRestoreGroup_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterSaveAndRestoreGroup_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterSaveAndRestoreGroup_F(CCTK_INT (*func)(const CCTK_INT* SandRIndex));
CCTK_INT AliasMoLRegisterSaveAndRestoreGroup_F(CCTK_INT (*func)(const CCTK_INT* SandRIndex))
{
  CCTK_INT aliased = MoLRegisterSaveAndRestoreGroup_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterSaveAndRestoreGroup_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatchInterpGridArrays_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT order ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT* interp_maps ,
 const CCTK_POINTER_TO_CONST interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_POINTER output_arrays) = NULL;
static CCTK_INT (*MultiPatchInterpGridArrays_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* order ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_maps ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_POINTER* output_arrays) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatchInterpGridArrays (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT order ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT* interp_maps ,
 const CCTK_POINTER_TO_CONST interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_POINTER output_arrays);
CCTK_INT MultiPatchInterpGridArrays (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT order ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT* interp_maps ,
 const CCTK_POINTER_TO_CONST interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_POINTER output_arrays)
{
  CCTK_INT retval;

  if (!MultiPatchInterpGridArrays_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatchInterpGridArrays has not been provided by any active thorn.");
  }

  retval = (*MultiPatchInterpGridArrays_C_Wrapper)(cctkGH , N_dims , order , N_interp_points , interp_maps , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_arrays);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatchInterpGridArrays) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* order ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_maps ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_POINTER* output_arrays);
CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatchInterpGridArrays) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* order ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_maps ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_POINTER* output_arrays)
{
  CCTK_INT retval;

  if (!MultiPatchInterpGridArrays_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatchInterpGridArrays has not been provided by any active thorn.");
  }

  retval = (*MultiPatchInterpGridArrays_F_Wrapper)(cctkGH , N_dims , order , N_interp_points , interp_maps , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_arrays);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatchInterpGridArrays(void);
CCTK_INT IsAliasedMultiPatchInterpGridArrays(void)
{
  return (MultiPatchInterpGridArrays_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatchInterpGridArrays_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT order ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT* interp_maps ,
 const CCTK_POINTER_TO_CONST interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_POINTER output_arrays));
CCTK_INT AliasMultiPatchInterpGridArrays_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT order ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT* interp_maps ,
 const CCTK_POINTER_TO_CONST interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_POINTER output_arrays))
{
  CCTK_INT aliased = MultiPatchInterpGridArrays_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatchInterpGridArrays_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatchInterpGridArrays_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* order ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_maps ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_POINTER* output_arrays));
CCTK_INT AliasMultiPatchInterpGridArrays_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* order ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_maps ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_POINTER* output_arrays))
{
  CCTK_INT aliased = MultiPatchInterpGridArrays_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatchInterpGridArrays_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper) (const CCTK_INT map ,
 const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;
static CCTK_INT (*MultiPatch_ConvertFromPhysicalBoundary_F_Wrapper) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_ConvertFromPhysicalBoundary (const CCTK_INT map ,
 const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT MultiPatch_ConvertFromPhysicalBoundary (const CCTK_INT map ,
 const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_ConvertFromPhysicalBoundary has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper)(map , size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_ConvertFromPhysicalBoundary) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_ConvertFromPhysicalBoundary) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!MultiPatch_ConvertFromPhysicalBoundary_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_ConvertFromPhysicalBoundary has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_ConvertFromPhysicalBoundary_F_Wrapper)(map , size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_ConvertFromPhysicalBoundary(void);
CCTK_INT IsAliasedMultiPatch_ConvertFromPhysicalBoundary(void)
{
  return (MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_ConvertFromPhysicalBoundary_C(CCTK_INT (*func)(const CCTK_INT map ,
 const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasMultiPatch_ConvertFromPhysicalBoundary_C(CCTK_INT (*func)(const CCTK_INT map ,
 const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_ConvertFromPhysicalBoundary_F(CCTK_INT (*func)(const CCTK_INT* map ,
 const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasMultiPatch_ConvertFromPhysicalBoundary_F(CCTK_INT (*func)(const CCTK_INT* map ,
 const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_ConvertFromPhysicalBoundary_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_GetBbox_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bbox) = NULL;
static CCTK_INT (*MultiPatch_GetBbox_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bbox) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_GetBbox (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bbox);
CCTK_INT MultiPatch_GetBbox (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bbox)
{
  CCTK_INT retval;

  if (!MultiPatch_GetBbox_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetBbox has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetBbox_C_Wrapper)(cctkGH , size , bbox);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetBbox) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bbox);
CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetBbox) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bbox)
{
  CCTK_INT retval;

  if (!MultiPatch_GetBbox_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetBbox has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetBbox_F_Wrapper)(cctkGH , size , bbox);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_GetBbox(void);
CCTK_INT IsAliasedMultiPatch_GetBbox(void)
{
  return (MultiPatch_GetBbox_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_GetBbox_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bbox));
CCTK_INT AliasMultiPatch_GetBbox_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bbox))
{
  CCTK_INT aliased = MultiPatch_GetBbox_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetBbox_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_GetBbox_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bbox));
CCTK_INT AliasMultiPatch_GetBbox_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bbox))
{
  CCTK_INT aliased = MultiPatch_GetBbox_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetBbox_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_GetBoundarySpecification_C_Wrapper) (const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout) = NULL;
static CCTK_INT (*MultiPatch_GetBoundarySpecification_F_Wrapper) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_GetBoundarySpecification (const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout);
CCTK_INT MultiPatch_GetBoundarySpecification (const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout)
{
  CCTK_INT retval;

  if (!MultiPatch_GetBoundarySpecification_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetBoundarySpecification has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetBoundarySpecification_C_Wrapper)(map , size , nboundaryzones , is_internal , is_staggered , shiftout);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetBoundarySpecification) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout);
CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetBoundarySpecification) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout)
{
  CCTK_INT retval;

  if (!MultiPatch_GetBoundarySpecification_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetBoundarySpecification has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetBoundarySpecification_F_Wrapper)(map , size , nboundaryzones , is_internal , is_staggered , shiftout);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_GetBoundarySpecification(void);
CCTK_INT IsAliasedMultiPatch_GetBoundarySpecification(void)
{
  return (MultiPatch_GetBoundarySpecification_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_GetBoundarySpecification_C(CCTK_INT (*func)(const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout));
CCTK_INT AliasMultiPatch_GetBoundarySpecification_C(CCTK_INT (*func)(const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout))
{
  CCTK_INT aliased = MultiPatch_GetBoundarySpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetBoundarySpecification_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_GetBoundarySpecification_F(CCTK_INT (*func)(const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout));
CCTK_INT AliasMultiPatch_GetBoundarySpecification_F(CCTK_INT (*func)(const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout))
{
  CCTK_INT aliased = MultiPatch_GetBoundarySpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetBoundarySpecification_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_GetDomainSpecification_C_Wrapper) (const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing) = NULL;
static CCTK_INT (*MultiPatch_GetDomainSpecification_F_Wrapper) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_GetDomainSpecification (const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing);
CCTK_INT MultiPatch_GetDomainSpecification (const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!MultiPatch_GetDomainSpecification_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetDomainSpecification has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetDomainSpecification_C_Wrapper)(map , size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetDomainSpecification) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing);
CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetDomainSpecification) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!MultiPatch_GetDomainSpecification_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetDomainSpecification has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetDomainSpecification_F_Wrapper)(map , size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_GetDomainSpecification(void);
CCTK_INT IsAliasedMultiPatch_GetDomainSpecification(void)
{
  return (MultiPatch_GetDomainSpecification_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_GetDomainSpecification_C(CCTK_INT (*func)(const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing));
CCTK_INT AliasMultiPatch_GetDomainSpecification_C(CCTK_INT (*func)(const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing))
{
  CCTK_INT aliased = MultiPatch_GetDomainSpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetDomainSpecification_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_GetDomainSpecification_F(CCTK_INT (*func)(const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing));
CCTK_INT AliasMultiPatch_GetDomainSpecification_F(CCTK_INT (*func)(const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing))
{
  CCTK_INT aliased = MultiPatch_GetDomainSpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetDomainSpecification_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_GetMap_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*MultiPatch_GetMap_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_GetMap (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT MultiPatch_GetMap (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!MultiPatch_GetMap_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetMap has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetMap_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetMap) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetMap) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!MultiPatch_GetMap_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetMap has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetMap_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_GetMap(void);
CCTK_INT IsAliasedMultiPatch_GetMap(void)
{
  return (MultiPatch_GetMap_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_GetMap_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasMultiPatch_GetMap_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = MultiPatch_GetMap_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetMap_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_GetMap_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasMultiPatch_GetMap_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = MultiPatch_GetMap_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetMap_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_GetMaps_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*MultiPatch_GetMaps_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_GetMaps (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT MultiPatch_GetMaps (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!MultiPatch_GetMaps_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetMaps has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetMaps_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetMaps) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetMaps) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!MultiPatch_GetMaps_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetMaps has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetMaps_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_GetMaps(void);
CCTK_INT IsAliasedMultiPatch_GetMaps(void)
{
  return (MultiPatch_GetMaps_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_GetMaps_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasMultiPatch_GetMaps_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = MultiPatch_GetMaps_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetMaps_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_GetMaps_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasMultiPatch_GetMaps_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = MultiPatch_GetMaps_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetMaps_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_GetSystemSpecification_C_Wrapper) (CCTK_INT* maps) = NULL;
static CCTK_INT (*MultiPatch_GetSystemSpecification_F_Wrapper) (CCTK_INT* maps) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_GetSystemSpecification (CCTK_INT* maps);
CCTK_INT MultiPatch_GetSystemSpecification (CCTK_INT* maps)
{
  CCTK_INT retval;

  if (!MultiPatch_GetSystemSpecification_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetSystemSpecification has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetSystemSpecification_C_Wrapper)(maps);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetSystemSpecification) (CCTK_INT* maps);
CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetSystemSpecification) (CCTK_INT* maps)
{
  CCTK_INT retval;

  if (!MultiPatch_GetSystemSpecification_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetSystemSpecification has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetSystemSpecification_F_Wrapper)(maps);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_GetSystemSpecification(void);
CCTK_INT IsAliasedMultiPatch_GetSystemSpecification(void)
{
  return (MultiPatch_GetSystemSpecification_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_GetSystemSpecification_C(CCTK_INT (*func)(CCTK_INT* maps));
CCTK_INT AliasMultiPatch_GetSystemSpecification_C(CCTK_INT (*func)(CCTK_INT* maps))
{
  CCTK_INT aliased = MultiPatch_GetSystemSpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetSystemSpecification_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_GetSystemSpecification_F(CCTK_INT (*func)(CCTK_INT* maps));
CCTK_INT AliasMultiPatch_GetSystemSpecification_F(CCTK_INT (*func)(CCTK_INT* maps))
{
  CCTK_INT aliased = MultiPatch_GetSystemSpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetSystemSpecification_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_GlobalToLocal_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT ndims ,
 const CCTK_INT npoints ,
 const CCTK_POINTER_TO_CONST globalcoords ,
 CCTK_INT* patch ,
 const CCTK_POINTER localcoords ,
 const CCTK_POINTER dadx ,
 const CCTK_POINTER ddadxdx) = NULL;
static CCTK_INT (*MultiPatch_GlobalToLocal_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* ndims ,
 const CCTK_INT* npoints ,
 const CCTK_POINTER_TO_CONST* globalcoords ,
 CCTK_INT* patch ,
 const CCTK_POINTER* localcoords ,
 const CCTK_POINTER* dadx ,
 const CCTK_POINTER* ddadxdx) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_GlobalToLocal (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT ndims ,
 const CCTK_INT npoints ,
 const CCTK_POINTER_TO_CONST globalcoords ,
 CCTK_INT* patch ,
 const CCTK_POINTER localcoords ,
 const CCTK_POINTER dadx ,
 const CCTK_POINTER ddadxdx);
CCTK_INT MultiPatch_GlobalToLocal (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT ndims ,
 const CCTK_INT npoints ,
 const CCTK_POINTER_TO_CONST globalcoords ,
 CCTK_INT* patch ,
 const CCTK_POINTER localcoords ,
 const CCTK_POINTER dadx ,
 const CCTK_POINTER ddadxdx)
{
  CCTK_INT retval;

  if (!MultiPatch_GlobalToLocal_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GlobalToLocal has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GlobalToLocal_C_Wrapper)(cctkGH , ndims , npoints , globalcoords , patch , localcoords , dadx , ddadxdx);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GlobalToLocal) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* ndims ,
 const CCTK_INT* npoints ,
 const CCTK_POINTER_TO_CONST* globalcoords ,
 CCTK_INT* patch ,
 const CCTK_POINTER* localcoords ,
 const CCTK_POINTER* dadx ,
 const CCTK_POINTER* ddadxdx);
CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GlobalToLocal) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* ndims ,
 const CCTK_INT* npoints ,
 const CCTK_POINTER_TO_CONST* globalcoords ,
 CCTK_INT* patch ,
 const CCTK_POINTER* localcoords ,
 const CCTK_POINTER* dadx ,
 const CCTK_POINTER* ddadxdx)
{
  CCTK_INT retval;

  if (!MultiPatch_GlobalToLocal_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GlobalToLocal has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GlobalToLocal_F_Wrapper)(cctkGH , ndims , npoints , globalcoords , patch , localcoords , dadx , ddadxdx);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_GlobalToLocal(void);
CCTK_INT IsAliasedMultiPatch_GlobalToLocal(void)
{
  return (MultiPatch_GlobalToLocal_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_GlobalToLocal_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT ndims ,
 const CCTK_INT npoints ,
 const CCTK_POINTER_TO_CONST globalcoords ,
 CCTK_INT* patch ,
 const CCTK_POINTER localcoords ,
 const CCTK_POINTER dadx ,
 const CCTK_POINTER ddadxdx));
CCTK_INT AliasMultiPatch_GlobalToLocal_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT ndims ,
 const CCTK_INT npoints ,
 const CCTK_POINTER_TO_CONST globalcoords ,
 CCTK_INT* patch ,
 const CCTK_POINTER localcoords ,
 const CCTK_POINTER dadx ,
 const CCTK_POINTER ddadxdx))
{
  CCTK_INT aliased = MultiPatch_GlobalToLocal_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GlobalToLocal_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_GlobalToLocal_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* ndims ,
 const CCTK_INT* npoints ,
 const CCTK_POINTER_TO_CONST* globalcoords ,
 CCTK_INT* patch ,
 const CCTK_POINTER* localcoords ,
 const CCTK_POINTER* dadx ,
 const CCTK_POINTER* ddadxdx));
CCTK_INT AliasMultiPatch_GlobalToLocal_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* ndims ,
 const CCTK_INT* npoints ,
 const CCTK_POINTER_TO_CONST* globalcoords ,
 CCTK_INT* patch ,
 const CCTK_POINTER* localcoords ,
 const CCTK_POINTER* dadx ,
 const CCTK_POINTER* ddadxdx))
{
  CCTK_INT aliased = MultiPatch_GlobalToLocal_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GlobalToLocal_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_LocalToGlobal_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT ndims ,
 const CCTK_INT npoints ,
 const CCTK_INT* patch ,
 const CCTK_POINTER_TO_CONST localcoords ,
 const CCTK_POINTER globalcoords ,
 const CCTK_POINTER dxda ,
 const CCTK_POINTER det_dxda ,
 const CCTK_POINTER dadx ,
 const CCTK_POINTER ddxdada ,
 const CCTK_POINTER ddadxdx ,
 const CCTK_POINTER dddxdadada) = NULL;
static CCTK_INT (*MultiPatch_LocalToGlobal_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* ndims ,
 const CCTK_INT* npoints ,
 const CCTK_INT* patch ,
 const CCTK_POINTER_TO_CONST* localcoords ,
 const CCTK_POINTER* globalcoords ,
 const CCTK_POINTER* dxda ,
 const CCTK_POINTER* det_dxda ,
 const CCTK_POINTER* dadx ,
 const CCTK_POINTER* ddxdada ,
 const CCTK_POINTER* ddadxdx ,
 const CCTK_POINTER* dddxdadada) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_LocalToGlobal (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT ndims ,
 const CCTK_INT npoints ,
 const CCTK_INT* patch ,
 const CCTK_POINTER_TO_CONST localcoords ,
 const CCTK_POINTER globalcoords ,
 const CCTK_POINTER dxda ,
 const CCTK_POINTER det_dxda ,
 const CCTK_POINTER dadx ,
 const CCTK_POINTER ddxdada ,
 const CCTK_POINTER ddadxdx ,
 const CCTK_POINTER dddxdadada);
CCTK_INT MultiPatch_LocalToGlobal (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT ndims ,
 const CCTK_INT npoints ,
 const CCTK_INT* patch ,
 const CCTK_POINTER_TO_CONST localcoords ,
 const CCTK_POINTER globalcoords ,
 const CCTK_POINTER dxda ,
 const CCTK_POINTER det_dxda ,
 const CCTK_POINTER dadx ,
 const CCTK_POINTER ddxdada ,
 const CCTK_POINTER ddadxdx ,
 const CCTK_POINTER dddxdadada)
{
  CCTK_INT retval;

  if (!MultiPatch_LocalToGlobal_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_LocalToGlobal has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_LocalToGlobal_C_Wrapper)(cctkGH , ndims , npoints , patch , localcoords , globalcoords , dxda , det_dxda , dadx , ddxdada , ddadxdx , dddxdadada);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_LocalToGlobal) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* ndims ,
 const CCTK_INT* npoints ,
 const CCTK_INT* patch ,
 const CCTK_POINTER_TO_CONST* localcoords ,
 const CCTK_POINTER* globalcoords ,
 const CCTK_POINTER* dxda ,
 const CCTK_POINTER* det_dxda ,
 const CCTK_POINTER* dadx ,
 const CCTK_POINTER* ddxdada ,
 const CCTK_POINTER* ddadxdx ,
 const CCTK_POINTER* dddxdadada);
CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_LocalToGlobal) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* ndims ,
 const CCTK_INT* npoints ,
 const CCTK_INT* patch ,
 const CCTK_POINTER_TO_CONST* localcoords ,
 const CCTK_POINTER* globalcoords ,
 const CCTK_POINTER* dxda ,
 const CCTK_POINTER* det_dxda ,
 const CCTK_POINTER* dadx ,
 const CCTK_POINTER* ddxdada ,
 const CCTK_POINTER* ddadxdx ,
 const CCTK_POINTER* dddxdadada)
{
  CCTK_INT retval;

  if (!MultiPatch_LocalToGlobal_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_LocalToGlobal has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_LocalToGlobal_F_Wrapper)(cctkGH , ndims , npoints , patch , localcoords , globalcoords , dxda , det_dxda , dadx , ddxdada , ddadxdx , dddxdadada);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_LocalToGlobal(void);
CCTK_INT IsAliasedMultiPatch_LocalToGlobal(void)
{
  return (MultiPatch_LocalToGlobal_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_LocalToGlobal_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT ndims ,
 const CCTK_INT npoints ,
 const CCTK_INT* patch ,
 const CCTK_POINTER_TO_CONST localcoords ,
 const CCTK_POINTER globalcoords ,
 const CCTK_POINTER dxda ,
 const CCTK_POINTER det_dxda ,
 const CCTK_POINTER dadx ,
 const CCTK_POINTER ddxdada ,
 const CCTK_POINTER ddadxdx ,
 const CCTK_POINTER dddxdadada));
CCTK_INT AliasMultiPatch_LocalToGlobal_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT ndims ,
 const CCTK_INT npoints ,
 const CCTK_INT* patch ,
 const CCTK_POINTER_TO_CONST localcoords ,
 const CCTK_POINTER globalcoords ,
 const CCTK_POINTER dxda ,
 const CCTK_POINTER det_dxda ,
 const CCTK_POINTER dadx ,
 const CCTK_POINTER ddxdada ,
 const CCTK_POINTER ddadxdx ,
 const CCTK_POINTER dddxdadada))
{
  CCTK_INT aliased = MultiPatch_LocalToGlobal_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_LocalToGlobal_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_LocalToGlobal_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* ndims ,
 const CCTK_INT* npoints ,
 const CCTK_INT* patch ,
 const CCTK_POINTER_TO_CONST* localcoords ,
 const CCTK_POINTER* globalcoords ,
 const CCTK_POINTER* dxda ,
 const CCTK_POINTER* det_dxda ,
 const CCTK_POINTER* dadx ,
 const CCTK_POINTER* ddxdada ,
 const CCTK_POINTER* ddadxdx ,
 const CCTK_POINTER* dddxdadada));
CCTK_INT AliasMultiPatch_LocalToGlobal_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* ndims ,
 const CCTK_INT* npoints ,
 const CCTK_INT* patch ,
 const CCTK_POINTER_TO_CONST* localcoords ,
 const CCTK_POINTER* globalcoords ,
 const CCTK_POINTER* dxda ,
 const CCTK_POINTER* det_dxda ,
 const CCTK_POINTER* dadx ,
 const CCTK_POINTER* ddxdada ,
 const CCTK_POINTER* ddadxdx ,
 const CCTK_POINTER* dddxdadada))
{
  CCTK_INT aliased = MultiPatch_LocalToGlobal_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_LocalToGlobal_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_MapIsCartesian_C_Wrapper) (const CCTK_INT map) = NULL;
static CCTK_INT (*MultiPatch_MapIsCartesian_F_Wrapper) (const CCTK_INT* map) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_MapIsCartesian (const CCTK_INT map);
CCTK_INT MultiPatch_MapIsCartesian (const CCTK_INT map)
{
  CCTK_INT retval;

  if (!MultiPatch_MapIsCartesian_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_MapIsCartesian has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_MapIsCartesian_C_Wrapper)(map);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_MapIsCartesian) (const CCTK_INT* map);
CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_MapIsCartesian) (const CCTK_INT* map)
{
  CCTK_INT retval;

  if (!MultiPatch_MapIsCartesian_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_MapIsCartesian has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_MapIsCartesian_F_Wrapper)(map);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_MapIsCartesian(void);
CCTK_INT IsAliasedMultiPatch_MapIsCartesian(void)
{
  return (MultiPatch_MapIsCartesian_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_MapIsCartesian_C(CCTK_INT (*func)(const CCTK_INT map));
CCTK_INT AliasMultiPatch_MapIsCartesian_C(CCTK_INT (*func)(const CCTK_INT map))
{
  CCTK_INT aliased = MultiPatch_MapIsCartesian_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_MapIsCartesian_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_MapIsCartesian_F(CCTK_INT (*func)(const CCTK_INT* map));
CCTK_INT AliasMultiPatch_MapIsCartesian_F(CCTK_INT (*func)(const CCTK_INT* map))
{
  CCTK_INT aliased = MultiPatch_MapIsCartesian_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_MapIsCartesian_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*NewRad_Apply_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL var0 ,
 const CCTK_REAL v0 ,
 const CCTK_INT radpower) = NULL;
static CCTK_INT (*NewRad_Apply_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL* var0 ,
 const CCTK_REAL* v0 ,
 const CCTK_INT* radpower) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT NewRad_Apply (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL var0 ,
 const CCTK_REAL v0 ,
 const CCTK_INT radpower);
CCTK_INT NewRad_Apply (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL var0 ,
 const CCTK_REAL v0 ,
 const CCTK_INT radpower)
{
  CCTK_INT retval;

  if (!NewRad_Apply_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function NewRad_Apply has not been provided by any active thorn.");
  }

  retval = (*NewRad_Apply_C_Wrapper)(cctkGH , var , rhs , var0 , v0 , radpower);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(NewRad_Apply) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL* var0 ,
 const CCTK_REAL* v0 ,
 const CCTK_INT* radpower);
CCTK_INT CCTK_FCALL CCTK_FNAME(NewRad_Apply) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL* var0 ,
 const CCTK_REAL* v0 ,
 const CCTK_INT* radpower)
{
  CCTK_INT retval;

  if (!NewRad_Apply_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function NewRad_Apply has not been provided by any active thorn.");
  }

  retval = (*NewRad_Apply_F_Wrapper)(cctkGH , var , rhs , var0 , v0 , radpower);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedNewRad_Apply(void);
CCTK_INT IsAliasedNewRad_Apply(void)
{
  return (NewRad_Apply_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasNewRad_Apply_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL var0 ,
 const CCTK_REAL v0 ,
 const CCTK_INT radpower));
CCTK_INT AliasNewRad_Apply_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL var0 ,
 const CCTK_REAL v0 ,
 const CCTK_INT radpower))
{
  CCTK_INT aliased = NewRad_Apply_C_Wrapper != NULL;
  if (!aliased)
  {
    NewRad_Apply_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasNewRad_Apply_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL* var0 ,
 const CCTK_REAL* v0 ,
 const CCTK_INT* radpower));
CCTK_INT AliasNewRad_Apply_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL* var0 ,
 const CCTK_REAL* v0 ,
 const CCTK_INT* radpower))
{
  CCTK_INT aliased = NewRad_Apply_C_Wrapper != NULL;
  if (!aliased)
  {
    NewRad_Apply_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Periodic_ApplyGI_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT group_index) = NULL;
static CCTK_INT (*Periodic_ApplyGI_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT* group_index) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Periodic_ApplyGI (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT group_index);
CCTK_INT Periodic_ApplyGI (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT group_index)
{
  CCTK_INT retval;

  if (!Periodic_ApplyGI_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Periodic_ApplyGI has not been provided by any active thorn.");
  }

  retval = (*Periodic_ApplyGI_C_Wrapper)(cctkGH , size , stencil , do_periodic , group_index);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Periodic_ApplyGI) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT* group_index);
CCTK_INT CCTK_FCALL CCTK_FNAME(Periodic_ApplyGI) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT* group_index)
{
  CCTK_INT retval;

  if (!Periodic_ApplyGI_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Periodic_ApplyGI has not been provided by any active thorn.");
  }

  retval = (*Periodic_ApplyGI_F_Wrapper)(cctkGH , size , stencil , do_periodic , group_index);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPeriodic_ApplyGI(void);
CCTK_INT IsAliasedPeriodic_ApplyGI(void)
{
  return (Periodic_ApplyGI_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPeriodic_ApplyGI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT group_index));
CCTK_INT AliasPeriodic_ApplyGI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT group_index))
{
  CCTK_INT aliased = Periodic_ApplyGI_C_Wrapper != NULL;
  if (!aliased)
  {
    Periodic_ApplyGI_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPeriodic_ApplyGI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT* group_index));
CCTK_INT AliasPeriodic_ApplyGI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT* group_index))
{
  CCTK_INT aliased = Periodic_ApplyGI_C_Wrapper != NULL;
  if (!aliased)
  {
    Periodic_ApplyGI_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Periodic_ApplyGN_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 CCTK_STRING group_name) = NULL;
static CCTK_INT (*Periodic_ApplyGN_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 CCTK_STRING group_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Periodic_ApplyGN (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 CCTK_STRING group_name);
CCTK_INT Periodic_ApplyGN (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 CCTK_STRING group_name)
{
  CCTK_INT retval;

  if (!Periodic_ApplyGN_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Periodic_ApplyGN has not been provided by any active thorn.");
  }

  retval = (*Periodic_ApplyGN_C_Wrapper)(cctkGH , size , stencil , do_periodic , group_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Periodic_ApplyGN) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Periodic_ApplyGN) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Periodic_ApplyGN_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Periodic_ApplyGN has not been provided by any active thorn.");
  }

  retval = (*Periodic_ApplyGN_F_Wrapper)(cctkGH , size , stencil , do_periodic , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPeriodic_ApplyGN(void);
CCTK_INT IsAliasedPeriodic_ApplyGN(void)
{
  return (Periodic_ApplyGN_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPeriodic_ApplyGN_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 CCTK_STRING group_name));
CCTK_INT AliasPeriodic_ApplyGN_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 CCTK_STRING group_name))
{
  CCTK_INT aliased = Periodic_ApplyGN_C_Wrapper != NULL;
  if (!aliased)
  {
    Periodic_ApplyGN_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPeriodic_ApplyGN_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 CCTK_STRING group_name));
CCTK_INT AliasPeriodic_ApplyGN_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 CCTK_STRING group_name))
{
  CCTK_INT aliased = Periodic_ApplyGN_C_Wrapper != NULL;
  if (!aliased)
  {
    Periodic_ApplyGN_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Periodic_ApplyVI_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT var_index) = NULL;
static CCTK_INT (*Periodic_ApplyVI_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT* var_index) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Periodic_ApplyVI (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT var_index);
CCTK_INT Periodic_ApplyVI (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT var_index)
{
  CCTK_INT retval;

  if (!Periodic_ApplyVI_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Periodic_ApplyVI has not been provided by any active thorn.");
  }

  retval = (*Periodic_ApplyVI_C_Wrapper)(cctkGH , size , stencil , do_periodic , var_index);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Periodic_ApplyVI) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT* var_index);
CCTK_INT CCTK_FCALL CCTK_FNAME(Periodic_ApplyVI) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT* var_index)
{
  CCTK_INT retval;

  if (!Periodic_ApplyVI_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Periodic_ApplyVI has not been provided by any active thorn.");
  }

  retval = (*Periodic_ApplyVI_F_Wrapper)(cctkGH , size , stencil , do_periodic , var_index);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPeriodic_ApplyVI(void);
CCTK_INT IsAliasedPeriodic_ApplyVI(void)
{
  return (Periodic_ApplyVI_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPeriodic_ApplyVI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT var_index));
CCTK_INT AliasPeriodic_ApplyVI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT var_index))
{
  CCTK_INT aliased = Periodic_ApplyVI_C_Wrapper != NULL;
  if (!aliased)
  {
    Periodic_ApplyVI_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPeriodic_ApplyVI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT* var_index));
CCTK_INT AliasPeriodic_ApplyVI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 const CCTK_INT* var_index))
{
  CCTK_INT aliased = Periodic_ApplyVI_C_Wrapper != NULL;
  if (!aliased)
  {
    Periodic_ApplyVI_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Periodic_ApplyVN_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 CCTK_STRING var_name) = NULL;
static CCTK_INT (*Periodic_ApplyVN_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 CCTK_STRING var_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Periodic_ApplyVN (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 CCTK_STRING var_name);
CCTK_INT Periodic_ApplyVN (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 CCTK_STRING var_name)
{
  CCTK_INT retval;

  if (!Periodic_ApplyVN_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Periodic_ApplyVN has not been provided by any active thorn.");
  }

  retval = (*Periodic_ApplyVN_C_Wrapper)(cctkGH , size , stencil , do_periodic , var_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Periodic_ApplyVN) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Periodic_ApplyVN) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Periodic_ApplyVN_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Periodic_ApplyVN has not been provided by any active thorn.");
  }

  retval = (*Periodic_ApplyVN_F_Wrapper)(cctkGH , size , stencil , do_periodic , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPeriodic_ApplyVN(void);
CCTK_INT IsAliasedPeriodic_ApplyVN(void)
{
  return (Periodic_ApplyVN_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPeriodic_ApplyVN_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 CCTK_STRING var_name));
CCTK_INT AliasPeriodic_ApplyVN_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 CCTK_STRING var_name))
{
  CCTK_INT aliased = Periodic_ApplyVN_C_Wrapper != NULL;
  if (!aliased)
  {
    Periodic_ApplyVN_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPeriodic_ApplyVN_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 CCTK_STRING var_name));
CCTK_INT AliasPeriodic_ApplyVN_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_INT* stencil ,
 const CCTK_INT* do_periodic ,
 CCTK_STRING var_name))
{
  CCTK_INT aliased = Periodic_ApplyVN_C_Wrapper != NULL;
  if (!aliased)
  {
    Periodic_ApplyVN_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*PhysToConfInPlace_C_Wrapper) (const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz) = NULL;
static void (*PhysToConfInPlace_F_Wrapper) (const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void PhysToConfInPlace (const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz);
void PhysToConfInPlace (const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz)
{
  if (!PhysToConfInPlace_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PhysToConfInPlace has not been provided by any active thorn.");
  }

  (*PhysToConfInPlace_C_Wrapper)(nx , ny , nz , psi , gxx , gxy , gxz , gyy , gyz , gzz);
}

void CCTK_FCALL CCTK_FNAME(PhysToConfInPlace) (const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz);
void CCTK_FCALL CCTK_FNAME(PhysToConfInPlace) (const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz)
{
  if (!PhysToConfInPlace_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PhysToConfInPlace has not been provided by any active thorn.");
  }

  (*PhysToConfInPlace_F_Wrapper)(nx , ny , nz , psi , gxx , gxy , gxz , gyy , gyz , gzz);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPhysToConfInPlace(void);
CCTK_INT IsAliasedPhysToConfInPlace(void)
{
  return (PhysToConfInPlace_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPhysToConfInPlace_C(void (*func)(const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz));
CCTK_INT AliasPhysToConfInPlace_C(void (*func)(const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz))
{
  CCTK_INT aliased = PhysToConfInPlace_C_Wrapper != NULL;
  if (!aliased)
  {
    PhysToConfInPlace_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPhysToConfInPlace_F(void (*func)(const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz));
CCTK_INT AliasPhysToConfInPlace_F(void (*func)(const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz))
{
  CCTK_INT aliased = PhysToConfInPlace_C_Wrapper != NULL;
  if (!aliased)
  {
    PhysToConfInPlace_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*Prim2ConGen_C_Wrapper) (const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 const CCTK_REAL epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz) = NULL;
static void (*Prim2ConGen_F_Wrapper) (const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 const CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void Prim2ConGen (const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 const CCTK_REAL epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz);
void Prim2ConGen (const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 const CCTK_REAL epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz)
{
  if (!Prim2ConGen_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Prim2ConGen has not been provided by any active thorn.");
  }

  (*Prim2ConGen_C_Wrapper)(handle , gxx , gxy , gxz , gyy , gyz , gzz , det , dens , sx , sy , sz , tau , rho , velx , vely , velz , epsilon , press , w_lorentz);
}

void CCTK_FCALL CCTK_FNAME(Prim2ConGen) (const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 const CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz);
void CCTK_FCALL CCTK_FNAME(Prim2ConGen) (const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 const CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz)
{
  if (!Prim2ConGen_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Prim2ConGen has not been provided by any active thorn.");
  }

  (*Prim2ConGen_F_Wrapper)(handle , gxx , gxy , gxz , gyy , gyz , gzz , det , dens , sx , sy , sz , tau , rho , velx , vely , velz , epsilon , press , w_lorentz);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPrim2ConGen(void);
CCTK_INT IsAliasedPrim2ConGen(void)
{
  return (Prim2ConGen_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPrim2ConGen_C(void (*func)(const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 const CCTK_REAL epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz));
CCTK_INT AliasPrim2ConGen_C(void (*func)(const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 const CCTK_REAL epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz))
{
  CCTK_INT aliased = Prim2ConGen_C_Wrapper != NULL;
  if (!aliased)
  {
    Prim2ConGen_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPrim2ConGen_F(void (*func)(const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 const CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz));
CCTK_INT AliasPrim2ConGen_F(void (*func)(const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 const CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz))
{
  CCTK_INT aliased = Prim2ConGen_C_Wrapper != NULL;
  if (!aliased)
  {
    Prim2ConGen_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*Prim2ConGenM_C_Wrapper) (const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 const CCTK_REAL epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL Bvecx ,
 const CCTK_REAL Bvecy ,
 const CCTK_REAL Bvecz ,
 CCTK_REAL* w_lorentz) = NULL;
static void (*Prim2ConGenM_F_Wrapper) (const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 const CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL* Bvecx ,
 const CCTK_REAL* Bvecy ,
 const CCTK_REAL* Bvecz ,
 CCTK_REAL* w_lorentz) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void Prim2ConGenM (const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 const CCTK_REAL epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL Bvecx ,
 const CCTK_REAL Bvecy ,
 const CCTK_REAL Bvecz ,
 CCTK_REAL* w_lorentz);
void Prim2ConGenM (const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 const CCTK_REAL epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL Bvecx ,
 const CCTK_REAL Bvecy ,
 const CCTK_REAL Bvecz ,
 CCTK_REAL* w_lorentz)
{
  if (!Prim2ConGenM_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Prim2ConGenM has not been provided by any active thorn.");
  }

  (*Prim2ConGenM_C_Wrapper)(handle , gxx , gxy , gxz , gyy , gyz , gzz , det , dens , sx , sy , sz , tau , Bconsx , Bconsy , Bconsz , rho , velx , vely , velz , epsilon , press , Bvecx , Bvecy , Bvecz , w_lorentz);
}

void CCTK_FCALL CCTK_FNAME(Prim2ConGenM) (const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 const CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL* Bvecx ,
 const CCTK_REAL* Bvecy ,
 const CCTK_REAL* Bvecz ,
 CCTK_REAL* w_lorentz);
void CCTK_FCALL CCTK_FNAME(Prim2ConGenM) (const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 const CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL* Bvecx ,
 const CCTK_REAL* Bvecy ,
 const CCTK_REAL* Bvecz ,
 CCTK_REAL* w_lorentz)
{
  if (!Prim2ConGenM_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Prim2ConGenM has not been provided by any active thorn.");
  }

  (*Prim2ConGenM_F_Wrapper)(handle , gxx , gxy , gxz , gyy , gyz , gzz , det , dens , sx , sy , sz , tau , Bconsx , Bconsy , Bconsz , rho , velx , vely , velz , epsilon , press , Bvecx , Bvecy , Bvecz , w_lorentz);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPrim2ConGenM(void);
CCTK_INT IsAliasedPrim2ConGenM(void)
{
  return (Prim2ConGenM_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPrim2ConGenM_C(void (*func)(const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 const CCTK_REAL epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL Bvecx ,
 const CCTK_REAL Bvecy ,
 const CCTK_REAL Bvecz ,
 CCTK_REAL* w_lorentz));
CCTK_INT AliasPrim2ConGenM_C(void (*func)(const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 const CCTK_REAL epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL Bvecx ,
 const CCTK_REAL Bvecy ,
 const CCTK_REAL Bvecz ,
 CCTK_REAL* w_lorentz))
{
  CCTK_INT aliased = Prim2ConGenM_C_Wrapper != NULL;
  if (!aliased)
  {
    Prim2ConGenM_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPrim2ConGenM_F(void (*func)(const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 const CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL* Bvecx ,
 const CCTK_REAL* Bvecy ,
 const CCTK_REAL* Bvecz ,
 CCTK_REAL* w_lorentz));
CCTK_INT AliasPrim2ConGenM_F(void (*func)(const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 const CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL* Bvecx ,
 const CCTK_REAL* Bvecy ,
 const CCTK_REAL* Bvecz ,
 CCTK_REAL* w_lorentz))
{
  CCTK_INT aliased = Prim2ConGenM_C_Wrapper != NULL;
  if (!aliased)
  {
    Prim2ConGenM_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*Prim2ConGenM_hot_C_Wrapper) (const CCTK_INT handle ,
 const CCTK_INT GRHydro_reflevel ,
 const CCTK_INT i ,
 const CCTK_INT j ,
 const CCTK_INT k ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 const CCTK_REAL epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL Bvecx ,
 const CCTK_REAL Bvecy ,
 const CCTK_REAL Bvecz ,
 CCTK_REAL* w_lorentz ,
 CCTK_REAL* temperature ,
 const CCTK_REAL Y_e) = NULL;
static void (*Prim2ConGenM_hot_F_Wrapper) (const CCTK_INT* handle ,
 const CCTK_INT* GRHydro_reflevel ,
 const CCTK_INT* i ,
 const CCTK_INT* j ,
 const CCTK_INT* k ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 const CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL* Bvecx ,
 const CCTK_REAL* Bvecy ,
 const CCTK_REAL* Bvecz ,
 CCTK_REAL* w_lorentz ,
 CCTK_REAL* temperature ,
 const CCTK_REAL* Y_e) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void Prim2ConGenM_hot (const CCTK_INT handle ,
 const CCTK_INT GRHydro_reflevel ,
 const CCTK_INT i ,
 const CCTK_INT j ,
 const CCTK_INT k ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 const CCTK_REAL epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL Bvecx ,
 const CCTK_REAL Bvecy ,
 const CCTK_REAL Bvecz ,
 CCTK_REAL* w_lorentz ,
 CCTK_REAL* temperature ,
 const CCTK_REAL Y_e);
void Prim2ConGenM_hot (const CCTK_INT handle ,
 const CCTK_INT GRHydro_reflevel ,
 const CCTK_INT i ,
 const CCTK_INT j ,
 const CCTK_INT k ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 const CCTK_REAL epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL Bvecx ,
 const CCTK_REAL Bvecy ,
 const CCTK_REAL Bvecz ,
 CCTK_REAL* w_lorentz ,
 CCTK_REAL* temperature ,
 const CCTK_REAL Y_e)
{
  if (!Prim2ConGenM_hot_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Prim2ConGenM_hot has not been provided by any active thorn.");
  }

  (*Prim2ConGenM_hot_C_Wrapper)(handle , GRHydro_reflevel , i , j , k , x , y , z , gxx , gxy , gxz , gyy , gyz , gzz , det , dens , sx , sy , sz , tau , Bconsx , Bconsy , Bconsz , rho , velx , vely , velz , epsilon , press , Bvecx , Bvecy , Bvecz , w_lorentz , temperature , Y_e);
}

void CCTK_FCALL CCTK_FNAME(Prim2ConGenM_hot) (const CCTK_INT* handle ,
 const CCTK_INT* GRHydro_reflevel ,
 const CCTK_INT* i ,
 const CCTK_INT* j ,
 const CCTK_INT* k ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 const CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL* Bvecx ,
 const CCTK_REAL* Bvecy ,
 const CCTK_REAL* Bvecz ,
 CCTK_REAL* w_lorentz ,
 CCTK_REAL* temperature ,
 const CCTK_REAL* Y_e);
void CCTK_FCALL CCTK_FNAME(Prim2ConGenM_hot) (const CCTK_INT* handle ,
 const CCTK_INT* GRHydro_reflevel ,
 const CCTK_INT* i ,
 const CCTK_INT* j ,
 const CCTK_INT* k ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 const CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL* Bvecx ,
 const CCTK_REAL* Bvecy ,
 const CCTK_REAL* Bvecz ,
 CCTK_REAL* w_lorentz ,
 CCTK_REAL* temperature ,
 const CCTK_REAL* Y_e)
{
  if (!Prim2ConGenM_hot_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Prim2ConGenM_hot has not been provided by any active thorn.");
  }

  (*Prim2ConGenM_hot_F_Wrapper)(handle , GRHydro_reflevel , i , j , k , x , y , z , gxx , gxy , gxz , gyy , gyz , gzz , det , dens , sx , sy , sz , tau , Bconsx , Bconsy , Bconsz , rho , velx , vely , velz , epsilon , press , Bvecx , Bvecy , Bvecz , w_lorentz , temperature , Y_e);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPrim2ConGenM_hot(void);
CCTK_INT IsAliasedPrim2ConGenM_hot(void)
{
  return (Prim2ConGenM_hot_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPrim2ConGenM_hot_C(void (*func)(const CCTK_INT handle ,
 const CCTK_INT GRHydro_reflevel ,
 const CCTK_INT i ,
 const CCTK_INT j ,
 const CCTK_INT k ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 const CCTK_REAL epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL Bvecx ,
 const CCTK_REAL Bvecy ,
 const CCTK_REAL Bvecz ,
 CCTK_REAL* w_lorentz ,
 CCTK_REAL* temperature ,
 const CCTK_REAL Y_e));
CCTK_INT AliasPrim2ConGenM_hot_C(void (*func)(const CCTK_INT handle ,
 const CCTK_INT GRHydro_reflevel ,
 const CCTK_INT i ,
 const CCTK_INT j ,
 const CCTK_INT k ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 const CCTK_REAL epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL Bvecx ,
 const CCTK_REAL Bvecy ,
 const CCTK_REAL Bvecz ,
 CCTK_REAL* w_lorentz ,
 CCTK_REAL* temperature ,
 const CCTK_REAL Y_e))
{
  CCTK_INT aliased = Prim2ConGenM_hot_C_Wrapper != NULL;
  if (!aliased)
  {
    Prim2ConGenM_hot_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPrim2ConGenM_hot_F(void (*func)(const CCTK_INT* handle ,
 const CCTK_INT* GRHydro_reflevel ,
 const CCTK_INT* i ,
 const CCTK_INT* j ,
 const CCTK_INT* k ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 const CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL* Bvecx ,
 const CCTK_REAL* Bvecy ,
 const CCTK_REAL* Bvecz ,
 CCTK_REAL* w_lorentz ,
 CCTK_REAL* temperature ,
 const CCTK_REAL* Y_e));
CCTK_INT AliasPrim2ConGenM_hot_F(void (*func)(const CCTK_INT* handle ,
 const CCTK_INT* GRHydro_reflevel ,
 const CCTK_INT* i ,
 const CCTK_INT* j ,
 const CCTK_INT* k ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 const CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL* Bvecx ,
 const CCTK_REAL* Bvecy ,
 const CCTK_REAL* Bvecz ,
 CCTK_REAL* w_lorentz ,
 CCTK_REAL* temperature ,
 const CCTK_REAL* Y_e))
{
  CCTK_INT aliased = Prim2ConGenM_hot_C_Wrapper != NULL;
  if (!aliased)
  {
    Prim2ConGenM_hot_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*Prim2ConPoly_C_Wrapper) (const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz) = NULL;
static void (*Prim2ConPoly_F_Wrapper) (const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void Prim2ConPoly (const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz);
void Prim2ConPoly (const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz)
{
  if (!Prim2ConPoly_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Prim2ConPoly has not been provided by any active thorn.");
  }

  (*Prim2ConPoly_C_Wrapper)(handle , gxx , gxy , gxz , gyy , gyz , gzz , det , dens , sx , sy , sz , tau , rho , velx , vely , velz , epsilon , press , w_lorentz);
}

void CCTK_FCALL CCTK_FNAME(Prim2ConPoly) (const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz);
void CCTK_FCALL CCTK_FNAME(Prim2ConPoly) (const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz)
{
  if (!Prim2ConPoly_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Prim2ConPoly has not been provided by any active thorn.");
  }

  (*Prim2ConPoly_F_Wrapper)(handle , gxx , gxy , gxz , gyy , gyz , gzz , det , dens , sx , sy , sz , tau , rho , velx , vely , velz , epsilon , press , w_lorentz);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPrim2ConPoly(void);
CCTK_INT IsAliasedPrim2ConPoly(void)
{
  return (Prim2ConPoly_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPrim2ConPoly_C(void (*func)(const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz));
CCTK_INT AliasPrim2ConPoly_C(void (*func)(const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz))
{
  CCTK_INT aliased = Prim2ConPoly_C_Wrapper != NULL;
  if (!aliased)
  {
    Prim2ConPoly_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPrim2ConPoly_F(void (*func)(const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz));
CCTK_INT AliasPrim2ConPoly_F(void (*func)(const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 CCTK_REAL* w_lorentz))
{
  CCTK_INT aliased = Prim2ConPoly_C_Wrapper != NULL;
  if (!aliased)
  {
    Prim2ConPoly_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*Prim2ConPolyM_C_Wrapper) (const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL Bvecx ,
 const CCTK_REAL Bvecy ,
 const CCTK_REAL Bvecz ,
 CCTK_REAL* w_lorentz) = NULL;
static void (*Prim2ConPolyM_F_Wrapper) (const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL* Bvecx ,
 const CCTK_REAL* Bvecy ,
 const CCTK_REAL* Bvecz ,
 CCTK_REAL* w_lorentz) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void Prim2ConPolyM (const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL Bvecx ,
 const CCTK_REAL Bvecy ,
 const CCTK_REAL Bvecz ,
 CCTK_REAL* w_lorentz);
void Prim2ConPolyM (const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL Bvecx ,
 const CCTK_REAL Bvecy ,
 const CCTK_REAL Bvecz ,
 CCTK_REAL* w_lorentz)
{
  if (!Prim2ConPolyM_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Prim2ConPolyM has not been provided by any active thorn.");
  }

  (*Prim2ConPolyM_C_Wrapper)(handle , gxx , gxy , gxz , gyy , gyz , gzz , det , dens , sx , sy , sz , tau , Bconsx , Bconsy , Bconsz , rho , velx , vely , velz , epsilon , press , Bvecx , Bvecy , Bvecz , w_lorentz);
}

void CCTK_FCALL CCTK_FNAME(Prim2ConPolyM) (const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL* Bvecx ,
 const CCTK_REAL* Bvecy ,
 const CCTK_REAL* Bvecz ,
 CCTK_REAL* w_lorentz);
void CCTK_FCALL CCTK_FNAME(Prim2ConPolyM) (const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL* Bvecx ,
 const CCTK_REAL* Bvecy ,
 const CCTK_REAL* Bvecz ,
 CCTK_REAL* w_lorentz)
{
  if (!Prim2ConPolyM_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Prim2ConPolyM has not been provided by any active thorn.");
  }

  (*Prim2ConPolyM_F_Wrapper)(handle , gxx , gxy , gxz , gyy , gyz , gzz , det , dens , sx , sy , sz , tau , Bconsx , Bconsy , Bconsz , rho , velx , vely , velz , epsilon , press , Bvecx , Bvecy , Bvecz , w_lorentz);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPrim2ConPolyM(void);
CCTK_INT IsAliasedPrim2ConPolyM(void)
{
  return (Prim2ConPolyM_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPrim2ConPolyM_C(void (*func)(const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL Bvecx ,
 const CCTK_REAL Bvecy ,
 const CCTK_REAL Bvecz ,
 CCTK_REAL* w_lorentz));
CCTK_INT AliasPrim2ConPolyM_C(void (*func)(const CCTK_INT handle ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 const CCTK_REAL det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL rho ,
 const CCTK_REAL velx ,
 const CCTK_REAL vely ,
 const CCTK_REAL velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL Bvecx ,
 const CCTK_REAL Bvecy ,
 const CCTK_REAL Bvecz ,
 CCTK_REAL* w_lorentz))
{
  CCTK_INT aliased = Prim2ConPolyM_C_Wrapper != NULL;
  if (!aliased)
  {
    Prim2ConPolyM_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPrim2ConPolyM_F(void (*func)(const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL* Bvecx ,
 const CCTK_REAL* Bvecy ,
 const CCTK_REAL* Bvecz ,
 CCTK_REAL* w_lorentz));
CCTK_INT AliasPrim2ConPolyM_F(void (*func)(const CCTK_INT* handle ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* det ,
 CCTK_REAL* dens ,
 CCTK_REAL* sx ,
 CCTK_REAL* sy ,
 CCTK_REAL* sz ,
 CCTK_REAL* tau ,
 CCTK_REAL* Bconsx ,
 CCTK_REAL* Bconsy ,
 CCTK_REAL* Bconsz ,
 const CCTK_REAL* rho ,
 const CCTK_REAL* velx ,
 const CCTK_REAL* vely ,
 const CCTK_REAL* velz ,
 CCTK_REAL* epsilon ,
 CCTK_REAL* press ,
 const CCTK_REAL* Bvecx ,
 const CCTK_REAL* Bvecy ,
 const CCTK_REAL* Bvecz ,
 CCTK_REAL* w_lorentz))
{
  CCTK_INT aliased = Prim2ConPolyM_C_Wrapper != NULL;
  if (!aliased)
  {
    Prim2ConPolyM_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*PublishBoolean_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING name) = NULL;
static CCTK_INT (*PublishBoolean_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 CCTK_STRING key, CCTK_STRING name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT PublishBoolean (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING name);
CCTK_INT PublishBoolean (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING name)
{
  CCTK_INT retval;

  if (!PublishBoolean_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishBoolean has not been provided by any active thorn.");
  }

  retval = (*PublishBoolean_C_Wrapper)(cctkGH , level , value , key , name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(PublishBoolean) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 TWO_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(PublishBoolean) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 TWO_FORTSTRING_ARG)
{
  CCTK_INT retval;

  TWO_FORTSTRING_CREATE(cctki_string1,cctki_string2)

  if (!PublishBoolean_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishBoolean has not been provided by any active thorn.");
  }

  retval = (*PublishBoolean_F_Wrapper)(cctkGH , level , value , cctki_string1,cctki_string2);
  free(cctki_string1);
  free(cctki_string2);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPublishBoolean(void);
CCTK_INT IsAliasedPublishBoolean(void)
{
  return (PublishBoolean_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPublishBoolean_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING name));
CCTK_INT AliasPublishBoolean_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING name))
{
  CCTK_INT aliased = PublishBoolean_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishBoolean_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPublishBoolean_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 CCTK_STRING key, CCTK_STRING name));
CCTK_INT AliasPublishBoolean_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 CCTK_STRING key, CCTK_STRING name))
{
  CCTK_INT aliased = PublishBoolean_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishBoolean_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*PublishBoolean_Register_C_Wrapper) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name) = NULL;
static CCTK_INT (*PublishBoolean_Register_F_Wrapper) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 CCTK_STRING name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT PublishBoolean_Register (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name);
CCTK_INT PublishBoolean_Register (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name)
{
  CCTK_INT retval;

  if (!PublishBoolean_Register_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishBoolean_Register has not been provided by any active thorn.");
  }

  retval = (*PublishBoolean_Register_C_Wrapper)(publish_cb , cb_data , name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(PublishBoolean_Register) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(PublishBoolean_Register) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!PublishBoolean_Register_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishBoolean_Register has not been provided by any active thorn.");
  }

  retval = (*PublishBoolean_Register_F_Wrapper)(publish_cb , cb_data , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPublishBoolean_Register(void);
CCTK_INT IsAliasedPublishBoolean_Register(void)
{
  return (PublishBoolean_Register_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPublishBoolean_Register_C(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name));
CCTK_INT AliasPublishBoolean_Register_C(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name))
{
  CCTK_INT aliased = PublishBoolean_Register_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishBoolean_Register_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPublishBoolean_Register_F(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 CCTK_STRING name));
CCTK_INT AliasPublishBoolean_Register_F(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 CCTK_STRING name))
{
  CCTK_INT aliased = PublishBoolean_Register_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishBoolean_Register_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*PublishBoolean_Unregister_C_Wrapper) (CCTK_STRING name) = NULL;
static CCTK_INT (*PublishBoolean_Unregister_F_Wrapper) (CCTK_STRING name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT PublishBoolean_Unregister (CCTK_STRING name);
CCTK_INT PublishBoolean_Unregister (CCTK_STRING name)
{
  CCTK_INT retval;

  if (!PublishBoolean_Unregister_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishBoolean_Unregister has not been provided by any active thorn.");
  }

  retval = (*PublishBoolean_Unregister_C_Wrapper)(name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(PublishBoolean_Unregister) (ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(PublishBoolean_Unregister) (ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!PublishBoolean_Unregister_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishBoolean_Unregister has not been provided by any active thorn.");
  }

  retval = (*PublishBoolean_Unregister_F_Wrapper)(cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPublishBoolean_Unregister(void);
CCTK_INT IsAliasedPublishBoolean_Unregister(void)
{
  return (PublishBoolean_Unregister_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPublishBoolean_Unregister_C(CCTK_INT (*func)(CCTK_STRING name));
CCTK_INT AliasPublishBoolean_Unregister_C(CCTK_INT (*func)(CCTK_STRING name))
{
  CCTK_INT aliased = PublishBoolean_Unregister_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishBoolean_Unregister_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPublishBoolean_Unregister_F(CCTK_INT (*func)(CCTK_STRING name));
CCTK_INT AliasPublishBoolean_Unregister_F(CCTK_INT (*func)(CCTK_STRING name))
{
  CCTK_INT aliased = PublishBoolean_Unregister_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishBoolean_Unregister_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*PublishInt_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING name) = NULL;
static CCTK_INT (*PublishInt_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 CCTK_STRING key, CCTK_STRING name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT PublishInt (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING name);
CCTK_INT PublishInt (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING name)
{
  CCTK_INT retval;

  if (!PublishInt_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishInt has not been provided by any active thorn.");
  }

  retval = (*PublishInt_C_Wrapper)(cctkGH , level , value , key , name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(PublishInt) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 TWO_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(PublishInt) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 TWO_FORTSTRING_ARG)
{
  CCTK_INT retval;

  TWO_FORTSTRING_CREATE(cctki_string1,cctki_string2)

  if (!PublishInt_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishInt has not been provided by any active thorn.");
  }

  retval = (*PublishInt_F_Wrapper)(cctkGH , level , value , cctki_string1,cctki_string2);
  free(cctki_string1);
  free(cctki_string2);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPublishInt(void);
CCTK_INT IsAliasedPublishInt(void)
{
  return (PublishInt_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPublishInt_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING name));
CCTK_INT AliasPublishInt_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING name))
{
  CCTK_INT aliased = PublishInt_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishInt_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPublishInt_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 CCTK_STRING key, CCTK_STRING name));
CCTK_INT AliasPublishInt_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 CCTK_STRING key, CCTK_STRING name))
{
  CCTK_INT aliased = PublishInt_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishInt_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*PublishInt_Register_C_Wrapper) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name) = NULL;
static CCTK_INT (*PublishInt_Register_F_Wrapper) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 CCTK_STRING name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT PublishInt_Register (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name);
CCTK_INT PublishInt_Register (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name)
{
  CCTK_INT retval;

  if (!PublishInt_Register_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishInt_Register has not been provided by any active thorn.");
  }

  retval = (*PublishInt_Register_C_Wrapper)(publish_cb , cb_data , name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(PublishInt_Register) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(PublishInt_Register) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!PublishInt_Register_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishInt_Register has not been provided by any active thorn.");
  }

  retval = (*PublishInt_Register_F_Wrapper)(publish_cb , cb_data , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPublishInt_Register(void);
CCTK_INT IsAliasedPublishInt_Register(void)
{
  return (PublishInt_Register_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPublishInt_Register_C(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name));
CCTK_INT AliasPublishInt_Register_C(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_INT value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name))
{
  CCTK_INT aliased = PublishInt_Register_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishInt_Register_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPublishInt_Register_F(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 CCTK_STRING name));
CCTK_INT AliasPublishInt_Register_F(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_INT* value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 CCTK_STRING name))
{
  CCTK_INT aliased = PublishInt_Register_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishInt_Register_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*PublishInt_Unregister_C_Wrapper) (CCTK_STRING name) = NULL;
static CCTK_INT (*PublishInt_Unregister_F_Wrapper) (CCTK_STRING name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT PublishInt_Unregister (CCTK_STRING name);
CCTK_INT PublishInt_Unregister (CCTK_STRING name)
{
  CCTK_INT retval;

  if (!PublishInt_Unregister_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishInt_Unregister has not been provided by any active thorn.");
  }

  retval = (*PublishInt_Unregister_C_Wrapper)(name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(PublishInt_Unregister) (ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(PublishInt_Unregister) (ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!PublishInt_Unregister_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishInt_Unregister has not been provided by any active thorn.");
  }

  retval = (*PublishInt_Unregister_F_Wrapper)(cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPublishInt_Unregister(void);
CCTK_INT IsAliasedPublishInt_Unregister(void)
{
  return (PublishInt_Unregister_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPublishInt_Unregister_C(CCTK_INT (*func)(CCTK_STRING name));
CCTK_INT AliasPublishInt_Unregister_C(CCTK_INT (*func)(CCTK_STRING name))
{
  CCTK_INT aliased = PublishInt_Unregister_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishInt_Unregister_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPublishInt_Unregister_F(CCTK_INT (*func)(CCTK_STRING name));
CCTK_INT AliasPublishInt_Unregister_F(CCTK_INT (*func)(CCTK_STRING name))
{
  CCTK_INT aliased = PublishInt_Unregister_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishInt_Unregister_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*PublishReal_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_REAL value ,
 CCTK_STRING key, CCTK_STRING name) = NULL;
static CCTK_INT (*PublishReal_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_REAL* value ,
 CCTK_STRING key, CCTK_STRING name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT PublishReal (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_REAL value ,
 CCTK_STRING key, CCTK_STRING name);
CCTK_INT PublishReal (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_REAL value ,
 CCTK_STRING key, CCTK_STRING name)
{
  CCTK_INT retval;

  if (!PublishReal_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishReal has not been provided by any active thorn.");
  }

  retval = (*PublishReal_C_Wrapper)(cctkGH , level , value , key , name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(PublishReal) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_REAL* value ,
 TWO_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(PublishReal) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_REAL* value ,
 TWO_FORTSTRING_ARG)
{
  CCTK_INT retval;

  TWO_FORTSTRING_CREATE(cctki_string1,cctki_string2)

  if (!PublishReal_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishReal has not been provided by any active thorn.");
  }

  retval = (*PublishReal_F_Wrapper)(cctkGH , level , value , cctki_string1,cctki_string2);
  free(cctki_string1);
  free(cctki_string2);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPublishReal(void);
CCTK_INT IsAliasedPublishReal(void)
{
  return (PublishReal_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPublishReal_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_REAL value ,
 CCTK_STRING key, CCTK_STRING name));
CCTK_INT AliasPublishReal_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_REAL value ,
 CCTK_STRING key, CCTK_STRING name))
{
  CCTK_INT aliased = PublishReal_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishReal_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPublishReal_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_REAL* value ,
 CCTK_STRING key, CCTK_STRING name));
CCTK_INT AliasPublishReal_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_REAL* value ,
 CCTK_STRING key, CCTK_STRING name))
{
  CCTK_INT aliased = PublishReal_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishReal_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*PublishReal_Register_C_Wrapper) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_REAL value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name) = NULL;
static CCTK_INT (*PublishReal_Register_F_Wrapper) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_REAL* value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 CCTK_STRING name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT PublishReal_Register (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_REAL value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name);
CCTK_INT PublishReal_Register (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_REAL value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name)
{
  CCTK_INT retval;

  if (!PublishReal_Register_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishReal_Register has not been provided by any active thorn.");
  }

  retval = (*PublishReal_Register_C_Wrapper)(publish_cb , cb_data , name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(PublishReal_Register) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_REAL* value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(PublishReal_Register) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_REAL* value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!PublishReal_Register_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishReal_Register has not been provided by any active thorn.");
  }

  retval = (*PublishReal_Register_F_Wrapper)(publish_cb , cb_data , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPublishReal_Register(void);
CCTK_INT IsAliasedPublishReal_Register(void)
{
  return (PublishReal_Register_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPublishReal_Register_C(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_REAL value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name));
CCTK_INT AliasPublishReal_Register_C(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_REAL value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name))
{
  CCTK_INT aliased = PublishReal_Register_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishReal_Register_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPublishReal_Register_F(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_REAL* value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 CCTK_STRING name));
CCTK_INT AliasPublishReal_Register_F(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_REAL* value ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 CCTK_STRING name))
{
  CCTK_INT aliased = PublishReal_Register_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishReal_Register_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*PublishReal_Unregister_C_Wrapper) (CCTK_STRING name) = NULL;
static CCTK_INT (*PublishReal_Unregister_F_Wrapper) (CCTK_STRING name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT PublishReal_Unregister (CCTK_STRING name);
CCTK_INT PublishReal_Unregister (CCTK_STRING name)
{
  CCTK_INT retval;

  if (!PublishReal_Unregister_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishReal_Unregister has not been provided by any active thorn.");
  }

  retval = (*PublishReal_Unregister_C_Wrapper)(name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(PublishReal_Unregister) (ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(PublishReal_Unregister) (ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!PublishReal_Unregister_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishReal_Unregister has not been provided by any active thorn.");
  }

  retval = (*PublishReal_Unregister_F_Wrapper)(cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPublishReal_Unregister(void);
CCTK_INT IsAliasedPublishReal_Unregister(void)
{
  return (PublishReal_Unregister_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPublishReal_Unregister_C(CCTK_INT (*func)(CCTK_STRING name));
CCTK_INT AliasPublishReal_Unregister_C(CCTK_INT (*func)(CCTK_STRING name))
{
  CCTK_INT aliased = PublishReal_Unregister_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishReal_Unregister_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPublishReal_Unregister_F(CCTK_INT (*func)(CCTK_STRING name));
CCTK_INT AliasPublishReal_Unregister_F(CCTK_INT (*func)(CCTK_STRING name))
{
  CCTK_INT aliased = PublishReal_Unregister_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishReal_Unregister_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*PublishString_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 CCTK_STRING value, CCTK_STRING key, CCTK_STRING name) = NULL;
static CCTK_INT (*PublishString_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 CCTK_STRING value, CCTK_STRING key, CCTK_STRING name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT PublishString (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 CCTK_STRING value, CCTK_STRING key, CCTK_STRING name);
CCTK_INT PublishString (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 CCTK_STRING value, CCTK_STRING key, CCTK_STRING name)
{
  CCTK_INT retval;

  if (!PublishString_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishString has not been provided by any active thorn.");
  }

  retval = (*PublishString_C_Wrapper)(cctkGH , level , value , key , name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(PublishString) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 THREE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(PublishString) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 THREE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  THREE_FORTSTRING_CREATE(cctki_string1,cctki_string2,cctki_string3)

  if (!PublishString_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishString has not been provided by any active thorn.");
  }

  retval = (*PublishString_F_Wrapper)(cctkGH , level , cctki_string1,cctki_string2,cctki_string3);
  free(cctki_string1);
  free(cctki_string2);
  free(cctki_string3);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPublishString(void);
CCTK_INT IsAliasedPublishString(void)
{
  return (PublishString_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPublishString_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 CCTK_STRING value, CCTK_STRING key, CCTK_STRING name));
CCTK_INT AliasPublishString_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 CCTK_STRING value, CCTK_STRING key, CCTK_STRING name))
{
  CCTK_INT aliased = PublishString_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishString_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPublishString_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 CCTK_STRING value, CCTK_STRING key, CCTK_STRING name));
CCTK_INT AliasPublishString_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 CCTK_STRING value, CCTK_STRING key, CCTK_STRING name))
{
  CCTK_INT aliased = PublishString_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishString_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*PublishString_Register_C_Wrapper) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 CCTK_STRING value, CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name) = NULL;
static CCTK_INT (*PublishString_Register_F_Wrapper) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 CCTK_STRING value, CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 CCTK_STRING name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT PublishString_Register (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 CCTK_STRING value, CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name);
CCTK_INT PublishString_Register (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 CCTK_STRING value, CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name)
{
  CCTK_INT retval;

  if (!PublishString_Register_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishString_Register has not been provided by any active thorn.");
  }

  retval = (*PublishString_Register_C_Wrapper)(publish_cb , cb_data , name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(PublishString_Register) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 CCTK_STRING value, CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(PublishString_Register) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 CCTK_STRING value, CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!PublishString_Register_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishString_Register has not been provided by any active thorn.");
  }

  retval = (*PublishString_Register_F_Wrapper)(publish_cb , cb_data , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPublishString_Register(void);
CCTK_INT IsAliasedPublishString_Register(void)
{
  return (PublishString_Register_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPublishString_Register_C(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 CCTK_STRING value, CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name));
CCTK_INT AliasPublishString_Register_C(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 CCTK_STRING value, CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name))
{
  CCTK_INT aliased = PublishString_Register_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishString_Register_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPublishString_Register_F(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 CCTK_STRING value, CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 CCTK_STRING name));
CCTK_INT AliasPublishString_Register_F(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 CCTK_STRING value, CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 CCTK_STRING name))
{
  CCTK_INT aliased = PublishString_Register_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishString_Register_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*PublishString_Unregister_C_Wrapper) (CCTK_STRING name) = NULL;
static CCTK_INT (*PublishString_Unregister_F_Wrapper) (CCTK_STRING name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT PublishString_Unregister (CCTK_STRING name);
CCTK_INT PublishString_Unregister (CCTK_STRING name)
{
  CCTK_INT retval;

  if (!PublishString_Unregister_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishString_Unregister has not been provided by any active thorn.");
  }

  retval = (*PublishString_Unregister_C_Wrapper)(name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(PublishString_Unregister) (ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(PublishString_Unregister) (ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!PublishString_Unregister_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishString_Unregister has not been provided by any active thorn.");
  }

  retval = (*PublishString_Unregister_F_Wrapper)(cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPublishString_Unregister(void);
CCTK_INT IsAliasedPublishString_Unregister(void)
{
  return (PublishString_Unregister_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPublishString_Unregister_C(CCTK_INT (*func)(CCTK_STRING name));
CCTK_INT AliasPublishString_Unregister_C(CCTK_INT (*func)(CCTK_STRING name))
{
  CCTK_INT aliased = PublishString_Unregister_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishString_Unregister_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPublishString_Unregister_F(CCTK_INT (*func)(CCTK_STRING name));
CCTK_INT AliasPublishString_Unregister_F(CCTK_INT (*func)(CCTK_STRING name))
{
  CCTK_INT aliased = PublishString_Unregister_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishString_Unregister_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*PublishTable_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_INT table ,
 CCTK_STRING key, CCTK_STRING name) = NULL;
static CCTK_INT (*PublishTable_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_INT* table ,
 CCTK_STRING key, CCTK_STRING name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT PublishTable (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_INT table ,
 CCTK_STRING key, CCTK_STRING name);
CCTK_INT PublishTable (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_INT table ,
 CCTK_STRING key, CCTK_STRING name)
{
  CCTK_INT retval;

  if (!PublishTable_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishTable has not been provided by any active thorn.");
  }

  retval = (*PublishTable_C_Wrapper)(cctkGH , level , table , key , name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(PublishTable) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_INT* table ,
 TWO_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(PublishTable) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_INT* table ,
 TWO_FORTSTRING_ARG)
{
  CCTK_INT retval;

  TWO_FORTSTRING_CREATE(cctki_string1,cctki_string2)

  if (!PublishTable_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishTable has not been provided by any active thorn.");
  }

  retval = (*PublishTable_F_Wrapper)(cctkGH , level , table , cctki_string1,cctki_string2);
  free(cctki_string1);
  free(cctki_string2);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPublishTable(void);
CCTK_INT IsAliasedPublishTable(void)
{
  return (PublishTable_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPublishTable_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_INT table ,
 CCTK_STRING key, CCTK_STRING name));
CCTK_INT AliasPublishTable_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT level ,
 const CCTK_INT table ,
 CCTK_STRING key, CCTK_STRING name))
{
  CCTK_INT aliased = PublishTable_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishTable_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPublishTable_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_INT* table ,
 CCTK_STRING key, CCTK_STRING name));
CCTK_INT AliasPublishTable_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* level ,
 const CCTK_INT* table ,
 CCTK_STRING key, CCTK_STRING name))
{
  CCTK_INT aliased = PublishTable_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishTable_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*PublishTable_Register_C_Wrapper) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_INT table ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name) = NULL;
static CCTK_INT (*PublishTable_Register_F_Wrapper) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_INT* table ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 CCTK_STRING name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT PublishTable_Register (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_INT table ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name);
CCTK_INT PublishTable_Register (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_INT table ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name)
{
  CCTK_INT retval;

  if (!PublishTable_Register_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishTable_Register has not been provided by any active thorn.");
  }

  retval = (*PublishTable_Register_C_Wrapper)(publish_cb , cb_data , name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(PublishTable_Register) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_INT* table ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(PublishTable_Register) (CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_INT* table ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!PublishTable_Register_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishTable_Register has not been provided by any active thorn.");
  }

  retval = (*PublishTable_Register_F_Wrapper)(publish_cb , cb_data , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPublishTable_Register(void);
CCTK_INT IsAliasedPublishTable_Register(void)
{
  return (PublishTable_Register_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPublishTable_Register_C(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_INT table ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name));
CCTK_INT AliasPublishTable_Register_C(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER cb_data ,
 const CCTK_INT level ,
 const CCTK_INT table ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER cb_data ,
 CCTK_STRING name))
{
  CCTK_INT aliased = PublishTable_Register_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishTable_Register_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPublishTable_Register_F(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_INT* table ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 CCTK_STRING name));
CCTK_INT AliasPublishTable_Register_F(CCTK_INT (*func)(CCTK_INT (*const publish_cb)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* cb_data ,
 const CCTK_INT* level ,
 const CCTK_INT* table ,
 CCTK_STRING key, CCTK_STRING thorn) ,
 const CCTK_POINTER* cb_data ,
 CCTK_STRING name))
{
  CCTK_INT aliased = PublishTable_Register_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishTable_Register_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*PublishTable_Unregister_C_Wrapper) (CCTK_STRING name) = NULL;
static CCTK_INT (*PublishTable_Unregister_F_Wrapper) (CCTK_STRING name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT PublishTable_Unregister (CCTK_STRING name);
CCTK_INT PublishTable_Unregister (CCTK_STRING name)
{
  CCTK_INT retval;

  if (!PublishTable_Unregister_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishTable_Unregister has not been provided by any active thorn.");
  }

  retval = (*PublishTable_Unregister_C_Wrapper)(name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(PublishTable_Unregister) (ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(PublishTable_Unregister) (ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!PublishTable_Unregister_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PublishTable_Unregister has not been provided by any active thorn.");
  }

  retval = (*PublishTable_Unregister_F_Wrapper)(cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPublishTable_Unregister(void);
CCTK_INT IsAliasedPublishTable_Unregister(void)
{
  return (PublishTable_Unregister_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPublishTable_Unregister_C(CCTK_INT (*func)(CCTK_STRING name));
CCTK_INT AliasPublishTable_Unregister_C(CCTK_INT (*func)(CCTK_STRING name))
{
  CCTK_INT aliased = PublishTable_Unregister_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishTable_Unregister_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPublishTable_Unregister_F(CCTK_INT (*func)(CCTK_STRING name));
CCTK_INT AliasPublishTable_Unregister_F(CCTK_INT (*func)(CCTK_STRING name))
{
  CCTK_INT aliased = PublishTable_Unregister_C_Wrapper != NULL;
  if (!aliased)
  {
    PublishTable_Unregister_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*QueryProlongating_C_Wrapper) (void) = NULL;
static CCTK_INT (*QueryProlongating_F_Wrapper) (void) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT QueryProlongating (void);
CCTK_INT QueryProlongating (void)
{
  CCTK_INT retval;

  if (!QueryProlongating_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function QueryProlongating has not been provided by any active thorn.");
  }

  retval = (*QueryProlongating_C_Wrapper)();
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(QueryProlongating) (void);
CCTK_INT CCTK_FCALL CCTK_FNAME(QueryProlongating) (void)
{
  CCTK_INT retval;

  if (!QueryProlongating_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function QueryProlongating has not been provided by any active thorn.");
  }

  retval = (*QueryProlongating_F_Wrapper)();
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedQueryProlongating(void);
CCTK_INT IsAliasedQueryProlongating(void)
{
  return (QueryProlongating_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasQueryProlongating_C(CCTK_INT (*func)(void));
CCTK_INT AliasQueryProlongating_C(CCTK_INT (*func)(void))
{
  CCTK_INT aliased = QueryProlongating_C_Wrapper != NULL;
  if (!aliased)
  {
    QueryProlongating_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasQueryProlongating_F(CCTK_INT (*func)(void));
CCTK_INT AliasQueryProlongating_F(CCTK_INT (*func)(void))
{
  CCTK_INT aliased = QueryProlongating_C_Wrapper != NULL;
  if (!aliased)
  {
    QueryProlongating_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*RegisterScheduleWrapper_C_Wrapper) (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data)) = NULL;
static CCTK_INT (*RegisterScheduleWrapper_F_Wrapper) (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data)) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT RegisterScheduleWrapper (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data));
CCTK_INT RegisterScheduleWrapper (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data))
{
  CCTK_INT retval;

  if (!RegisterScheduleWrapper_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function RegisterScheduleWrapper has not been provided by any active thorn.");
  }

  retval = (*RegisterScheduleWrapper_C_Wrapper)(func_before , func_after);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(RegisterScheduleWrapper) (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data));
CCTK_INT CCTK_FCALL CCTK_FNAME(RegisterScheduleWrapper) (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data))
{
  CCTK_INT retval;

  if (!RegisterScheduleWrapper_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function RegisterScheduleWrapper has not been provided by any active thorn.");
  }

  retval = (*RegisterScheduleWrapper_F_Wrapper)(func_before , func_after);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedRegisterScheduleWrapper(void);
CCTK_INT IsAliasedRegisterScheduleWrapper(void)
{
  return (RegisterScheduleWrapper_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasRegisterScheduleWrapper_C(CCTK_INT (*func)(CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data)));
CCTK_INT AliasRegisterScheduleWrapper_C(CCTK_INT (*func)(CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data)))
{
  CCTK_INT aliased = RegisterScheduleWrapper_C_Wrapper != NULL;
  if (!aliased)
  {
    RegisterScheduleWrapper_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasRegisterScheduleWrapper_F(CCTK_INT (*func)(CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data)));
CCTK_INT AliasRegisterScheduleWrapper_F(CCTK_INT (*func)(CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data)))
{
  CCTK_INT aliased = RegisterScheduleWrapper_C_Wrapper != NULL;
  if (!aliased)
  {
    RegisterScheduleWrapper_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*RegridLevel_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT current_max_reflevel ,
 const CCTK_INT max_reflevels) = NULL;
static CCTK_INT (*RegridLevel_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* current_max_reflevel ,
 const CCTK_INT* max_reflevels) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT RegridLevel (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT current_max_reflevel ,
 const CCTK_INT max_reflevels);
CCTK_INT RegridLevel (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT current_max_reflevel ,
 const CCTK_INT max_reflevels)
{
  CCTK_INT retval;

  if (!RegridLevel_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function RegridLevel has not been provided by any active thorn.");
  }

  retval = (*RegridLevel_C_Wrapper)(cctkGH , current_max_reflevel , max_reflevels);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(RegridLevel) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* current_max_reflevel ,
 const CCTK_INT* max_reflevels);
CCTK_INT CCTK_FCALL CCTK_FNAME(RegridLevel) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* current_max_reflevel ,
 const CCTK_INT* max_reflevels)
{
  CCTK_INT retval;

  if (!RegridLevel_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function RegridLevel has not been provided by any active thorn.");
  }

  retval = (*RegridLevel_F_Wrapper)(cctkGH , current_max_reflevel , max_reflevels);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedRegridLevel(void);
CCTK_INT IsAliasedRegridLevel(void)
{
  return (RegridLevel_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasRegridLevel_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT current_max_reflevel ,
 const CCTK_INT max_reflevels));
CCTK_INT AliasRegridLevel_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT current_max_reflevel ,
 const CCTK_INT max_reflevels))
{
  CCTK_INT aliased = RegridLevel_C_Wrapper != NULL;
  if (!aliased)
  {
    RegridLevel_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasRegridLevel_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* current_max_reflevel ,
 const CCTK_INT* max_reflevels));
CCTK_INT AliasRegridLevel_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* current_max_reflevel ,
 const CCTK_INT* max_reflevels))
{
  CCTK_INT aliased = RegridLevel_C_Wrapper != NULL;
  if (!aliased)
  {
    RegridLevel_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Rescale_Sources_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* psi ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyz) = NULL;
static CCTK_INT (*Rescale_Sources_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* psi ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyz) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Rescale_Sources (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* psi ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyz);
CCTK_INT Rescale_Sources (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* psi ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyz)
{
  CCTK_INT retval;

  if (!Rescale_Sources_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Rescale_Sources has not been provided by any active thorn.");
  }

  retval = (*Rescale_Sources_C_Wrapper)(cctkGH , size , x , y , z , psi , gxx , gyy , gzz , gxy , gxz , gyz);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Rescale_Sources) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* psi ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyz);
CCTK_INT CCTK_FCALL CCTK_FNAME(Rescale_Sources) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* psi ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyz)
{
  CCTK_INT retval;

  if (!Rescale_Sources_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Rescale_Sources has not been provided by any active thorn.");
  }

  retval = (*Rescale_Sources_F_Wrapper)(cctkGH , size , x , y , z , psi , gxx , gyy , gzz , gxy , gxz , gyz);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedRescale_Sources(void);
CCTK_INT IsAliasedRescale_Sources(void)
{
  return (Rescale_Sources_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasRescale_Sources_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* psi ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyz));
CCTK_INT AliasRescale_Sources_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* psi ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyz))
{
  CCTK_INT aliased = Rescale_Sources_C_Wrapper != NULL;
  if (!aliased)
  {
    Rescale_Sources_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasRescale_Sources_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* psi ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyz));
CCTK_INT AliasRescale_Sources_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 const CCTK_REAL* psi ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gzz ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyz))
{
  CCTK_INT aliased = Rescale_Sources_C_Wrapper != NULL;
  if (!aliased)
  {
    Rescale_Sources_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Send_Twitter_Msg_C_Wrapper) (CCTK_STRING msg) = NULL;
static CCTK_INT (*Send_Twitter_Msg_F_Wrapper) (CCTK_STRING msg) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Send_Twitter_Msg (CCTK_STRING msg);
CCTK_INT Send_Twitter_Msg (CCTK_STRING msg)
{
  CCTK_INT retval;

  if (!Send_Twitter_Msg_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Send_Twitter_Msg has not been provided by any active thorn.");
  }

  retval = (*Send_Twitter_Msg_C_Wrapper)(msg);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Send_Twitter_Msg) (ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Send_Twitter_Msg) (ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Send_Twitter_Msg_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Send_Twitter_Msg has not been provided by any active thorn.");
  }

  retval = (*Send_Twitter_Msg_F_Wrapper)(cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSend_Twitter_Msg(void);
CCTK_INT IsAliasedSend_Twitter_Msg(void)
{
  return (Send_Twitter_Msg_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSend_Twitter_Msg_C(CCTK_INT (*func)(CCTK_STRING msg));
CCTK_INT AliasSend_Twitter_Msg_C(CCTK_INT (*func)(CCTK_STRING msg))
{
  CCTK_INT aliased = Send_Twitter_Msg_C_Wrapper != NULL;
  if (!aliased)
  {
    Send_Twitter_Msg_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSend_Twitter_Msg_F(CCTK_INT (*func)(CCTK_STRING msg));
CCTK_INT AliasSend_Twitter_Msg_F(CCTK_INT (*func)(CCTK_STRING msg))
{
  CCTK_INT aliased = Send_Twitter_Msg_C_Wrapper != NULL;
  if (!aliased)
  {
    Send_Twitter_Msg_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*SetDriftCorrectPosition_C_Wrapper) (const CCTK_POINTER_TO_CONST GH_Pointer ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z) = NULL;
static void (*SetDriftCorrectPosition_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH_Pointer ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void SetDriftCorrectPosition (const CCTK_POINTER_TO_CONST GH_Pointer ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z);
void SetDriftCorrectPosition (const CCTK_POINTER_TO_CONST GH_Pointer ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z)
{
  if (!SetDriftCorrectPosition_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SetDriftCorrectPosition has not been provided by any active thorn.");
  }

  (*SetDriftCorrectPosition_C_Wrapper)(GH_Pointer , x , y , z);
}

void CCTK_FCALL CCTK_FNAME(SetDriftCorrectPosition) (const CCTK_POINTER_TO_CONST* GH_Pointer ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z);
void CCTK_FCALL CCTK_FNAME(SetDriftCorrectPosition) (const CCTK_POINTER_TO_CONST* GH_Pointer ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z)
{
  if (!SetDriftCorrectPosition_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SetDriftCorrectPosition has not been provided by any active thorn.");
  }

  (*SetDriftCorrectPosition_F_Wrapper)(GH_Pointer , x , y , z);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSetDriftCorrectPosition(void);
CCTK_INT IsAliasedSetDriftCorrectPosition(void)
{
  return (SetDriftCorrectPosition_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSetDriftCorrectPosition_C(void (*func)(const CCTK_POINTER_TO_CONST GH_Pointer ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z));
CCTK_INT AliasSetDriftCorrectPosition_C(void (*func)(const CCTK_POINTER_TO_CONST GH_Pointer ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z))
{
  CCTK_INT aliased = SetDriftCorrectPosition_C_Wrapper != NULL;
  if (!aliased)
  {
    SetDriftCorrectPosition_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSetDriftCorrectPosition_F(void (*func)(const CCTK_POINTER_TO_CONST* GH_Pointer ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z));
CCTK_INT AliasSetDriftCorrectPosition_F(void (*func)(const CCTK_POINTER_TO_CONST* GH_Pointer ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z))
{
  CCTK_INT aliased = SetDriftCorrectPosition_C_Wrapper != NULL;
  if (!aliased)
  {
    SetDriftCorrectPosition_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SetVarsToNaN_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING vars) = NULL;
static CCTK_INT (*SetVarsToNaN_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_STRING vars) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SetVarsToNaN (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING vars);
CCTK_INT SetVarsToNaN (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING vars)
{
  CCTK_INT retval;

  if (!SetVarsToNaN_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SetVarsToNaN has not been provided by any active thorn.");
  }

  retval = (*SetVarsToNaN_C_Wrapper)(cctkGH , vars);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SetVarsToNaN) (const CCTK_POINTER_TO_CONST* cctkGH ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(SetVarsToNaN) (const CCTK_POINTER_TO_CONST* cctkGH ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!SetVarsToNaN_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SetVarsToNaN has not been provided by any active thorn.");
  }

  retval = (*SetVarsToNaN_F_Wrapper)(cctkGH , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSetVarsToNaN(void);
CCTK_INT IsAliasedSetVarsToNaN(void)
{
  return (SetVarsToNaN_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSetVarsToNaN_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING vars));
CCTK_INT AliasSetVarsToNaN_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING vars))
{
  CCTK_INT aliased = SetVarsToNaN_C_Wrapper != NULL;
  if (!aliased)
  {
    SetVarsToNaN_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSetVarsToNaN_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_STRING vars));
CCTK_INT AliasSetVarsToNaN_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_STRING vars))
{
  CCTK_INT aliased = SetVarsToNaN_C_Wrapper != NULL;
  if (!aliased)
  {
    SetVarsToNaN_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Set_Initial_Guess_for_u_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_REAL* u ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z) = NULL;
static CCTK_INT (*Set_Initial_Guess_for_u_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_REAL* u ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Set_Initial_Guess_for_u (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_REAL* u ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z);
CCTK_INT Set_Initial_Guess_for_u (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_REAL* u ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z)
{
  CCTK_INT retval;

  if (!Set_Initial_Guess_for_u_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Set_Initial_Guess_for_u has not been provided by any active thorn.");
  }

  retval = (*Set_Initial_Guess_for_u_C_Wrapper)(cctkGH , size , u , x , y , z);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Set_Initial_Guess_for_u) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_REAL* u ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z);
CCTK_INT CCTK_FCALL CCTK_FNAME(Set_Initial_Guess_for_u) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_REAL* u ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z)
{
  CCTK_INT retval;

  if (!Set_Initial_Guess_for_u_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Set_Initial_Guess_for_u has not been provided by any active thorn.");
  }

  retval = (*Set_Initial_Guess_for_u_F_Wrapper)(cctkGH , size , u , x , y , z);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSet_Initial_Guess_for_u(void);
CCTK_INT IsAliasedSet_Initial_Guess_for_u(void)
{
  return (Set_Initial_Guess_for_u_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSet_Initial_Guess_for_u_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_REAL* u ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z));
CCTK_INT AliasSet_Initial_Guess_for_u_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_REAL* u ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z))
{
  CCTK_INT aliased = Set_Initial_Guess_for_u_C_Wrapper != NULL;
  if (!aliased)
  {
    Set_Initial_Guess_for_u_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSet_Initial_Guess_for_u_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_REAL* u ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z));
CCTK_INT AliasSet_Initial_Guess_for_u_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_REAL* u ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z))
{
  CCTK_INT aliased = Set_Initial_Guess_for_u_C_Wrapper != NULL;
  if (!aliased)
  {
    Set_Initial_Guess_for_u_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Set_Momentum_Source_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z) = NULL;
static CCTK_INT (*Set_Momentum_Source_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Set_Momentum_Source (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z);
CCTK_INT Set_Momentum_Source (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z)
{
  CCTK_INT retval;

  if (!Set_Momentum_Source_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Set_Momentum_Source has not been provided by any active thorn.");
  }

  retval = (*Set_Momentum_Source_C_Wrapper)(cctkGH , dir , size , source , x , y , z);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Set_Momentum_Source) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z);
CCTK_INT CCTK_FCALL CCTK_FNAME(Set_Momentum_Source) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z)
{
  CCTK_INT retval;

  if (!Set_Momentum_Source_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Set_Momentum_Source has not been provided by any active thorn.");
  }

  retval = (*Set_Momentum_Source_F_Wrapper)(cctkGH , dir , size , source , x , y , z);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSet_Momentum_Source(void);
CCTK_INT IsAliasedSet_Momentum_Source(void)
{
  return (Set_Momentum_Source_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSet_Momentum_Source_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z));
CCTK_INT AliasSet_Momentum_Source_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z))
{
  CCTK_INT aliased = Set_Momentum_Source_C_Wrapper != NULL;
  if (!aliased)
  {
    Set_Momentum_Source_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSet_Momentum_Source_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z));
CCTK_INT AliasSet_Momentum_Source_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z))
{
  CCTK_INT aliased = Set_Momentum_Source_C_Wrapper != NULL;
  if (!aliased)
  {
    Set_Momentum_Source_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Set_Rho_ADM_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z) = NULL;
static CCTK_INT (*Set_Rho_ADM_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Set_Rho_ADM (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z);
CCTK_INT Set_Rho_ADM (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z)
{
  CCTK_INT retval;

  if (!Set_Rho_ADM_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Set_Rho_ADM has not been provided by any active thorn.");
  }

  retval = (*Set_Rho_ADM_C_Wrapper)(cctkGH , size , source , x , y , z);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Set_Rho_ADM) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z);
CCTK_INT CCTK_FCALL CCTK_FNAME(Set_Rho_ADM) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z)
{
  CCTK_INT retval;

  if (!Set_Rho_ADM_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Set_Rho_ADM has not been provided by any active thorn.");
  }

  retval = (*Set_Rho_ADM_F_Wrapper)(cctkGH , size , source , x , y , z);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSet_Rho_ADM(void);
CCTK_INT IsAliasedSet_Rho_ADM(void)
{
  return (Set_Rho_ADM_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSet_Rho_ADM_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z));
CCTK_INT AliasSet_Rho_ADM_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z))
{
  CCTK_INT aliased = Set_Rho_ADM_C_Wrapper != NULL;
  if (!aliased)
  {
    Set_Rho_ADM_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSet_Rho_ADM_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z));
CCTK_INT AliasSet_Rho_ADM_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_REAL* source ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z))
{
  CCTK_INT aliased = Set_Rho_ADM_C_Wrapper != NULL;
  if (!aliased)
  {
    Set_Rho_ADM_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*SpatialDet_C_Wrapper) (const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 CCTK_REAL* det) = NULL;
static void (*SpatialDet_F_Wrapper) (const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 CCTK_REAL* det) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void SpatialDet (const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 CCTK_REAL* det);
void SpatialDet (const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 CCTK_REAL* det)
{
  if (!SpatialDet_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SpatialDet has not been provided by any active thorn.");
  }

  (*SpatialDet_C_Wrapper)(gxx , gxy , gxz , gyy , gyz , gzz , det);
}

void CCTK_FCALL CCTK_FNAME(SpatialDet) (const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 CCTK_REAL* det);
void CCTK_FCALL CCTK_FNAME(SpatialDet) (const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 CCTK_REAL* det)
{
  if (!SpatialDet_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SpatialDet has not been provided by any active thorn.");
  }

  (*SpatialDet_F_Wrapper)(gxx , gxy , gxz , gyy , gyz , gzz , det);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSpatialDet(void);
CCTK_INT IsAliasedSpatialDet(void)
{
  return (SpatialDet_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSpatialDet_C(void (*func)(const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 CCTK_REAL* det));
CCTK_INT AliasSpatialDet_C(void (*func)(const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz ,
 CCTK_REAL* det))
{
  CCTK_INT aliased = SpatialDet_C_Wrapper != NULL;
  if (!aliased)
  {
    SpatialDet_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSpatialDet_F(void (*func)(const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 CCTK_REAL* det));
CCTK_INT AliasSpatialDet_F(void (*func)(const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz ,
 CCTK_REAL* det))
{
  CCTK_INT aliased = SpatialDet_C_Wrapper != NULL;
  if (!aliased)
  {
    SpatialDet_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryHandleOfName_C_Wrapper) (CCTK_STRING sym_name) = NULL;
static CCTK_INT (*SymmetryHandleOfName_F_Wrapper) (CCTK_STRING sym_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryHandleOfName (CCTK_STRING sym_name);
CCTK_INT SymmetryHandleOfName (CCTK_STRING sym_name)
{
  CCTK_INT retval;

  if (!SymmetryHandleOfName_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryHandleOfName has not been provided by any active thorn.");
  }

  retval = (*SymmetryHandleOfName_C_Wrapper)(sym_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryHandleOfName) (ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryHandleOfName) (ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!SymmetryHandleOfName_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryHandleOfName has not been provided by any active thorn.");
  }

  retval = (*SymmetryHandleOfName_F_Wrapper)(cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryHandleOfName(void);
CCTK_INT IsAliasedSymmetryHandleOfName(void)
{
  return (SymmetryHandleOfName_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryHandleOfName_C(CCTK_INT (*func)(CCTK_STRING sym_name));
CCTK_INT AliasSymmetryHandleOfName_C(CCTK_INT (*func)(CCTK_STRING sym_name))
{
  CCTK_INT aliased = SymmetryHandleOfName_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryHandleOfName_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryHandleOfName_F(CCTK_INT (*func)(CCTK_STRING sym_name));
CCTK_INT AliasSymmetryHandleOfName_F(CCTK_INT (*func)(CCTK_STRING sym_name))
{
  CCTK_INT aliased = SymmetryHandleOfName_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryHandleOfName_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryInterpolate_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays) = NULL;
static CCTK_INT (*SymmetryInterpolate_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryInterpolate (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays);
CCTK_INT SymmetryInterpolate (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays)
{
  CCTK_INT retval;

  if (!SymmetryInterpolate_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryInterpolate has not been provided by any active thorn.");
  }

  retval = (*SymmetryInterpolate_C_Wrapper)(cctkGH , N_dims , local_interp_handle , param_table_handle , coord_system_handle , N_interp_points , interp_coords_type , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_array_types , output_arrays);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryInterpolate) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryInterpolate) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays)
{
  CCTK_INT retval;

  if (!SymmetryInterpolate_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryInterpolate has not been provided by any active thorn.");
  }

  retval = (*SymmetryInterpolate_F_Wrapper)(cctkGH , N_dims , local_interp_handle , param_table_handle , coord_system_handle , N_interp_points , interp_coords_type , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_array_types , output_arrays);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryInterpolate(void);
CCTK_INT IsAliasedSymmetryInterpolate(void)
{
  return (SymmetryInterpolate_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryInterpolate_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays));
CCTK_INT AliasSymmetryInterpolate_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays))
{
  CCTK_INT aliased = SymmetryInterpolate_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryInterpolate_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryInterpolate_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays));
CCTK_INT AliasSymmetryInterpolate_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays))
{
  CCTK_INT aliased = SymmetryInterpolate_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryInterpolate_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryInterpolateFaces_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces) = NULL;
static CCTK_INT (*SymmetryInterpolateFaces_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryInterpolateFaces (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces);
CCTK_INT SymmetryInterpolateFaces (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces)
{
  CCTK_INT retval;

  if (!SymmetryInterpolateFaces_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryInterpolateFaces has not been provided by any active thorn.");
  }

  retval = (*SymmetryInterpolateFaces_C_Wrapper)(cctkGH , N_dims , local_interp_handle , param_table_handle , coord_system_handle , N_interp_points , interp_coords_type , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_array_types , output_arrays , faces);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryInterpolateFaces) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryInterpolateFaces) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces)
{
  CCTK_INT retval;

  if (!SymmetryInterpolateFaces_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryInterpolateFaces has not been provided by any active thorn.");
  }

  retval = (*SymmetryInterpolateFaces_F_Wrapper)(cctkGH , N_dims , local_interp_handle , param_table_handle , coord_system_handle , N_interp_points , interp_coords_type , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_array_types , output_arrays , faces);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryInterpolateFaces(void);
CCTK_INT IsAliasedSymmetryInterpolateFaces(void)
{
  return (SymmetryInterpolateFaces_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryInterpolateFaces_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces));
CCTK_INT AliasSymmetryInterpolateFaces_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces))
{
  CCTK_INT aliased = SymmetryInterpolateFaces_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryInterpolateFaces_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryInterpolateFaces_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces));
CCTK_INT AliasSymmetryInterpolateFaces_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces))
{
  CCTK_INT aliased = SymmetryInterpolateFaces_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryInterpolateFaces_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_POINTER_TO_CONST (*SymmetryNameOfHandle_C_Wrapper) (const CCTK_INT sym_handle) = NULL;
static CCTK_POINTER_TO_CONST (*SymmetryNameOfHandle_F_Wrapper) (const CCTK_INT* sym_handle) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_POINTER_TO_CONST SymmetryNameOfHandle (const CCTK_INT sym_handle);
CCTK_POINTER_TO_CONST SymmetryNameOfHandle (const CCTK_INT sym_handle)
{
  CCTK_POINTER_TO_CONST retval;

  if (!SymmetryNameOfHandle_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryNameOfHandle has not been provided by any active thorn.");
  }

  retval = (*SymmetryNameOfHandle_C_Wrapper)(sym_handle);
  return (retval);
}

CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(SymmetryNameOfHandle) (const CCTK_INT* sym_handle);
CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(SymmetryNameOfHandle) (const CCTK_INT* sym_handle)
{
  CCTK_POINTER_TO_CONST retval;

  if (!SymmetryNameOfHandle_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryNameOfHandle has not been provided by any active thorn.");
  }

  retval = (*SymmetryNameOfHandle_F_Wrapper)(sym_handle);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryNameOfHandle(void);
CCTK_INT IsAliasedSymmetryNameOfHandle(void)
{
  return (SymmetryNameOfHandle_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryNameOfHandle_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_INT sym_handle));
CCTK_INT AliasSymmetryNameOfHandle_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_INT sym_handle))
{
  CCTK_INT aliased = SymmetryNameOfHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryNameOfHandle_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryNameOfHandle_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_INT* sym_handle));
CCTK_INT AliasSymmetryNameOfHandle_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_INT* sym_handle))
{
  CCTK_INT aliased = SymmetryNameOfHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryNameOfHandle_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryRegister_C_Wrapper) (CCTK_STRING sym_name) = NULL;
static CCTK_INT (*SymmetryRegister_F_Wrapper) (CCTK_STRING sym_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryRegister (CCTK_STRING sym_name);
CCTK_INT SymmetryRegister (CCTK_STRING sym_name)
{
  CCTK_INT retval;

  if (!SymmetryRegister_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegister has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegister_C_Wrapper)(sym_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegister) (ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegister) (ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!SymmetryRegister_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegister has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegister_F_Wrapper)(cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryRegister(void);
CCTK_INT IsAliasedSymmetryRegister(void)
{
  return (SymmetryRegister_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryRegister_C(CCTK_INT (*func)(CCTK_STRING sym_name));
CCTK_INT AliasSymmetryRegister_C(CCTK_INT (*func)(CCTK_STRING sym_name))
{
  CCTK_INT aliased = SymmetryRegister_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegister_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryRegister_F(CCTK_INT (*func)(CCTK_STRING sym_name));
CCTK_INT AliasSymmetryRegister_F(CCTK_INT (*func)(CCTK_STRING sym_name))
{
  CCTK_INT aliased = SymmetryRegister_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegister_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryRegisterGI_C_Wrapper) (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT group_index) = NULL;
static CCTK_INT (*SymmetryRegisterGI_F_Wrapper) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT* group_index) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryRegisterGI (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT group_index);
CCTK_INT SymmetryRegisterGI (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT group_index)
{
  CCTK_INT retval;

  if (!SymmetryRegisterGI_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGI has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegisterGI_C_Wrapper)(cctkGH , sym_handle , which_faces , symmetry_zone_width , group_index);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegisterGI) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT* group_index);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegisterGI) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT* group_index)
{
  CCTK_INT retval;

  if (!SymmetryRegisterGI_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGI has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegisterGI_F_Wrapper)(cctkGH , sym_handle , which_faces , symmetry_zone_width , group_index);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryRegisterGI(void);
CCTK_INT IsAliasedSymmetryRegisterGI(void)
{
  return (SymmetryRegisterGI_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryRegisterGI_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT group_index));
CCTK_INT AliasSymmetryRegisterGI_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT group_index))
{
  CCTK_INT aliased = SymmetryRegisterGI_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGI_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryRegisterGI_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT* group_index));
CCTK_INT AliasSymmetryRegisterGI_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT* group_index))
{
  CCTK_INT aliased = SymmetryRegisterGI_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGI_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryRegisterGN_C_Wrapper) (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name) = NULL;
static CCTK_INT (*SymmetryRegisterGN_F_Wrapper) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryRegisterGN (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name);
CCTK_INT SymmetryRegisterGN (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name)
{
  CCTK_INT retval;

  if (!SymmetryRegisterGN_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGN has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegisterGN_C_Wrapper)(cctkGH , sym_handle , which_faces , symmetry_zone_width , group_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegisterGN) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegisterGN) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!SymmetryRegisterGN_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGN has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegisterGN_F_Wrapper)(cctkGH , sym_handle , which_faces , symmetry_zone_width , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryRegisterGN(void);
CCTK_INT IsAliasedSymmetryRegisterGN(void)
{
  return (SymmetryRegisterGN_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryRegisterGN_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name));
CCTK_INT AliasSymmetryRegisterGN_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name))
{
  CCTK_INT aliased = SymmetryRegisterGN_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGN_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryRegisterGN_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name));
CCTK_INT AliasSymmetryRegisterGN_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name))
{
  CCTK_INT aliased = SymmetryRegisterGN_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGN_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryRegisterGrid_C_Wrapper) (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width) = NULL;
static CCTK_INT (*SymmetryRegisterGrid_F_Wrapper) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryRegisterGrid (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width);
CCTK_INT SymmetryRegisterGrid (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width)
{
  CCTK_INT retval;

  if (!SymmetryRegisterGrid_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGrid has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegisterGrid_C_Wrapper)(cctkGH , sym_handle , which_faces , symmetry_zone_width);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegisterGrid) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegisterGrid) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width)
{
  CCTK_INT retval;

  if (!SymmetryRegisterGrid_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGrid has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegisterGrid_F_Wrapper)(cctkGH , sym_handle , which_faces , symmetry_zone_width);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryRegisterGrid(void);
CCTK_INT IsAliasedSymmetryRegisterGrid(void)
{
  return (SymmetryRegisterGrid_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryRegisterGrid_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width));
CCTK_INT AliasSymmetryRegisterGrid_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width))
{
  CCTK_INT aliased = SymmetryRegisterGrid_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGrid_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryRegisterGrid_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width));
CCTK_INT AliasSymmetryRegisterGrid_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width))
{
  CCTK_INT aliased = SymmetryRegisterGrid_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGrid_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryRegisterGridInterpolator_C_Wrapper) (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces)) = NULL;
static CCTK_INT (*SymmetryRegisterGridInterpolator_F_Wrapper) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces)) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryRegisterGridInterpolator (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces));
CCTK_INT SymmetryRegisterGridInterpolator (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces))
{
  CCTK_INT retval;

  if (!SymmetryRegisterGridInterpolator_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGridInterpolator has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegisterGridInterpolator_C_Wrapper)(cctkGH , sym_handle , symmetry_interpolate);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegisterGridInterpolator) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces));
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegisterGridInterpolator) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces))
{
  CCTK_INT retval;

  if (!SymmetryRegisterGridInterpolator_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGridInterpolator has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegisterGridInterpolator_F_Wrapper)(cctkGH , sym_handle , symmetry_interpolate);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryRegisterGridInterpolator(void);
CCTK_INT IsAliasedSymmetryRegisterGridInterpolator(void)
{
  return (SymmetryRegisterGridInterpolator_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryRegisterGridInterpolator_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces)));
CCTK_INT AliasSymmetryRegisterGridInterpolator_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces)))
{
  CCTK_INT aliased = SymmetryRegisterGridInterpolator_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGridInterpolator_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryRegisterGridInterpolator_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces)));
CCTK_INT AliasSymmetryRegisterGridInterpolator_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces)))
{
  CCTK_INT aliased = SymmetryRegisterGridInterpolator_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGridInterpolator_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryTableHandleForGI_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT group_index) = NULL;
static CCTK_INT (*SymmetryTableHandleForGI_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* group_index) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryTableHandleForGI (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT group_index);
CCTK_INT SymmetryTableHandleForGI (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT group_index)
{
  CCTK_INT retval;

  if (!SymmetryTableHandleForGI_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryTableHandleForGI has not been provided by any active thorn.");
  }

  retval = (*SymmetryTableHandleForGI_C_Wrapper)(cctkGH , group_index);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryTableHandleForGI) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* group_index);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryTableHandleForGI) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* group_index)
{
  CCTK_INT retval;

  if (!SymmetryTableHandleForGI_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryTableHandleForGI has not been provided by any active thorn.");
  }

  retval = (*SymmetryTableHandleForGI_F_Wrapper)(cctkGH , group_index);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryTableHandleForGI(void);
CCTK_INT IsAliasedSymmetryTableHandleForGI(void)
{
  return (SymmetryTableHandleForGI_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryTableHandleForGI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT group_index));
CCTK_INT AliasSymmetryTableHandleForGI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT group_index))
{
  CCTK_INT aliased = SymmetryTableHandleForGI_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryTableHandleForGI_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryTableHandleForGI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* group_index));
CCTK_INT AliasSymmetryTableHandleForGI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* group_index))
{
  CCTK_INT aliased = SymmetryTableHandleForGI_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryTableHandleForGI_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryTableHandleForGN_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING group_name) = NULL;
static CCTK_INT (*SymmetryTableHandleForGN_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_STRING group_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryTableHandleForGN (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING group_name);
CCTK_INT SymmetryTableHandleForGN (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING group_name)
{
  CCTK_INT retval;

  if (!SymmetryTableHandleForGN_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryTableHandleForGN has not been provided by any active thorn.");
  }

  retval = (*SymmetryTableHandleForGN_C_Wrapper)(cctkGH , group_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryTableHandleForGN) (const CCTK_POINTER_TO_CONST* cctkGH ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryTableHandleForGN) (const CCTK_POINTER_TO_CONST* cctkGH ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!SymmetryTableHandleForGN_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryTableHandleForGN has not been provided by any active thorn.");
  }

  retval = (*SymmetryTableHandleForGN_F_Wrapper)(cctkGH , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryTableHandleForGN(void);
CCTK_INT IsAliasedSymmetryTableHandleForGN(void)
{
  return (SymmetryTableHandleForGN_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryTableHandleForGN_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING group_name));
CCTK_INT AliasSymmetryTableHandleForGN_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING group_name))
{
  CCTK_INT aliased = SymmetryTableHandleForGN_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryTableHandleForGN_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryTableHandleForGN_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_STRING group_name));
CCTK_INT AliasSymmetryTableHandleForGN_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_STRING group_name))
{
  CCTK_INT aliased = SymmetryTableHandleForGN_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryTableHandleForGN_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryTableHandleForGrid_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*SymmetryTableHandleForGrid_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryTableHandleForGrid (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT SymmetryTableHandleForGrid (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!SymmetryTableHandleForGrid_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryTableHandleForGrid has not been provided by any active thorn.");
  }

  retval = (*SymmetryTableHandleForGrid_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryTableHandleForGrid) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryTableHandleForGrid) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!SymmetryTableHandleForGrid_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryTableHandleForGrid has not been provided by any active thorn.");
  }

  retval = (*SymmetryTableHandleForGrid_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryTableHandleForGrid(void);
CCTK_INT IsAliasedSymmetryTableHandleForGrid(void)
{
  return (SymmetryTableHandleForGrid_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryTableHandleForGrid_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasSymmetryTableHandleForGrid_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = SymmetryTableHandleForGrid_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryTableHandleForGrid_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryTableHandleForGrid_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasSymmetryTableHandleForGrid_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = SymmetryTableHandleForGrid_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryTableHandleForGrid_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*Trace_C_Wrapper) (const CCTK_INT* lsh ,
 const CCTK_REAL* g11 ,
 const CCTK_REAL* g12 ,
 const CCTK_REAL* g13 ,
 const CCTK_REAL* g22 ,
 const CCTK_REAL* g23 ,
 const CCTK_REAL* g33 ,
 CCTK_REAL* tensor11 ,
 CCTK_REAL* tensor12 ,
 CCTK_REAL* tensor13 ,
 CCTK_REAL* tensor22 ,
 CCTK_REAL* tensor23 ,
 CCTK_REAL* tensor33 ,
 CCTK_REAL* trace ,
 CCTK_REAL* detg) = NULL;
static void (*Trace_F_Wrapper) (const CCTK_INT* lsh ,
 const CCTK_REAL* g11 ,
 const CCTK_REAL* g12 ,
 const CCTK_REAL* g13 ,
 const CCTK_REAL* g22 ,
 const CCTK_REAL* g23 ,
 const CCTK_REAL* g33 ,
 CCTK_REAL* tensor11 ,
 CCTK_REAL* tensor12 ,
 CCTK_REAL* tensor13 ,
 CCTK_REAL* tensor22 ,
 CCTK_REAL* tensor23 ,
 CCTK_REAL* tensor33 ,
 CCTK_REAL* trace ,
 CCTK_REAL* detg) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void Trace (const CCTK_INT* lsh ,
 const CCTK_REAL* g11 ,
 const CCTK_REAL* g12 ,
 const CCTK_REAL* g13 ,
 const CCTK_REAL* g22 ,
 const CCTK_REAL* g23 ,
 const CCTK_REAL* g33 ,
 CCTK_REAL* tensor11 ,
 CCTK_REAL* tensor12 ,
 CCTK_REAL* tensor13 ,
 CCTK_REAL* tensor22 ,
 CCTK_REAL* tensor23 ,
 CCTK_REAL* tensor33 ,
 CCTK_REAL* trace ,
 CCTK_REAL* detg);
void Trace (const CCTK_INT* lsh ,
 const CCTK_REAL* g11 ,
 const CCTK_REAL* g12 ,
 const CCTK_REAL* g13 ,
 const CCTK_REAL* g22 ,
 const CCTK_REAL* g23 ,
 const CCTK_REAL* g33 ,
 CCTK_REAL* tensor11 ,
 CCTK_REAL* tensor12 ,
 CCTK_REAL* tensor13 ,
 CCTK_REAL* tensor22 ,
 CCTK_REAL* tensor23 ,
 CCTK_REAL* tensor33 ,
 CCTK_REAL* trace ,
 CCTK_REAL* detg)
{
  if (!Trace_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Trace has not been provided by any active thorn.");
  }

  (*Trace_C_Wrapper)(lsh , g11 , g12 , g13 , g22 , g23 , g33 , tensor11 , tensor12 , tensor13 , tensor22 , tensor23 , tensor33 , trace , detg);
}

void CCTK_FCALL CCTK_FNAME(Trace) (const CCTK_INT* lsh ,
 const CCTK_REAL* g11 ,
 const CCTK_REAL* g12 ,
 const CCTK_REAL* g13 ,
 const CCTK_REAL* g22 ,
 const CCTK_REAL* g23 ,
 const CCTK_REAL* g33 ,
 CCTK_REAL* tensor11 ,
 CCTK_REAL* tensor12 ,
 CCTK_REAL* tensor13 ,
 CCTK_REAL* tensor22 ,
 CCTK_REAL* tensor23 ,
 CCTK_REAL* tensor33 ,
 CCTK_REAL* trace ,
 CCTK_REAL* detg);
void CCTK_FCALL CCTK_FNAME(Trace) (const CCTK_INT* lsh ,
 const CCTK_REAL* g11 ,
 const CCTK_REAL* g12 ,
 const CCTK_REAL* g13 ,
 const CCTK_REAL* g22 ,
 const CCTK_REAL* g23 ,
 const CCTK_REAL* g33 ,
 CCTK_REAL* tensor11 ,
 CCTK_REAL* tensor12 ,
 CCTK_REAL* tensor13 ,
 CCTK_REAL* tensor22 ,
 CCTK_REAL* tensor23 ,
 CCTK_REAL* tensor33 ,
 CCTK_REAL* trace ,
 CCTK_REAL* detg)
{
  if (!Trace_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Trace has not been provided by any active thorn.");
  }

  (*Trace_F_Wrapper)(lsh , g11 , g12 , g13 , g22 , g23 , g33 , tensor11 , tensor12 , tensor13 , tensor22 , tensor23 , tensor33 , trace , detg);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedTrace(void);
CCTK_INT IsAliasedTrace(void)
{
  return (Trace_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasTrace_C(void (*func)(const CCTK_INT* lsh ,
 const CCTK_REAL* g11 ,
 const CCTK_REAL* g12 ,
 const CCTK_REAL* g13 ,
 const CCTK_REAL* g22 ,
 const CCTK_REAL* g23 ,
 const CCTK_REAL* g33 ,
 CCTK_REAL* tensor11 ,
 CCTK_REAL* tensor12 ,
 CCTK_REAL* tensor13 ,
 CCTK_REAL* tensor22 ,
 CCTK_REAL* tensor23 ,
 CCTK_REAL* tensor33 ,
 CCTK_REAL* trace ,
 CCTK_REAL* detg));
CCTK_INT AliasTrace_C(void (*func)(const CCTK_INT* lsh ,
 const CCTK_REAL* g11 ,
 const CCTK_REAL* g12 ,
 const CCTK_REAL* g13 ,
 const CCTK_REAL* g22 ,
 const CCTK_REAL* g23 ,
 const CCTK_REAL* g33 ,
 CCTK_REAL* tensor11 ,
 CCTK_REAL* tensor12 ,
 CCTK_REAL* tensor13 ,
 CCTK_REAL* tensor22 ,
 CCTK_REAL* tensor23 ,
 CCTK_REAL* tensor33 ,
 CCTK_REAL* trace ,
 CCTK_REAL* detg))
{
  CCTK_INT aliased = Trace_C_Wrapper != NULL;
  if (!aliased)
  {
    Trace_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasTrace_F(void (*func)(const CCTK_INT* lsh ,
 const CCTK_REAL* g11 ,
 const CCTK_REAL* g12 ,
 const CCTK_REAL* g13 ,
 const CCTK_REAL* g22 ,
 const CCTK_REAL* g23 ,
 const CCTK_REAL* g33 ,
 CCTK_REAL* tensor11 ,
 CCTK_REAL* tensor12 ,
 CCTK_REAL* tensor13 ,
 CCTK_REAL* tensor22 ,
 CCTK_REAL* tensor23 ,
 CCTK_REAL* tensor33 ,
 CCTK_REAL* trace ,
 CCTK_REAL* detg));
CCTK_INT AliasTrace_F(void (*func)(const CCTK_INT* lsh ,
 const CCTK_REAL* g11 ,
 const CCTK_REAL* g12 ,
 const CCTK_REAL* g13 ,
 const CCTK_REAL* g22 ,
 const CCTK_REAL* g23 ,
 const CCTK_REAL* g33 ,
 CCTK_REAL* tensor11 ,
 CCTK_REAL* tensor12 ,
 CCTK_REAL* tensor13 ,
 CCTK_REAL* tensor22 ,
 CCTK_REAL* tensor23 ,
 CCTK_REAL* tensor33 ,
 CCTK_REAL* trace ,
 CCTK_REAL* detg))
{
  CCTK_INT aliased = Trace_C_Wrapper != NULL;
  if (!aliased)
  {
    Trace_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*UnRegisterScheduleWrapper_C_Wrapper) (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data)) = NULL;
static CCTK_INT (*UnRegisterScheduleWrapper_F_Wrapper) (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data)) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT UnRegisterScheduleWrapper (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data));
CCTK_INT UnRegisterScheduleWrapper (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data))
{
  CCTK_INT retval;

  if (!UnRegisterScheduleWrapper_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UnRegisterScheduleWrapper has not been provided by any active thorn.");
  }

  retval = (*UnRegisterScheduleWrapper_C_Wrapper)(func_before , func_after);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(UnRegisterScheduleWrapper) (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data));
CCTK_INT CCTK_FCALL CCTK_FNAME(UnRegisterScheduleWrapper) (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data))
{
  CCTK_INT retval;

  if (!UnRegisterScheduleWrapper_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UnRegisterScheduleWrapper has not been provided by any active thorn.");
  }

  retval = (*UnRegisterScheduleWrapper_F_Wrapper)(func_before , func_after);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedUnRegisterScheduleWrapper(void);
CCTK_INT IsAliasedUnRegisterScheduleWrapper(void)
{
  return (UnRegisterScheduleWrapper_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasUnRegisterScheduleWrapper_C(CCTK_INT (*func)(CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data)));
CCTK_INT AliasUnRegisterScheduleWrapper_C(CCTK_INT (*func)(CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data)))
{
  CCTK_INT aliased = UnRegisterScheduleWrapper_C_Wrapper != NULL;
  if (!aliased)
  {
    UnRegisterScheduleWrapper_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasUnRegisterScheduleWrapper_F(CCTK_INT (*func)(CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data)));
CCTK_INT AliasUnRegisterScheduleWrapper_F(CCTK_INT (*func)(CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data)))
{
  CCTK_INT aliased = UnRegisterScheduleWrapper_C_Wrapper != NULL;
  if (!aliased)
  {
    UnRegisterScheduleWrapper_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_POINTER_TO_CONST (*UniqueBuildID_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_POINTER_TO_CONST (*UniqueBuildID_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_POINTER_TO_CONST UniqueBuildID (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_POINTER_TO_CONST UniqueBuildID (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!UniqueBuildID_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UniqueBuildID has not been provided by any active thorn.");
  }

  retval = (*UniqueBuildID_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(UniqueBuildID) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(UniqueBuildID) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!UniqueBuildID_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UniqueBuildID has not been provided by any active thorn.");
  }

  retval = (*UniqueBuildID_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedUniqueBuildID(void);
CCTK_INT IsAliasedUniqueBuildID(void)
{
  return (UniqueBuildID_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasUniqueBuildID_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasUniqueBuildID_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = UniqueBuildID_C_Wrapper != NULL;
  if (!aliased)
  {
    UniqueBuildID_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasUniqueBuildID_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasUniqueBuildID_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = UniqueBuildID_C_Wrapper != NULL;
  if (!aliased)
  {
    UniqueBuildID_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_POINTER_TO_CONST (*UniqueConfigID_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_POINTER_TO_CONST (*UniqueConfigID_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_POINTER_TO_CONST UniqueConfigID (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_POINTER_TO_CONST UniqueConfigID (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!UniqueConfigID_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UniqueConfigID has not been provided by any active thorn.");
  }

  retval = (*UniqueConfigID_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(UniqueConfigID) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(UniqueConfigID) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!UniqueConfigID_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UniqueConfigID has not been provided by any active thorn.");
  }

  retval = (*UniqueConfigID_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedUniqueConfigID(void);
CCTK_INT IsAliasedUniqueConfigID(void)
{
  return (UniqueConfigID_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasUniqueConfigID_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasUniqueConfigID_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = UniqueConfigID_C_Wrapper != NULL;
  if (!aliased)
  {
    UniqueConfigID_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasUniqueConfigID_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasUniqueConfigID_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = UniqueConfigID_C_Wrapper != NULL;
  if (!aliased)
  {
    UniqueConfigID_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_POINTER_TO_CONST (*UniqueRunID_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_POINTER_TO_CONST (*UniqueRunID_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_POINTER_TO_CONST UniqueRunID (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_POINTER_TO_CONST UniqueRunID (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!UniqueRunID_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UniqueRunID has not been provided by any active thorn.");
  }

  retval = (*UniqueRunID_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(UniqueRunID) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(UniqueRunID) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!UniqueRunID_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UniqueRunID has not been provided by any active thorn.");
  }

  retval = (*UniqueRunID_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedUniqueRunID(void);
CCTK_INT IsAliasedUniqueRunID(void)
{
  return (UniqueRunID_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasUniqueRunID_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasUniqueRunID_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = UniqueRunID_C_Wrapper != NULL;
  if (!aliased)
  {
    UniqueRunID_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasUniqueRunID_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasUniqueRunID_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = UniqueRunID_C_Wrapper != NULL;
  if (!aliased)
  {
    UniqueRunID_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_POINTER_TO_CONST (*UniqueSimulationID_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_POINTER_TO_CONST (*UniqueSimulationID_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_POINTER_TO_CONST UniqueSimulationID (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_POINTER_TO_CONST UniqueSimulationID (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!UniqueSimulationID_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UniqueSimulationID has not been provided by any active thorn.");
  }

  retval = (*UniqueSimulationID_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(UniqueSimulationID) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(UniqueSimulationID) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!UniqueSimulationID_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UniqueSimulationID has not been provided by any active thorn.");
  }

  retval = (*UniqueSimulationID_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedUniqueSimulationID(void);
CCTK_INT IsAliasedUniqueSimulationID(void)
{
  return (UniqueSimulationID_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasUniqueSimulationID_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasUniqueSimulationID_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = UniqueSimulationID_C_Wrapper != NULL;
  if (!aliased)
  {
    UniqueSimulationID_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasUniqueSimulationID_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasUniqueSimulationID_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = UniqueSimulationID_C_Wrapper != NULL;
  if (!aliased)
  {
    UniqueSimulationID_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*UpperMet_C_Wrapper) (CCTK_REAL* uxx ,
 CCTK_REAL* uxy ,
 CCTK_REAL* uxz ,
 CCTK_REAL* uyy ,
 CCTK_REAL* uyz ,
 CCTK_REAL* uzz ,
 const CCTK_REAL det ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz) = NULL;
static void (*UpperMet_F_Wrapper) (CCTK_REAL* uxx ,
 CCTK_REAL* uxy ,
 CCTK_REAL* uxz ,
 CCTK_REAL* uyy ,
 CCTK_REAL* uyz ,
 CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void UpperMet (CCTK_REAL* uxx ,
 CCTK_REAL* uxy ,
 CCTK_REAL* uxz ,
 CCTK_REAL* uyy ,
 CCTK_REAL* uyz ,
 CCTK_REAL* uzz ,
 const CCTK_REAL det ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz);
void UpperMet (CCTK_REAL* uxx ,
 CCTK_REAL* uxy ,
 CCTK_REAL* uxz ,
 CCTK_REAL* uyy ,
 CCTK_REAL* uyz ,
 CCTK_REAL* uzz ,
 const CCTK_REAL det ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz)
{
  if (!UpperMet_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UpperMet has not been provided by any active thorn.");
  }

  (*UpperMet_C_Wrapper)(uxx , uxy , uxz , uyy , uyz , uzz , det , gxx , gxy , gxz , gyy , gyz , gzz);
}

void CCTK_FCALL CCTK_FNAME(UpperMet) (CCTK_REAL* uxx ,
 CCTK_REAL* uxy ,
 CCTK_REAL* uxz ,
 CCTK_REAL* uyy ,
 CCTK_REAL* uyz ,
 CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz);
void CCTK_FCALL CCTK_FNAME(UpperMet) (CCTK_REAL* uxx ,
 CCTK_REAL* uxy ,
 CCTK_REAL* uxz ,
 CCTK_REAL* uyy ,
 CCTK_REAL* uyz ,
 CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz)
{
  if (!UpperMet_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UpperMet has not been provided by any active thorn.");
  }

  (*UpperMet_F_Wrapper)(uxx , uxy , uxz , uyy , uyz , uzz , det , gxx , gxy , gxz , gyy , gyz , gzz);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedUpperMet(void);
CCTK_INT IsAliasedUpperMet(void)
{
  return (UpperMet_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasUpperMet_C(void (*func)(CCTK_REAL* uxx ,
 CCTK_REAL* uxy ,
 CCTK_REAL* uxz ,
 CCTK_REAL* uyy ,
 CCTK_REAL* uyz ,
 CCTK_REAL* uzz ,
 const CCTK_REAL det ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz));
CCTK_INT AliasUpperMet_C(void (*func)(CCTK_REAL* uxx ,
 CCTK_REAL* uxy ,
 CCTK_REAL* uxz ,
 CCTK_REAL* uyy ,
 CCTK_REAL* uyz ,
 CCTK_REAL* uzz ,
 const CCTK_REAL det ,
 const CCTK_REAL gxx ,
 const CCTK_REAL gxy ,
 const CCTK_REAL gxz ,
 const CCTK_REAL gyy ,
 const CCTK_REAL gyz ,
 const CCTK_REAL gzz))
{
  CCTK_INT aliased = UpperMet_C_Wrapper != NULL;
  if (!aliased)
  {
    UpperMet_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasUpperMet_F(void (*func)(CCTK_REAL* uxx ,
 CCTK_REAL* uxy ,
 CCTK_REAL* uxz ,
 CCTK_REAL* uyy ,
 CCTK_REAL* uyz ,
 CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz));
CCTK_INT AliasUpperMet_F(void (*func)(CCTK_REAL* uxx ,
 CCTK_REAL* uxy ,
 CCTK_REAL* uxz ,
 CCTK_REAL* uyy ,
 CCTK_REAL* uyz ,
 CCTK_REAL* uzz ,
 const CCTK_REAL* det ,
 const CCTK_REAL* gxx ,
 const CCTK_REAL* gxy ,
 const CCTK_REAL* gxz ,
 const CCTK_REAL* gyy ,
 const CCTK_REAL* gyz ,
 const CCTK_REAL* gzz))
{
  CCTK_INT aliased = UpperMet_C_Wrapper != NULL;
  if (!aliased)
  {
    UpperMet_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_POINTER (*VarDataPtrI_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT map ,
 const CCTK_INT reflevel ,
 const CCTK_INT component ,
 const CCTK_INT timelevel ,
 const CCTK_INT varindex) = NULL;
static CCTK_POINTER (*VarDataPtrI_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* map ,
 const CCTK_INT* reflevel ,
 const CCTK_INT* component ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* varindex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_POINTER VarDataPtrI (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT map ,
 const CCTK_INT reflevel ,
 const CCTK_INT component ,
 const CCTK_INT timelevel ,
 const CCTK_INT varindex);
CCTK_POINTER VarDataPtrI (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT map ,
 const CCTK_INT reflevel ,
 const CCTK_INT component ,
 const CCTK_INT timelevel ,
 const CCTK_INT varindex)
{
  CCTK_POINTER retval;

  if (!VarDataPtrI_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function VarDataPtrI has not been provided by any active thorn.");
  }

  retval = (*VarDataPtrI_C_Wrapper)(cctkGH , map , reflevel , component , timelevel , varindex);
  return (retval);
}

CCTK_POINTER CCTK_FCALL CCTK_FNAME(VarDataPtrI) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* map ,
 const CCTK_INT* reflevel ,
 const CCTK_INT* component ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* varindex);
CCTK_POINTER CCTK_FCALL CCTK_FNAME(VarDataPtrI) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* map ,
 const CCTK_INT* reflevel ,
 const CCTK_INT* component ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* varindex)
{
  CCTK_POINTER retval;

  if (!VarDataPtrI_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function VarDataPtrI has not been provided by any active thorn.");
  }

  retval = (*VarDataPtrI_F_Wrapper)(cctkGH , map , reflevel , component , timelevel , varindex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedVarDataPtrI(void);
CCTK_INT IsAliasedVarDataPtrI(void)
{
  return (VarDataPtrI_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasVarDataPtrI_C(CCTK_POINTER (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT map ,
 const CCTK_INT reflevel ,
 const CCTK_INT component ,
 const CCTK_INT timelevel ,
 const CCTK_INT varindex));
CCTK_INT AliasVarDataPtrI_C(CCTK_POINTER (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT map ,
 const CCTK_INT reflevel ,
 const CCTK_INT component ,
 const CCTK_INT timelevel ,
 const CCTK_INT varindex))
{
  CCTK_INT aliased = VarDataPtrI_C_Wrapper != NULL;
  if (!aliased)
  {
    VarDataPtrI_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasVarDataPtrI_F(CCTK_POINTER (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* map ,
 const CCTK_INT* reflevel ,
 const CCTK_INT* component ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* varindex));
CCTK_INT AliasVarDataPtrI_F(CCTK_POINTER (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* map ,
 const CCTK_INT* reflevel ,
 const CCTK_INT* component ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* varindex))
{
  CCTK_INT aliased = VarDataPtrI_C_Wrapper != NULL;
  if (!aliased)
  {
    VarDataPtrI_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*sYlm_DecomposeField_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST name ,
 const CCTK_INT re_gindx ,
 const CCTK_INT im_gindx ,
 const CCTK_REAL radius ,
 const CCTK_INT spin) = NULL;
static CCTK_INT (*sYlm_DecomposeField_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* name ,
 const CCTK_INT* re_gindx ,
 const CCTK_INT* im_gindx ,
 const CCTK_REAL* radius ,
 const CCTK_INT* spin) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT sYlm_DecomposeField (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST name ,
 const CCTK_INT re_gindx ,
 const CCTK_INT im_gindx ,
 const CCTK_REAL radius ,
 const CCTK_INT spin);
CCTK_INT sYlm_DecomposeField (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST name ,
 const CCTK_INT re_gindx ,
 const CCTK_INT im_gindx ,
 const CCTK_REAL radius ,
 const CCTK_INT spin)
{
  CCTK_INT retval;

  if (!sYlm_DecomposeField_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function sYlm_DecomposeField has not been provided by any active thorn.");
  }

  retval = (*sYlm_DecomposeField_C_Wrapper)(cctkGH , name , re_gindx , im_gindx , radius , spin);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(sYlm_DecomposeField) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* name ,
 const CCTK_INT* re_gindx ,
 const CCTK_INT* im_gindx ,
 const CCTK_REAL* radius ,
 const CCTK_INT* spin);
CCTK_INT CCTK_FCALL CCTK_FNAME(sYlm_DecomposeField) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* name ,
 const CCTK_INT* re_gindx ,
 const CCTK_INT* im_gindx ,
 const CCTK_REAL* radius ,
 const CCTK_INT* spin)
{
  CCTK_INT retval;

  if (!sYlm_DecomposeField_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function sYlm_DecomposeField has not been provided by any active thorn.");
  }

  retval = (*sYlm_DecomposeField_F_Wrapper)(cctkGH , name , re_gindx , im_gindx , radius , spin);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedsYlm_DecomposeField(void);
CCTK_INT IsAliasedsYlm_DecomposeField(void)
{
  return (sYlm_DecomposeField_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliassYlm_DecomposeField_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST name ,
 const CCTK_INT re_gindx ,
 const CCTK_INT im_gindx ,
 const CCTK_REAL radius ,
 const CCTK_INT spin));
CCTK_INT AliassYlm_DecomposeField_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST name ,
 const CCTK_INT re_gindx ,
 const CCTK_INT im_gindx ,
 const CCTK_REAL radius ,
 const CCTK_INT spin))
{
  CCTK_INT aliased = sYlm_DecomposeField_C_Wrapper != NULL;
  if (!aliased)
  {
    sYlm_DecomposeField_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliassYlm_DecomposeField_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* name ,
 const CCTK_INT* re_gindx ,
 const CCTK_INT* im_gindx ,
 const CCTK_REAL* radius ,
 const CCTK_INT* spin));
CCTK_INT AliassYlm_DecomposeField_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* name ,
 const CCTK_INT* re_gindx ,
 const CCTK_INT* im_gindx ,
 const CCTK_REAL* radius ,
 const CCTK_INT* spin))
{
  CCTK_INT aliased = sYlm_DecomposeField_C_Wrapper != NULL;
  if (!aliased)
  {
    sYlm_DecomposeField_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*sYlm_DecomposeField_3D_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST name ,
 const CCTK_INT re_gindx ,
 const CCTK_INT im_gindx ,
 const CCTK_INT spin) = NULL;
static CCTK_INT (*sYlm_DecomposeField_3D_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* name ,
 const CCTK_INT* re_gindx ,
 const CCTK_INT* im_gindx ,
 const CCTK_INT* spin) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT sYlm_DecomposeField_3D (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST name ,
 const CCTK_INT re_gindx ,
 const CCTK_INT im_gindx ,
 const CCTK_INT spin);
CCTK_INT sYlm_DecomposeField_3D (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST name ,
 const CCTK_INT re_gindx ,
 const CCTK_INT im_gindx ,
 const CCTK_INT spin)
{
  CCTK_INT retval;

  if (!sYlm_DecomposeField_3D_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function sYlm_DecomposeField_3D has not been provided by any active thorn.");
  }

  retval = (*sYlm_DecomposeField_3D_C_Wrapper)(cctkGH , name , re_gindx , im_gindx , spin);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(sYlm_DecomposeField_3D) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* name ,
 const CCTK_INT* re_gindx ,
 const CCTK_INT* im_gindx ,
 const CCTK_INT* spin);
CCTK_INT CCTK_FCALL CCTK_FNAME(sYlm_DecomposeField_3D) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* name ,
 const CCTK_INT* re_gindx ,
 const CCTK_INT* im_gindx ,
 const CCTK_INT* spin)
{
  CCTK_INT retval;

  if (!sYlm_DecomposeField_3D_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function sYlm_DecomposeField_3D has not been provided by any active thorn.");
  }

  retval = (*sYlm_DecomposeField_3D_F_Wrapper)(cctkGH , name , re_gindx , im_gindx , spin);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedsYlm_DecomposeField_3D(void);
CCTK_INT IsAliasedsYlm_DecomposeField_3D(void)
{
  return (sYlm_DecomposeField_3D_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliassYlm_DecomposeField_3D_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST name ,
 const CCTK_INT re_gindx ,
 const CCTK_INT im_gindx ,
 const CCTK_INT spin));
CCTK_INT AliassYlm_DecomposeField_3D_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER_TO_CONST name ,
 const CCTK_INT re_gindx ,
 const CCTK_INT im_gindx ,
 const CCTK_INT spin))
{
  CCTK_INT aliased = sYlm_DecomposeField_3D_C_Wrapper != NULL;
  if (!aliased)
  {
    sYlm_DecomposeField_3D_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliassYlm_DecomposeField_3D_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* name ,
 const CCTK_INT* re_gindx ,
 const CCTK_INT* im_gindx ,
 const CCTK_INT* spin));
CCTK_INT AliassYlm_DecomposeField_3D_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER_TO_CONST* name ,
 const CCTK_INT* re_gindx ,
 const CCTK_INT* im_gindx ,
 const CCTK_INT* spin))
{
  CCTK_INT aliased = sYlm_DecomposeField_3D_C_Wrapper != NULL;
  if (!aliased)
  {
    sYlm_DecomposeField_3D_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*sf_IdFromName_C_Wrapper) (const CCTK_INT fallbackid ,
 const CCTK_POINTER_TO_CONST name) = NULL;
static CCTK_INT (*sf_IdFromName_F_Wrapper) (const CCTK_INT* fallbackid ,
 const CCTK_POINTER_TO_CONST* name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT sf_IdFromName (const CCTK_INT fallbackid ,
 const CCTK_POINTER_TO_CONST name);
CCTK_INT sf_IdFromName (const CCTK_INT fallbackid ,
 const CCTK_POINTER_TO_CONST name)
{
  CCTK_INT retval;

  if (!sf_IdFromName_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function sf_IdFromName has not been provided by any active thorn.");
  }

  retval = (*sf_IdFromName_C_Wrapper)(fallbackid , name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(sf_IdFromName) (const CCTK_INT* fallbackid ,
 const CCTK_POINTER_TO_CONST* name);
CCTK_INT CCTK_FCALL CCTK_FNAME(sf_IdFromName) (const CCTK_INT* fallbackid ,
 const CCTK_POINTER_TO_CONST* name)
{
  CCTK_INT retval;

  if (!sf_IdFromName_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function sf_IdFromName has not been provided by any active thorn.");
  }

  retval = (*sf_IdFromName_F_Wrapper)(fallbackid , name);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedsf_IdFromName(void);
CCTK_INT IsAliasedsf_IdFromName(void)
{
  return (sf_IdFromName_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT Aliassf_IdFromName_C(CCTK_INT (*func)(const CCTK_INT fallbackid ,
 const CCTK_POINTER_TO_CONST name));
CCTK_INT Aliassf_IdFromName_C(CCTK_INT (*func)(const CCTK_INT fallbackid ,
 const CCTK_POINTER_TO_CONST name))
{
  CCTK_INT aliased = sf_IdFromName_C_Wrapper != NULL;
  if (!aliased)
  {
    sf_IdFromName_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT Aliassf_IdFromName_F(CCTK_INT (*func)(const CCTK_INT* fallbackid ,
 const CCTK_POINTER_TO_CONST* name));
CCTK_INT Aliassf_IdFromName_F(CCTK_INT (*func)(const CCTK_INT* fallbackid ,
 const CCTK_POINTER_TO_CONST* name))
{
  CCTK_INT aliased = sf_IdFromName_C_Wrapper != NULL;
  if (!aliased)
  {
    sf_IdFromName_F_Wrapper = func;
  }
  return aliased;
}
