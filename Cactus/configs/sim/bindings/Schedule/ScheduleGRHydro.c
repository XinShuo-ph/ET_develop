/*@@
   @file       ScheduleGRHydro.c
   @author     Automatically generated by CreateScheduleBindings.pl
   @desc
               Creates the schedule and parameter recovery bindings 
               for thorn GRHydro
   @enddesc
@@*/


#include "GRHydro/cctk.h"
#include "GRHydro/CParameters.h"
#include "cctki_ScheduleBindings.h"
#include "GRHydro/cctk_ScheduleFunctions.h"

/* Prototypes for Fortran schedule bindings functions to be registered */
/* Note that this is a cheat, we just need a function pointer. */
extern int CCTK_FNAME(GRHydro_InitDivergenceClean)(void);
extern int CCTK_FNAME(GRHydro_DivBInit)(void);
extern int CCTK_FNAME(GRHydro_BvecfromAvec)(void);
extern int CCTK_FNAME(GRHydro_SetUpCoords)(void);
extern int CCTK_FNAME(GRHydro_EvolveCoords)(void);
extern int CCTK_FNAME(GRHydro_ComovingShift)(void);
extern int CCTK_FNAME(GRHydro_Startup)(void);
extern int CCTK_FNAME(GRHydro_ParamCheck)(void);
extern int CCTK_FNAME(GRHydro_InitSymBound)(void);
extern int CCTK_FNAME(GRHydro_Rho_Minima_Setup)(void);
extern int CCTK_FNAME(GRHydro_Change_Rho_Minimum_At_Recovery)(void);
extern int CCTK_FNAME(GRHydro_SqrtSpatialDeterminant)(void);
extern int CCTK_FNAME(GRHydro_InitialAtmosphereResetM)(void);
extern int CCTK_FNAME(GRHydro_InitialAtmosphereResetM)(void);
extern int CCTK_FNAME(GRHydro_InitialAtmosphereResetAM)(void);
extern int CCTK_FNAME(GRHydro_InitialAtmosphereResetAM)(void);
extern int CCTK_FNAME(GRHydro_InitialAtmosphereReset)(void);
extern int CCTK_FNAME(GRHydro_InitialAtmosphereReset)(void);
extern int CCTK_FNAME(GRHydro_ENOSetup)(void);
extern int CCTK_FNAME(GRHydro_ENOShutdown)(void);
extern int CCTK_FNAME(GRHydro_WENOSetup)(void);
extern int CCTK_FNAME(GRHydro_WENOShutdown)(void);
extern int CCTK_FNAME(GRHydro_EoSChangeGamma)(void);
extern int CCTK_FNAME(GRHydro_EoSChangeK)(void);
extern int CCTK_FNAME(GRHydro_EoSChangeGammaK_Shibata)(void);
extern int CCTK_FNAME(GRHydro_Scalar_Setup)(void);
extern int CCTK_FNAME(GRHydro_Scalar_Setup)(void);
extern int CCTK_FNAME(GRHydro_SetupMask)(void);
extern int CCTK_FNAME(GRHydroCopyIntegerMask)(void);
extern int CCTK_FNAME(GRHydro_SetupMask)(void);
extern int CCTK_FNAME(GRHydro_SetupMask)(void);
extern int CCTK_FNAME(GRHydro_InitialAtmosphereReset)(void);
extern int CCTK_FNAME(GRHydro_InitAtmosMask)(void);
extern int CCTK_FNAME(GRHydro_InitAtmosMask)(void);
extern int CCTK_FNAME(GRHydro_InitAtmosMask)(void);
extern int CCTK_FNAME(GRHydroParticleInitial)(void);
extern int CCTK_FNAME(GRHydroParticleRHS)(void);
extern int CCTK_FNAME(SourceTermsM)(void);
extern int CCTK_FNAME(SourceTermsAM)(void);
extern int CCTK_FNAME(SourceTerms)(void);
extern int CCTK_FNAME(GRHydroStartLoop)(void);
extern int CCTK_FNAME(Reconstruction)(void);
extern int CCTK_FNAME(ReconstructionPolytype)(void);
extern int CCTK_FNAME(RiemannSolveM)(void);
extern int CCTK_FNAME(RiemannSolveAM)(void);
extern int CCTK_FNAME(RiemannSolve)(void);
extern int CCTK_FNAME(RiemannSolvePolytype)(void);
extern int CCTK_FNAME(GRHydro_FSAlpha)(void);
extern int CCTK_FNAME(GRHydro_SplitFlux)(void);
extern int CCTK_FNAME(GRHydro_FSAlpha)(void);
extern int CCTK_FNAME(GRHydro_SplitFlux)(void);
extern int CCTK_FNAME(UpdateCalculation)(void);
extern int CCTK_FNAME(GRHydroAdvanceLoop)(void);
extern int CCTK_FNAME(GRHydroUpdateAtmosphereMask)(void);
extern int CCTK_FNAME(GRHydro_RefinementLevel)(void);
extern int CCTK_FNAME(GRHydro_RefinementLevel)(void);
extern int CCTK_FNAME(GRHydro_SqrtSpatialDeterminant)(void);
extern int CCTK_FNAME(GRHydro_SqrtSpatialDeterminant)(void);
extern int CCTK_FNAME(GRHydro_RefinementLevel)(void);
extern int CCTK_FNAME(GRHydro_RefinementLevel)(void);
extern int CCTK_FNAME(GRHydro_RefinementLevel)(void);
extern int CCTK_FNAME(Conservative2PrimitiveM)(void);
extern int CCTK_FNAME(Primitive2ConservativeCellsM)(void);
extern int CCTK_FNAME(GRHydro_BvecfromAvec)(void);
extern int CCTK_FNAME(Conservative2PrimitiveAM)(void);
extern int CCTK_FNAME(Primitive2ConservativeCellsAM)(void);
extern int CCTK_FNAME(Conservative2Primitive)(void);
extern int CCTK_FNAME(Primitive2ConservativeCells)(void);
extern int CCTK_FNAME(Conservative2PrimitivePolytypeM)(void);
extern int CCTK_FNAME(Primitive2ConservativePolyCellsM)(void);
extern int CCTK_FNAME(Conservative2PrimitivePolytypeAM)(void);
extern int CCTK_FNAME(Primitive2ConservativePolyCellsAM)(void);
extern int CCTK_FNAME(Conservative2PrimitivePolytype)(void);
extern int CCTK_FNAME(Primitive2ConservativePolyCells)(void);
extern int CCTK_FNAME(GRHydro_SelectAtmosphereMaskBoundaries)(void);
extern int CCTK_FNAME(GRHydro_Boundaries)(void);
extern int CCTK_FNAME(GRHydro_Boundaries)(void);
extern int CCTK_FNAME(GRHydro_SelectPrimitiveInitialGuessesBoundaries)(void);
extern int CCTK_FNAME(GRHydro_SelectPrimitiveBoundaries)(void);
extern int CCTK_FNAME(GRHydro_SelectPrimitiveInitialGuessesBoundaries)(void);
extern int CCTK_FNAME(GRHydro_SelectPrimitiveBoundaries)(void);
extern int CCTK_FNAME(GRHydroPostSyncAtmosphereMask)(void);
extern int CCTK_FNAME(GRHydro_AtmosphereResetM)(void);
extern int CCTK_FNAME(GRHydro_AtmosphereResetAM)(void);
extern int CCTK_FNAME(GRHydro_AtmosphereReset)(void);
extern int CCTK_FNAME(GRHydro_Check_Rho_Minimum)(void);
extern int CCTK_FNAME(GRHydro_RefinementLevel)(void);
extern int CCTK_FNAME(reset_GRHydro_C2P_failed)(void);
extern int CCTK_FNAME(reset_GRHydro_C2P_failed)(void);
extern int CCTK_FNAME(sync_GRHydro_C2P_failed)(void);
extern int CCTK_FNAME(check_GRHydro_C2P_failed)(void);
extern int CCTK_FNAME(GRHydro_TmunuM)(void);
extern int CCTK_FNAME(GRHydro_CalcBcom)(void);
extern int CCTK_FNAME(GRHydro_Tmunu)(void);
extern int CCTK_FNAME(GRHydro_CalcDivB)(void);
extern int CCTK_FNAME(ConstrainSconTo1D)(void);
extern int CCTK_FNAME(H_viscosity)(void);

void CCTKi_BindingsSchedule_GRHydro(void);
void CCTKi_BindingsSchedule_GRHydro(void)
{
  DECLARE_CCTK_PARAMETERS
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::execute_MoL_Step")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::execute_MoL_Step", CCTK_DeclaredTimeLevels("GRHydro::execute_MoL_Step"));
  CCTKi_ScheduleGroupStorage("GRHydro::execute_MoL_Step",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::execute_MoL_PostStep")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::execute_MoL_PostStep", CCTK_DeclaredTimeLevels("GRHydro::execute_MoL_PostStep"));
  CCTKi_ScheduleGroupStorage("GRHydro::execute_MoL_PostStep",1);
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydro_Reset_Execution_Flags,
                           "GRHydro_Reset_Execution_Flags",
                           "GRHydro",
                           "GRHydro",
                           "Initially set execution flags to 'YEAH, Execute'!",
                           "CCTK_BASEGRID",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GLOBAL",
                           "");
  }
if (use_MoL_slow_multirate_sector)
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydro_Set_Execution_Flags,
                           "GRHydro_Set_Execution_Flags",
                           "GRHydro",
                           "GRHydro",
                           "Check if we need to execute RHS / Post-step calculation",
                           "MoL_Step",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LEVEL",
                           "",
                           "MoL_PostStepModify",
                           "MoL_DecrementCounter");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydro_Reset_Execution_Flags,
                           "GRHydro_Reset_Execution_Flags",
                           "GRHydro",
                           "GRHydro",
                           "Reset execution flags to 'YEAH, Execute'!",
                           "MoL_StartStep",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LEVEL",
                           "",
                           "MoL_SetCounter");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydro_Reset_Execution_Flags,
                           "GRHydro_Reset_Execution_Flags",
                           "GRHydro",
                           "GRHydro",
                           "Reset execution flags to 'YEAH, Execute'!",
                           "MoL_Evolution",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LEVEL",
                           "",
                           "MoL_FinishLoop");
  }
}
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::dens")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::dens", CCTK_DeclaredTimeLevels("GRHydro::dens"));
  CCTKi_ScheduleGroupStorage("GRHydro::dens",timelevels);
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::tau")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::tau", CCTK_DeclaredTimeLevels("GRHydro::tau"));
  CCTKi_ScheduleGroupStorage("GRHydro::tau",timelevels);
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::scon")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::scon", CCTK_DeclaredTimeLevels("GRHydro::scon"));
  CCTKi_ScheduleGroupStorage("GRHydro::scon",timelevels);
if (number_of_particles)
{
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::particles")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::particles", CCTK_DeclaredTimeLevels("GRHydro::particles"));
  CCTKi_ScheduleGroupStorage("GRHydro::particles",timelevels);
}
if(CCTK_Equals(Y_e_evolution_method,"GRHydro"))
{
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::Y_e_con")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::Y_e_con", CCTK_DeclaredTimeLevels("GRHydro::Y_e_con"));
  CCTKi_ScheduleGroupStorage("GRHydro::Y_e_con",timelevels);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::Y_e_con_rhs")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::Y_e_con_rhs", CCTK_DeclaredTimeLevels("GRHydro::Y_e_con_rhs"));
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::Y_e_con_flux")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::Y_e_con_flux", CCTK_DeclaredTimeLevels("GRHydro::Y_e_con_flux"));
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::Y_e_plus")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::Y_e_plus", CCTK_DeclaredTimeLevels("GRHydro::Y_e_plus"));
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::Y_e_minus")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::Y_e_minus", CCTK_DeclaredTimeLevels("GRHydro::Y_e_minus"));
  CCTKi_ScheduleGroupStorage("GRHydro::Y_e_con_rhs",1);
  CCTKi_ScheduleGroupStorage("GRHydro::Y_e_con_flux",1);
  CCTKi_ScheduleGroupStorage("GRHydro::Y_e_plus",1);
  CCTKi_ScheduleGroupStorage("GRHydro::Y_e_minus",1);
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("HydroBase::Y_e")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "HydroBase::Y_e", CCTK_DeclaredTimeLevels("HydroBase::Y_e"));
  CCTKi_ScheduleGroupStorage("HydroBase::Y_e",timelevels);
}
if(CCTK_Equals(temperature_evolution_method,"GRHydro"))
{
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::tempplus")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::tempplus", CCTK_DeclaredTimeLevels("GRHydro::tempplus"));
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::tempminus")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::tempminus", CCTK_DeclaredTimeLevels("GRHydro::tempminus"));
  CCTKi_ScheduleGroupStorage("GRHydro::tempplus",1);
  CCTKi_ScheduleGroupStorage("GRHydro::tempminus",1);
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("HydroBase::temperature")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "HydroBase::temperature", CCTK_DeclaredTimeLevels("HydroBase::temperature"));
  CCTKi_ScheduleGroupStorage("HydroBase::temperature",timelevels);
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("HydroBase::entropy")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "HydroBase::entropy", CCTK_DeclaredTimeLevels("HydroBase::entropy"));
  CCTKi_ScheduleGroupStorage("HydroBase::entropy",timelevels);
}
if(CCTK_Equals(Bvec_evolution_method,"GRHydro"))
{
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("HydroBase::Bvec")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "HydroBase::Bvec", CCTK_DeclaredTimeLevels("HydroBase::Bvec"));
  CCTKi_ScheduleGroupStorage("HydroBase::Bvec",timelevels);
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::Bcons")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::Bcons", CCTK_DeclaredTimeLevels("GRHydro::Bcons"));
  CCTKi_ScheduleGroupStorage("GRHydro::Bcons",timelevels);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::Bconsrhs")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::Bconsrhs", CCTK_DeclaredTimeLevels("GRHydro::Bconsrhs"));
  CCTKi_ScheduleGroupStorage("GRHydro::Bconsrhs",1);
  if (clean_divergence)
  {
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::psidc")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::psidc", CCTK_DeclaredTimeLevels("GRHydro::psidc"));
  CCTKi_ScheduleGroupStorage("GRHydro::psidc",timelevels);
  }
} else if(CCTK_Equals(Bvec_evolution_method,"GRHydro_Avec")) {
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("HydroBase::Bvec")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "HydroBase::Bvec", CCTK_DeclaredTimeLevels("HydroBase::Bvec"));
  CCTKi_ScheduleGroupStorage("HydroBase::Bvec",timelevels);
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("HydroBase::Avec")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "HydroBase::Avec", CCTK_DeclaredTimeLevels("HydroBase::Avec"));
  CCTKi_ScheduleGroupStorage("HydroBase::Avec",timelevels);
  if (CCTK_Equals(Avec_gauge,"Lorenz")) 
  {
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("HydroBase::Aphi")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "HydroBase::Aphi", CCTK_DeclaredTimeLevels("HydroBase::Aphi"));
  CCTKi_ScheduleGroupStorage("HydroBase::Aphi",timelevels);
  } 
}
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::evolve_MHD")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::evolve_MHD", CCTK_DeclaredTimeLevels("GRHydro::evolve_MHD"));
  CCTKi_ScheduleGroupStorage("GRHydro::evolve_MHD",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::evolve_Y_e")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::evolve_Y_e", CCTK_DeclaredTimeLevels("GRHydro::evolve_Y_e"));
  CCTKi_ScheduleGroupStorage("GRHydro::evolve_Y_e",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::evolve_temper")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::evolve_temper", CCTK_DeclaredTimeLevels("GRHydro::evolve_temper"));
  CCTKi_ScheduleGroupStorage("GRHydro::evolve_temper",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_reflevel")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::GRHydro_reflevel", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_reflevel"));
  CCTKi_ScheduleGroupStorage("GRHydro::GRHydro_reflevel",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::InLastMoLPostStep")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::InLastMoLPostStep", CCTK_DeclaredTimeLevels("GRHydro::InLastMoLPostStep"));
  CCTKi_ScheduleGroupStorage("GRHydro::InLastMoLPostStep",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::sdetg")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::sdetg", CCTK_DeclaredTimeLevels("GRHydro::sdetg"));
  CCTKi_ScheduleGroupStorage("GRHydro::sdetg",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::densrhs")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::densrhs", CCTK_DeclaredTimeLevels("GRHydro::densrhs"));
  CCTKi_ScheduleGroupStorage("GRHydro::densrhs",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::taurhs")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::taurhs", CCTK_DeclaredTimeLevels("GRHydro::taurhs"));
  CCTKi_ScheduleGroupStorage("GRHydro::taurhs",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::srhs")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::srhs", CCTK_DeclaredTimeLevels("GRHydro::srhs"));
  CCTKi_ScheduleGroupStorage("GRHydro::srhs",1);
if(CCTK_Equals(Bvec_evolution_method,"GRHydro"))
{
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::Bconsrhs")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::Bconsrhs", CCTK_DeclaredTimeLevels("GRHydro::Bconsrhs"));
  CCTKi_ScheduleGroupStorage("GRHydro::Bconsrhs",1);
  if (clean_divergence)
  {
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::psidcrhs")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::psidcrhs", CCTK_DeclaredTimeLevels("GRHydro::psidcrhs"));
  CCTKi_ScheduleGroupStorage("GRHydro::psidcrhs",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::whichpsidcspeed")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::whichpsidcspeed", CCTK_DeclaredTimeLevels("GRHydro::whichpsidcspeed"));
  CCTKi_ScheduleGroupStorage("GRHydro::whichpsidcspeed",1);
  }
  if (track_divB)
  {
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::divB")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::divB", CCTK_DeclaredTimeLevels("GRHydro::divB"));
  CCTKi_ScheduleGroupStorage("GRHydro::divB",1);
  }
  if (calculate_bcom)
  {
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::bcom")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::bcom", CCTK_DeclaredTimeLevels("GRHydro::bcom"));
  CCTKi_ScheduleGroupStorage("GRHydro::bcom",timelevels);
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::bcom0")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::bcom0", CCTK_DeclaredTimeLevels("GRHydro::bcom0"));
  CCTKi_ScheduleGroupStorage("GRHydro::bcom0",timelevels);
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::bcom_sq")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::bcom_sq", CCTK_DeclaredTimeLevels("GRHydro::bcom_sq"));
  CCTKi_ScheduleGroupStorage("GRHydro::bcom_sq",timelevels);
  }
} else if(CCTK_Equals(Bvec_evolution_method,"GRHydro_Avec")) {
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::Avecrhs")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::Avecrhs", CCTK_DeclaredTimeLevels("GRHydro::Avecrhs"));
  CCTKi_ScheduleGroupStorage("GRHydro::Avecrhs",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::evolve_Lorenz_gge")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::evolve_Lorenz_gge", CCTK_DeclaredTimeLevels("GRHydro::evolve_Lorenz_gge"));
  CCTKi_ScheduleGroupStorage("GRHydro::evolve_Lorenz_gge",1);
  if (CCTK_Equals(Avec_gauge,"Lorenz"))
  {
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::Aphirhs")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::Aphirhs", CCTK_DeclaredTimeLevels("GRHydro::Aphirhs"));
  CCTKi_ScheduleGroupStorage("GRHydro::Aphirhs",1);
  }
  if (track_divB)
  {
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::divB")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::divB", CCTK_DeclaredTimeLevels("GRHydro::divB"));
  CCTKi_ScheduleGroupStorage("GRHydro::divB",1);
  }
  if (calculate_bcom)
  {
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::bcom")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::bcom", CCTK_DeclaredTimeLevels("GRHydro::bcom"));
  CCTKi_ScheduleGroupStorage("GRHydro::bcom",timelevels);
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::bcom0")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::bcom0", CCTK_DeclaredTimeLevels("GRHydro::bcom0"));
  CCTKi_ScheduleGroupStorage("GRHydro::bcom0",timelevels);
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::bcom_sq")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::bcom_sq", CCTK_DeclaredTimeLevels("GRHydro::bcom_sq"));
  CCTKi_ScheduleGroupStorage("GRHydro::bcom_sq",timelevels);
  }
}
if(CCTK_Equals(entropy_evolution_method,"GRHydro"))
{
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("HydroBase::entropy")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "HydroBase::entropy", CCTK_DeclaredTimeLevels("HydroBase::entropy"));
  CCTKi_ScheduleGroupStorage("HydroBase::entropy",timelevels);
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::entropycons")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::entropycons", CCTK_DeclaredTimeLevels("GRHydro::entropycons"));
  CCTKi_ScheduleGroupStorage("GRHydro::entropycons",timelevels);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::entropyrhs")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::entropyrhs", CCTK_DeclaredTimeLevels("GRHydro::entropyrhs"));
  CCTKi_ScheduleGroupStorage("GRHydro::entropyrhs",1);
}
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::evolve_MHD")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::evolve_MHD", CCTK_DeclaredTimeLevels("GRHydro::evolve_MHD"));
  CCTKi_ScheduleGroupStorage("GRHydro::evolve_MHD",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::evolve_Y_e")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::evolve_Y_e", CCTK_DeclaredTimeLevels("GRHydro::evolve_Y_e"));
  CCTKi_ScheduleGroupStorage("GRHydro::evolve_Y_e",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::evolve_temper")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::evolve_temper", CCTK_DeclaredTimeLevels("GRHydro::evolve_temper"));
  CCTKi_ScheduleGroupStorage("GRHydro::evolve_temper",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::evolve_entropy")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::evolve_entropy", CCTK_DeclaredTimeLevels("GRHydro::evolve_entropy"));
  CCTKi_ScheduleGroupStorage("GRHydro::evolve_entropy",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_reflevel")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::GRHydro_reflevel", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_reflevel"));
  CCTKi_ScheduleGroupStorage("GRHydro::GRHydro_reflevel",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::InLastMoLPostStep")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::InLastMoLPostStep", CCTK_DeclaredTimeLevels("GRHydro::InLastMoLPostStep"));
  CCTKi_ScheduleGroupStorage("GRHydro::InLastMoLPostStep",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::densrhs")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::densrhs", CCTK_DeclaredTimeLevels("GRHydro::densrhs"));
  CCTKi_ScheduleGroupStorage("GRHydro::densrhs",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::taurhs")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::taurhs", CCTK_DeclaredTimeLevels("GRHydro::taurhs"));
  CCTKi_ScheduleGroupStorage("GRHydro::taurhs",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::srhs")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::srhs", CCTK_DeclaredTimeLevels("GRHydro::srhs"));
  CCTKi_ScheduleGroupStorage("GRHydro::srhs",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_eos_scalars")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::GRHydro_eos_scalars", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_eos_scalars"));
  CCTKi_ScheduleGroupStorage("GRHydro::GRHydro_eos_scalars",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_minima")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::GRHydro_minima", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_minima"));
  CCTKi_ScheduleGroupStorage("GRHydro::GRHydro_minima",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_scalars")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::GRHydro_scalars", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_scalars"));
  CCTKi_ScheduleGroupStorage("GRHydro::GRHydro_scalars",1);
if (number_of_particles)
{
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::particle_rhs")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::particle_rhs", CCTK_DeclaredTimeLevels("GRHydro::particle_rhs"));
  CCTKi_ScheduleGroupStorage("GRHydro::particle_rhs",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::particle_arrays")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::particle_arrays", CCTK_DeclaredTimeLevels("GRHydro::particle_arrays"));
  CCTKi_ScheduleGroupStorage("GRHydro::particle_arrays",1);
}
if (evolve_tracer)
{
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracers")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::GRHydro_tracers", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracers"));
  CCTKi_ScheduleGroupStorage("GRHydro::GRHydro_tracers",timelevels);
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_cons_tracers")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::GRHydro_cons_tracers", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_cons_tracers"));
  CCTKi_ScheduleGroupStorage("GRHydro::GRHydro_cons_tracers",timelevels);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_rhs")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::GRHydro_tracer_rhs", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_rhs"));
  CCTKi_ScheduleGroupStorage("GRHydro::GRHydro_tracer_rhs",1);
}
if (transport_constraints)
{
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::Evec")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::Evec", CCTK_DeclaredTimeLevels("GRHydro::Evec"));
  CCTKi_ScheduleGroupStorage("GRHydro::Evec",1);
}
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("GRHydro_Initial",
"GRHydro_Initial",
                        "GRHydro",
                        "GRHydro",
                        "GRHydro initial data group",
                        "HydroBase_Initial",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        0, /* Number of AFTER    routines  */
                        0, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "");
  }
if(CCTK_Equals(Bvec_evolution_method,"GRHydro") || CCTK_Equals(Bvec_evolution_method,"GRHydro_Avec"))
{
  if (clean_divergence)
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_InitDivergenceClean),
                           "GRHydro_InitDivergenceClean",
                           "GRHydro",
                           "GRHydro",
                           "Set psi for divergence cleaning initially to zero",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  }
  if (track_divB)
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_DivBInit),
                           "GRHydro_DivBInit",
                           "GRHydro",
                           "GRHydro",
                           "Set divB initially to zero",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  }
}
if(CCTK_Equals(Bvec_evolution_method,"GRHydro_Avec") && CCTK_Equals(initial_Bvec,"Bvec_from_Avec") )
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_BvecfromAvec),
                           "GRHydro_BvecfromAvec",
                           "GRHydro",
                           "GRHydro",
                           "Populate Bvec from Avec",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("HydroBase_Boundaries",
"HydroBase_Boundaries",
                        "GRHydro",
                        "GRHydro",
                        "Call boundary conditions after magnetic field initial data setup",
                        "HydroBase_Initial",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        2, /* Number of AFTER    routines  */
                        0, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "",
                        "GRHydro_PoloidalMagFieldM",
                        "GRHydro_Bvec_from_Avec");
  }
}
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("ADMBase::metric")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "ADMBase::metric", CCTK_DeclaredTimeLevels("ADMBase::metric"));
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("ADMBase::curv")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "ADMBase::curv", CCTK_DeclaredTimeLevels("ADMBase::curv"));
  CCTKi_ScheduleGroupStorage("ADMBase::metric",timelevels);
  CCTKi_ScheduleGroupStorage("ADMBase::curv",timelevels);
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("ADMBase::lapse")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "ADMBase::lapse", CCTK_DeclaredTimeLevels("ADMBase::lapse"));
  CCTKi_ScheduleGroupStorage("ADMBase::lapse",timelevels);
if (!CCTK_Equals(initial_shift,"none")) 
{
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("ADMBase::shift")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "ADMBase::shift", CCTK_DeclaredTimeLevels("ADMBase::shift"));
  CCTKi_ScheduleGroupStorage("ADMBase::shift",timelevels);
  if (CCTK_Equals(shift_evolution_method,"Comoving"))
  {
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_coords")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::GRHydro_coords", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_coords"));
  CCTKi_ScheduleGroupStorage("GRHydro::GRHydro_coords",timelevels);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_coords_rhs")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::GRHydro_coords_rhs", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_coords_rhs"));
  CCTKi_ScheduleGroupStorage("GRHydro::GRHydro_coords_rhs",1);
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_SetUpCoords),
                           "GRHydro_SetUpCoords",
                           "GRHydro",
                           "GRHydro",
                           "Set up the coordinates for use with the comoving shift",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_EvolveCoords),
                           "GRHydro_EvolveCoords",
                           "GRHydro",
                           "GRHydro",
                           "Evolve the coordinates for the comoving shift",
                           "GRHydroRHS",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_ComovingShift),
                           "GRHydro_ComovingShift",
                           "GRHydro",
                           "GRHydro",
                           "Comoving shift",
                           "HydroBase_PostStep",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_Con2Prim");
  }
  }           
}
if(CCTK_IsImplementationActive("Coordinates")) {
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::lvel")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::lvel", CCTK_DeclaredTimeLevels("GRHydro::lvel"));
  CCTKi_ScheduleGroupStorage("GRHydro::lvel",timelevels);
  if(CCTK_Equals(Bvec_evolution_method,"GRHydro") ||
     CCTK_Equals(Bvec_evolution_method,"GRHydro_Avec")) {
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::lBvec")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::lBvec", CCTK_DeclaredTimeLevels("GRHydro::lBvec"));
  CCTKi_ScheduleGroupStorage("GRHydro::lBvec",timelevels);
  }
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::local_metric")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::local_metric", CCTK_DeclaredTimeLevels("GRHydro::local_metric"));
  CCTKi_ScheduleGroupStorage("GRHydro::local_metric",timelevels);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::local_extrinsic_curvature")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::local_extrinsic_curvature", CCTK_DeclaredTimeLevels("GRHydro::local_extrinsic_curvature"));
  CCTKi_ScheduleGroupStorage("GRHydro::local_extrinsic_curvature",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::local_shift")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::local_shift", CCTK_DeclaredTimeLevels("GRHydro::local_shift"));
  CCTKi_ScheduleGroupStorage("GRHydro::local_shift",1);
}
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("STATICCONFORMAL::conformal_state")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "STATICCONFORMAL::conformal_state", CCTK_DeclaredTimeLevels("STATICCONFORMAL::conformal_state"));
  CCTKi_ScheduleGroupStorage("STATICCONFORMAL::conformal_state",1);
if (apply_H_viscosity)
{
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::H_viscosity_temps")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::H_viscosity_temps", CCTK_DeclaredTimeLevels("GRHydro::H_viscosity_temps"));
  CCTKi_ScheduleGroupStorage("GRHydro::H_viscosity_temps",1);
}
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_Startup),
                           "GRHydro_Startup",
                           "GRHydro",
                           "GRHydro",
                           "Startup banner",
                           "CCTK_WRAGH",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydro_RegisterMask,
                           "GRHydro_RegisterMask",
                           "GRHydro",
                           "GRHydro",
                           "Register the hydro masks",
                           "CCTK_STARTUP",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_ParamCheck),
                           "GRHydro_ParamCheck",
                           "GRHydro",
                           "GRHydro",
                           "Check parameters",
                           "CCTK_PARAMCHECK",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
if(CCTK_IsImplementationActive("Coordinates")) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydro_check_Jacobian_state,
                           "GRHydro_check_Jacobian_state",
                           "GRHydro",
                           "GRHydro",
                           "Test state of Jacobians",
                           "CCTK_BASEGRID",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           2, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GLOBAL",
                           "",
                           "TmunuBase_SetStressEnergyState",
                           "Coordinates_SetGlobalCoords_Group");
  }
}
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_InitSymBound),
                           "GRHydro_InitSymBound",
                           "GRHydro",
                           "GRHydro",
                           "Schedule symmetries and check shift state",
                           "CCTK_BASEGRID",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           2, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "ADMBase_SetShiftStateOn",
                           "ADMBase_SetShiftStateOff");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydro_EOSHandle,
                           "GRHydro_EOSHandle",
                           "GRHydro",
                           "GRHydro",
                           "Set the EOS number",
                           "CCTK_INITIAL",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "global",
                           "",
                           "HydroBase_Initial");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydro_EOSHandle,
                           "GRHydro_EOSHandle",
                           "GRHydro",
                           "GRHydro",
                           "Set the EOS number",
                           "CCTK_POST_RECOVER_VARIABLES",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "global",
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_Rho_Minima_Setup),
                           "GRHydro_Rho_Minima_Setup",
                           "GRHydro",
                           "GRHydro",
                           "Set up minimum for the rest-mass density in the atmosphere (before intial data)",
                           "CCTK_INITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_Initial");
  }
if (rho_abs_min_after_recovery > 0.0)
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_Change_Rho_Minimum_At_Recovery),
                           "GRHydro_Change_Rho_Minimum_At_Recovery",
                           "GRHydro",
                           "GRHydro",
                           "Set up minimum for the rest-mass density in the atmosphere (before intial data)",
                           "CCTK_POST_RECOVER_VARIABLES",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
}
if (CCTK_IsThornActive("PUGH" ))
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydro_Rho_Minima_Setup_Final_PUGH,
                           "GRHydro_Rho_Minima_Setup_Final_PUGH",
                           "GRHydro",
                           "GRHydro",
                           "Set the value of the rest-mass density of the atmosphere which will be used during the evolution (PUGH)",
                           "CCTK_POSTINITIAL",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           2, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "MoL_PostStepModify",
                           "MoL_PostStep");
  }
}
else if (CCTK_IsThornActive("Carpet"))
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydro_Rho_Minima_Setup_Final,
                           "GRHydro_Rho_Minima_Setup_Final",
                           "GRHydro",
                           "GRHydro",
                           "Set the value of the rest-mass density of the atmosphere which will be used during the evolution",
                           "CCTK_POSTPOSTINITIAL",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "Con2Prim");
  }
}
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_SqrtSpatialDeterminant),
                           "GRHydro_SqrtSpatialDeterminant",
                           "GRHydro",
                           "GRHydro",
                           "Calculate sdetg",
                           "CCTK_INITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           2, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_Prim2ConInitial",
                           "HydroBase_Initial",
                           "GRHydroTransformADMToLocalBasis");
  }
if(CCTK_Equals(Bvec_evolution_method,"GRHydro"))
{
  if (CCTK_IsThornActive("PUGH" ))
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_InitialAtmosphereResetM),
                           "GRHydro_InitialAtmosphereResetM",
                           "GRHydro",
                           "GRHydro",
                           "Use mask to enforce atmosphere at initial time",
                           "CCTK_POSTINITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           2, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "MoL_PostStepModify",
                           "MoL_PostStep",
                           "GRHydro_Rho_Minima_Setup_Final_PUGH");
  }
  }
  else if (CCTK_IsThornActive("Carpet"))
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_InitialAtmosphereResetM),
                           "GRHydro_InitialAtmosphereResetM",
                           "GRHydro",
                           "GRHydro",
                           "Use mask to enforce atmosphere at initial time",
                           "CCTK_POSTPOSTINITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "Con2Prim",
                           "GRHydro_Rho_Minima_Setup_Final");
  }
  }
} else if(CCTK_Equals(Bvec_evolution_method,"GRHydro_Avec")) {
  if (CCTK_IsThornActive("PUGH" ))
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_InitialAtmosphereResetAM),
                           "GRHydro_InitialAtmosphereResetAM",
                           "GRHydro",
                           "GRHydro",
                           "Use mask to enforce atmosphere at initial time",
                           "CCTK_POSTINITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           2, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "MoL_PostStepModify",
                           "MoL_PostStep",
                           "GRHydro_Rho_Minima_Setup_Final_PUGH");
  }
  }
  else if (CCTK_IsThornActive("Carpet"))
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_InitialAtmosphereResetAM),
                           "GRHydro_InitialAtmosphereResetAM",
                           "GRHydro",
                           "GRHydro",
                           "Use mask to enforce atmosphere at initial time",
                           "CCTK_POSTPOSTINITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "Con2Prim",
                           "GRHydro_Rho_Minima_Setup_Final");
  }
  }
} else if(CCTK_EQUALS(evolution_method, "GRHydro")){
  if (CCTK_IsThornActive("PUGH" ))
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_InitialAtmosphereReset),
                           "GRHydro_InitialAtmosphereReset",
                           "GRHydro",
                           "GRHydro",
                           "Use mask to enforce atmosphere at initial time",
                           "CCTK_POSTINITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           2, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "MoL_PostStepModify",
                           "MoL_PostStep",
                           "GRHydro_Rho_Minima_Setup_Final_PUGH");
  }
  }
  else if (CCTK_IsThornActive("Carpet"))
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_InitialAtmosphereReset),
                           "GRHydro_InitialAtmosphereReset",
                           "GRHydro",
                           "GRHydro",
                           "Use mask to enforce atmosphere at initial time",
                           "CCTK_POSTPOSTINITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "Con2Prim",
                           "GRHydro_Rho_Minima_Setup_Final");
  }
  }
}
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("ADMConstraintsGroup",
"ADMConstraintsGroup",
                        "GRHydro",
                        "GRHydro",
                        "Evaluate ADM constraints, and perform symmetry boundary conditions",
                        "CCTK_POSTPOSTINITIAL",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        0, /* Number of AFTER    routines  */
                        0, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "");
  }
if (CCTK_Equals(recon_method,"eno")) 
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_ENOSetup),
                           "GRHydro_ENOSetup",
                           "GRHydro",
                           "GRHydro",
                           "Coefficients for ENO reconstruction",
                           "CCTK_BASEGRID",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "global",
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_ENOShutdown),
                           "GRHydro_ENOShutdown",
                           "GRHydro",
                           "GRHydro",
                           "Deallocate ENO coefficients",
                           "CCTK_TERMINATE",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "global",
                           "",
                           "Driver_Terminate");
  }
}
if (CCTK_Equals(recon_method,"weno") || CCTK_Equals(recon_method,"weno-z"))
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_WENOSetup),
                           "GRHydro_WENOSetup",
                           "GRHydro",
                           "GRHydro",
                           "Coefficients for WENO reconstruction",
                           "CCTK_BASEGRID",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "global",
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_WENOShutdown),
                           "GRHydro_WENOShutdown",
                           "GRHydro",
                           "GRHydro",
                           "Deallocate WENO coefficients",
                           "CCTK_TERMINATE",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "global",
                           "",
                           "Driver_Terminate");
  }
}
if (EoS_Change)
{
  if (CCTK_Equals(EoS_Change_type,"Gamma"))
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_EoSChangeGamma),
                           "GRHydro_EoSChangeGamma",
                           "GRHydro",
                           "GRHydro",
                           "Reset the specific internal energy if the EoS changes between ID and evolution",
                           "CCTK_INITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "GRHydro_IVP",
                           "HydroBase_Initial");
  }
  }
  if (CCTK_Equals(EoS_Change_type,"K"))
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_EoSChangeK),
                           "GRHydro_EoSChangeK",
                           "GRHydro",
                           "GRHydro",
                           "Reset the hydro variables if the EoS (K) changes between ID and evolution",
                           "CCTK_INITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "GRHydro_IVP",
                           "HydroBase_Initial");
  }
  }
  if (CCTK_Equals(EoS_Change_type,"GammaKS"))
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_EoSChangeGammaK_Shibata),
                           "GRHydro_EoSChangeGammaK_Shibata",
                           "GRHydro",
                           "GRHydro",
                           "Reset the hydro variables if the EoS Gamma and K change between ID and evolution",
                           "CCTK_INITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           13, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GRHydro::dens",
                           "GRHydro::tau",
                           "GRHydro::scon",
                           "hydrobase::w_lorentz",
                           "hydrobase::rho",
                           "hydrobase::press",
                           "hydrobase::eps",
                           "hydrobase::vel",
                           "GRHydro::lvel",
                           "hydrobase::temperature",
                           "hydrobase::entropy",
                           "hydrobase::Y_e",
                           "GRHydro::Y_e_con",
                           "",
                           "GRHydro_IVP",
                           "HydroBase_Initial");
  }
  }
}
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydro_Register,
                           "GRHydro_Register",
                           "GRHydro",
                           "GRHydro",
                           "Register variables for MoL",
                           "MoL_Register",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_Scalar_Setup),
                           "GRHydro_Scalar_Setup",
                           "GRHydro",
                           "GRHydro",
                           "Set up and check scalars for efficiency",
                           "MoL_PreStep",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_Scalar_Setup),
                           "GRHydro_Scalar_Setup",
                           "GRHydro",
                           "GRHydro",
                           "Set up and check scalars for efficiency",
                           "CCTK_POSTINITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
if (CCTK_EQUALS(evolution_method, "GRHydro")) {
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_atmosphere_mask")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::GRHydro_atmosphere_mask", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_atmosphere_mask"));
  CCTKi_ScheduleGroupStorage("GRHydro::GRHydro_atmosphere_mask",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_atmosphere_mask_real")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::GRHydro_atmosphere_mask_real", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_atmosphere_mask_real"));
  CCTKi_ScheduleGroupStorage("GRHydro::GRHydro_atmosphere_mask_real",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_atmosphere_descriptors")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::GRHydro_atmosphere_descriptors", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_atmosphere_descriptors"));
  CCTKi_ScheduleGroupStorage("GRHydro::GRHydro_atmosphere_descriptors",1);
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_SetupMask),
                           "GRHydro_SetupMask",
                           "GRHydro",
                           "GRHydro",
                           "Initialize the atmosphere mask",
                           "CCTK_INITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_Initial");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydroCopyIntegerMask),
                           "GRHydroCopyIntegerMask",
                           "GRHydro",
                           "GRHydro",
                           "Initialize the real valued atmosphere mask after checkpoint recovery",
                           "CCTK_POST_RECOVER_VARIABLES",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "MoL_PostStep");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_SetupMask),
                           "GRHydro_SetupMask",
                           "GRHydro",
                           "GRHydro",
                           "Initialize the atmosphere mask",
                           "CCTK_POSTREGRID",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           2, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "MoL_PostStep",
                           "MaskOne",
                           "MaskZero");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_SetupMask),
                           "GRHydro_SetupMask",
                           "GRHydro",
                           "GRHydro",
                           "Initialize the atmosphere mask",
                           "CCTK_POSTREGRIDINITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           2, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "MoL_PostStep",
                           "MaskOne",
                           "MaskZero");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_InitialAtmosphereReset),
                           "GRHydro_InitialAtmosphereReset",
                           "GRHydro",
                           "GRHydro",
                           "Use mask to enforce atmosphere at initial time",
                           "CCTK_INITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           2, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_Prim2ConInitial",
                           "HydroBase_Initial",
                           "GRHydro_SqrtSpatialDeterminant");
  }
if (wk_atmosphere)
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_InitAtmosMask),
                           "GRHydro_InitAtmosMask",
                           "GRHydro",
                           "GRHydro",
                           "Set the atmosphere mask",
                           "CCTK_POSTINITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_InitAtmosMask),
                           "GRHydro_InitAtmosMask",
                           "GRHydro",
                           "GRHydro",
                           "Set the atmosphere mask",
                           "CCTK_POSTREGRID",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "MoL_PostStep",
                           "GRHydro_SetupMask");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_InitAtmosMask),
                           "GRHydro_InitAtmosMask",
                           "GRHydro",
                           "GRHydro",
                           "Set the atmosphere mask",
                           "CCTK_POSTREGRIDINITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_PostStep",
                           "GRHydro_SetupMask");
  }
}
if(CCTK_IsImplementationActive("Coordinates")) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydroTransformPrimToLocalBasis,
                           "GRHydroTransformPrimToLocalBasis",
                           "GRHydro",
                           "GRHydro",
                           "Transform primitive vars to local tensor basis.",
                           "CCTK_INITIAL",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           2, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_Prim2ConInitial",
                           "HydroBase_Initial",
                           "ADMBase_PostInitial");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydroTransformADMToLocalBasis,
                           "GRHydroTransformADMToLocalBasis",
                           "GRHydro",
                           "GRHydro",
                           "Transform ADM metric, extr. curv. and shift to local tensor basis.",
                           "CCTK_INITIAL",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "GRHydroTransformPrimToLocalBasis",
                           "HydroBase_Initial");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydroTransformADMToLocalBasis,
                           "GRHydroTransformADMToLocalBasis",
                           "GRHydro",
                           "GRHydro",
                           "Transform metric and shift to local tensor basis.",
                           "ADMBase_SetADMVars",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           1, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "GRHydro::execute_MoL_Step");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydroTransformPrimToGlobalBasis,
                           "GRHydroTransformPrimToGlobalBasis",
                           "GRHydro",
                           "GRHydro",
                           "Transform primitive vars to global tensor basis.",
                           "HydroBase_PostStep",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           1, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_Con2Prim",
                           "GRHydro::execute_MoL_PostStep");
  }
}
  {
    int cctkschedulei_tlevelarray[] = {1,0};
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_scalars")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_scalars", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_scalars"));
    CCTKi_ScheduleGroup("GRHydroRHS",
"GRHydroRHS",
                        "GRHydro",
                        "GRHydro",
                        "Calculate the update terms",
                        "HydroBase_RHS",
                        1,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        0, /* Number of AFTER    routines  */
                        0, /* Number of WHILE    variables */
                        1, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "GRHydro::GRHydro_scalars",
                        "",
                        "GRHydro::execute_MoL_Step");
  }
if (number_of_particles)
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydroParticleInitial),
                           "GRHydroParticleInitial",
                           "GRHydro",
                           "GRHydro",
                           "Initial data for the particle arrays",
                           "CCTK_INITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GLOBAL",
                           "",
                           "HydroBase_Initial");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydroParticleRHS),
                           "GRHydroParticleRHS",
                           "GRHydro",
                           "GRHydro",
                           "Update terms for the particles",
                           "GRHydroRHS",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GLOBAL",
                           "");
  }
}
if(use_cxx_code) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)SourceTerms,
                           "SourceTerms",
                           "GRHydro",
                           "GRHydro",
                           "Source term calculation",
                           "GRHydroRHS",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "FluxTerms");
  }
} else {
  if(CCTK_Equals(Bvec_evolution_method,"GRHydro"))
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(SourceTermsM),
                           "SourceTermsM",
                           "GRHydro",
                           "GRHydro",
                           "Source term calculation - MHD version",
                           "GRHydroRHS",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "FluxTerms");
  }
  } else if(CCTK_Equals(Bvec_evolution_method,"GRHydro_Avec")) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(SourceTermsAM),
                           "SourceTermsAM",
                           "GRHydro",
                           "GRHydro",
                           "Source term calculation - Vector Potential MHD version",
                           "GRHydroRHS",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "FluxTerms");
  }
  } else {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(SourceTerms),
                           "SourceTerms",
                           "GRHydro",
                           "GRHydro",
                           "Source term calculation",
                           "GRHydroRHS",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "FluxTerms");
  }
  }
}
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydroStartLoop),
                           "GRHydroStartLoop",
                           "GRHydro",
                           "GRHydro",
                           "Set the flux_direction variable",
                           "GRHydroRHS",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "level",
                           "",
                           "FluxTerms");
  }
if (CCTK_Equals(method_type, "RSA FV"))
{
  if (evolve_tracer)
  {  
    if(CCTK_Equals(Bvec_evolution_method,"GRHydro"))
    {
  {
    int cctkschedulei_tlevelarray[] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,0};
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_prim_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_prim_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_prim_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_con_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_con_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_con_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_fluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_fluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_fluxes"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_con_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_MHD_con_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_con_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_prim_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_MHD_prim_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_prim_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_psidc_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_MHD_psidc_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_psidc_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_entropy_prim_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_entropy_prim_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_entropy_prim_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_entropy_con_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_entropy_con_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_entropy_con_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Bfluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_Bfluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Bfluxes"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_psifluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_psifluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_psifluxes"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_entropyfluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_entropyfluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_entropyfluxes"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_cons_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_tracer_cons_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_cons_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_prim_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_tracer_prim_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_prim_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_flux")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_tracer_flux", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_flux"));
    CCTKi_ScheduleGroup("FluxTerms",
"FluxTerms",
                        "GRHydro",
                        "GRHydro",
                        "Calculation of intercell fluxes",
                        "GRHydroRHS",
                        14,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        0, /* Number of AFTER    routines  */
                        1, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "GRHydro::GRHydro_prim_bext",
                        "GRHydro::GRHydro_con_bext",
                        "GRHydro::GRHydro_fluxes",
                        "GRHydro::GRHydro_MHD_con_bext",
                        "GRHydro::GRHydro_MHD_prim_bext",
                        "GRHydro::GRHydro_MHD_psidc_bext",
                        "GRHydro::GRHydro_entropy_prim_bext",
                        "GRHydro::GRHydro_entropy_con_bext",
                        "GRHydro::GRHydro_Bfluxes",
                        "GRHydro::GRHydro_psifluxes",
                        "GRHydro::GRHydro_entropyfluxes",
                        "GRHydro::GRHydro_tracer_cons_bext",
                        "GRHydro::GRHydro_tracer_prim_bext",
                        "GRHydro::GRHydro_tracer_flux",
                        "",
                        "GRHydro::flux_direction");
  }
    } else if(CCTK_Equals(Bvec_evolution_method,"GRHydro_Avec") && CCTK_Equals(Avec_gauge,"Algebraic")) {
  {
    int cctkschedulei_tlevelarray[] = {1,1,1,1,1,1,1,1,1,1,0};
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_prim_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_prim_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_prim_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_con_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_con_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_con_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_fluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_fluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_fluxes"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_con_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_MHD_con_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_con_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_prim_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_MHD_prim_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_prim_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Avec_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_Avec_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Avec_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Avecfluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_Avecfluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Avecfluxes"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_cons_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_tracer_cons_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_cons_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_prim_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_tracer_prim_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_prim_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_flux")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_tracer_flux", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_flux"));
    CCTKi_ScheduleGroup("FluxTerms",
"FluxTerms",
                        "GRHydro",
                        "GRHydro",
                        "Calculation of intercell fluxes",
                        "GRHydroRHS",
                        10,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        0, /* Number of AFTER    routines  */
                        1, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "GRHydro::GRHydro_prim_bext",
                        "GRHydro::GRHydro_con_bext",
                        "GRHydro::GRHydro_fluxes",
                        "GRHydro::GRHydro_MHD_con_bext",
                        "GRHydro::GRHydro_MHD_prim_bext",
                        "GRHydro::GRHydro_Avec_bext",
                        "GRHydro::GRHydro_Avecfluxes",
                        "GRHydro::GRHydro_tracer_cons_bext",
                        "GRHydro::GRHydro_tracer_prim_bext",
                        "GRHydro::GRHydro_tracer_flux",
                        "",
                        "GRHydro::flux_direction");
  }
    } else if(CCTK_Equals(Bvec_evolution_method,"GRHydro_Avec") && CCTK_Equals(Avec_gauge,"Lorenz")) {
  {
    int cctkschedulei_tlevelarray[] = {1,1,1,1,1,1,1,1,1,1,1,1,0};
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_prim_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_prim_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_prim_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_con_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_con_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_con_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_fluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_fluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_fluxes"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_con_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_MHD_con_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_con_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_prim_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_MHD_prim_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_prim_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Avec_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_Avec_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Avec_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Aphi_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_Aphi_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Aphi_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Avecfluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_Avecfluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Avecfluxes"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Aphifluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_Aphifluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Aphifluxes"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_cons_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_tracer_cons_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_cons_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_prim_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_tracer_prim_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_prim_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_flux")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_tracer_flux", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_flux"));
    CCTKi_ScheduleGroup("FluxTerms",
"FluxTerms",
                        "GRHydro",
                        "GRHydro",
                        "Calculation of intercell fluxes",
                        "GRHydroRHS",
                        12,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        0, /* Number of AFTER    routines  */
                        1, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "GRHydro::GRHydro_prim_bext",
                        "GRHydro::GRHydro_con_bext",
                        "GRHydro::GRHydro_fluxes",
                        "GRHydro::GRHydro_MHD_con_bext",
                        "GRHydro::GRHydro_MHD_prim_bext",
                        "GRHydro::GRHydro_Avec_bext",
                        "GRHydro::GRHydro_Aphi_bext",
                        "GRHydro::GRHydro_Avecfluxes",
                        "GRHydro::GRHydro_Aphifluxes",
                        "GRHydro::GRHydro_tracer_cons_bext",
                        "GRHydro::GRHydro_tracer_prim_bext",
                        "GRHydro::GRHydro_tracer_flux",
                        "",
                        "GRHydro::flux_direction");
  }
    } else {
  {
    int cctkschedulei_tlevelarray[] = {1,1,1,1,1,1,0};
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_prim_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_prim_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_prim_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_con_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_con_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_con_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_fluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_fluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_fluxes"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_cons_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_tracer_cons_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_cons_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_prim_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_tracer_prim_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_prim_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_flux")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_tracer_flux", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_flux"));
    CCTKi_ScheduleGroup("FluxTerms",
"FluxTerms",
                        "GRHydro",
                        "GRHydro",
                        "Calculation of intercell fluxes",
                        "GRHydroRHS",
                        6,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        0, /* Number of AFTER    routines  */
                        1, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "GRHydro::GRHydro_prim_bext",
                        "GRHydro::GRHydro_con_bext",
                        "GRHydro::GRHydro_fluxes",
                        "GRHydro::GRHydro_tracer_cons_bext",
                        "GRHydro::GRHydro_tracer_prim_bext",
                        "GRHydro::GRHydro_tracer_flux",
                        "",
                        "GRHydro::flux_direction");
  }
    }
  }
  else
  {
    if(CCTK_Equals(Bvec_evolution_method,"GRHydro"))
    {
  {
    int cctkschedulei_tlevelarray[] = {1,1,1,1,1,1,1,1,1,1,1,0};
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_prim_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_prim_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_prim_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_con_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_con_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_con_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_fluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_fluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_fluxes"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_con_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_MHD_con_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_con_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_prim_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_MHD_prim_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_prim_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_psidc_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_MHD_psidc_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_psidc_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_entropy_con_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_entropy_con_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_entropy_con_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_entropy_prim_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_entropy_prim_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_entropy_prim_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Bfluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_Bfluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Bfluxes"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_psifluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_psifluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_psifluxes"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_entropyfluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_entropyfluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_entropyfluxes"));
    CCTKi_ScheduleGroup("FluxTerms",
"FluxTerms",
                        "GRHydro",
                        "GRHydro",
                        "Calculation of intercell fluxes",
                        "GRHydroRHS",
                        11,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        0, /* Number of AFTER    routines  */
                        1, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "GRHydro::GRHydro_prim_bext",
                        "GRHydro::GRHydro_con_bext",
                        "GRHydro::GRHydro_fluxes",
                        "GRHydro::GRHydro_MHD_con_bext",
                        "GRHydro::GRHydro_MHD_prim_bext",
                        "GRHydro::GRHydro_MHD_psidc_bext",
                        "GRHydro::GRHydro_entropy_con_bext",
                        "GRHydro::GRHydro_entropy_prim_bext",
                        "GRHydro::GRHydro_Bfluxes",
                        "GRHydro::GRHydro_psifluxes",
                        "GRHydro::GRHydro_entropyfluxes",
                        "",
                        "GRHydro::flux_direction");
  }
    } else if(CCTK_Equals(Bvec_evolution_method,"GRHydro_Avec"))  {
  {
    int cctkschedulei_tlevelarray[] = {1,1,1,1,1,1,1,1,1,0};
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_prim_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_prim_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_prim_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_con_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_con_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_con_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_fluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_fluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_fluxes"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_con_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_MHD_con_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_con_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_prim_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_MHD_prim_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_MHD_prim_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Avec_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_Avec_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Avec_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Aphi_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_Aphi_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Aphi_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Avecfluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_Avecfluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Avecfluxes"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Aphifluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_Aphifluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_Aphifluxes"));
    CCTKi_ScheduleGroup("FluxTerms",
"FluxTerms",
                        "GRHydro",
                        "GRHydro",
                        "Calculation of intercell fluxes",
                        "GRHydroRHS",
                        9,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        0, /* Number of AFTER    routines  */
                        1, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "GRHydro::GRHydro_prim_bext",
                        "GRHydro::GRHydro_con_bext",
                        "GRHydro::GRHydro_fluxes",
                        "GRHydro::GRHydro_MHD_con_bext",
                        "GRHydro::GRHydro_MHD_prim_bext",
                        "GRHydro::GRHydro_Avec_bext",
                        "GRHydro::GRHydro_Aphi_bext",
                        "GRHydro::GRHydro_Avecfluxes",
                        "GRHydro::GRHydro_Aphifluxes",
                        "",
                        "GRHydro::flux_direction");
  }
    } else {
  {
    int cctkschedulei_tlevelarray[] = {1,1,1,0};
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_prim_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_prim_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_prim_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_con_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_con_bext", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_con_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_fluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_fluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_fluxes"));
    CCTKi_ScheduleGroup("FluxTerms",
"FluxTerms",
                        "GRHydro",
                        "GRHydro",
                        "Calculation of intercell fluxes",
                        "GRHydroRHS",
                        3,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        0, /* Number of AFTER    routines  */
                        1, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "GRHydro::GRHydro_prim_bext",
                        "GRHydro::GRHydro_con_bext",
                        "GRHydro::GRHydro_fluxes",
                        "",
                        "GRHydro::flux_direction");
  }
    }
  }
  if (CCTK_Equals(GRHydro_eos_type,"General")) {
    if (use_cxx_code && ! CCTK_EQUALS(recon_method,"eno")) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)Reconstruction_cxx,
                           "Reconstruct",
                           "GRHydro",
                           "GRHydro",
                           "Reconstruct the functions at the cell boundaries",
                           "FluxTerms",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
    } else {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(Reconstruction),
                           "Reconstruct",
                           "GRHydro",
                           "GRHydro",
                           "Reconstruct the functions at the cell boundaries",
                           "FluxTerms",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
    }
  }
  else if (CCTK_Equals(GRHydro_eos_type,"Polytype")) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(ReconstructionPolytype),
                           "Reconstruct",
                           "GRHydro",
                           "GRHydro",
                           "Reconstruct the functions at the cell boundaries",
                           "FluxTerms",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  }
  if (set_trivial_rp_grid_function)
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)Set_Trivial_Riemann_Problem_Grid_Function,
                           "Set_Trivial_Riemann_Problem_Grid_Function",
                           "GRHydro",
                           "GRHydro",
                           "Set the gridfunction for the trp (for debugging only)",
                           "FluxTerms",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           1, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GRHydro::GRHydro_trivial_rp_gf_group",
                           "",
                           "Reconstruct");
  }
  }
  if (CCTK_Equals(GRHydro_eos_type,"General")) {
    if(CCTK_Equals(Bvec_evolution_method,"GRHydro"))
    {
  {
    int cctkschedulei_tlevelarray[] = {1,0};
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::EOS_temps")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::EOS_temps", CCTK_DeclaredTimeLevels("GRHydro::EOS_temps"));
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(RiemannSolveM),
                           "Riemann",
                           "GRHydro",
                           "GRHydro",
                           "Solve the local Riemann problems - MHD version",
                           "FluxTerms",
                           "Fortran",
                           1,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GRHydro::EOS_temps",
                           "",
                           "Reconstruct");
  }
    } else if(CCTK_Equals(Bvec_evolution_method,"GRHydro_Avec")) {
  {
    int cctkschedulei_tlevelarray[] = {1,0};
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::EOS_temps")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::EOS_temps", CCTK_DeclaredTimeLevels("GRHydro::EOS_temps"));
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(RiemannSolveAM),
                           "Riemann",
                           "GRHydro",
                           "GRHydro",
                           "Solve the local Riemann problems - Vector Potential MHD version",
                           "FluxTerms",
                           "Fortran",
                           1,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GRHydro::EOS_temps",
                           "",
                           "Reconstruct");
  }
    } else {
  {
    int cctkschedulei_tlevelarray[] = {1,0};
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::EOS_temps")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::EOS_temps", CCTK_DeclaredTimeLevels("GRHydro::EOS_temps"));
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(RiemannSolve),
                           "Riemann",
                           "GRHydro",
                           "GRHydro",
                           "Solve the local Riemann problems",
                           "FluxTerms",
                           "Fortran",
                           1,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GRHydro::EOS_temps",
                           "",
                           "Reconstruct");
  }
    }    
  }
  else if (CCTK_Equals(GRHydro_eos_type,"Polytype")) {
  {
    int cctkschedulei_tlevelarray[] = {1,0};
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::EOS_temps")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::EOS_temps", CCTK_DeclaredTimeLevels("GRHydro::EOS_temps"));
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(RiemannSolvePolytype),
                           "Riemann",
                           "GRHydro",
                           "GRHydro",
                           "Solve the local Riemann problems",
                           "FluxTerms",
                           "Fortran",
                           1,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GRHydro::EOS_temps",
                           "",
                           "Reconstruct");
  }
  }
}
else if (CCTK_Equals(method_type, "Flux split FD"))
{
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::fs_alpha")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::fs_alpha", CCTK_DeclaredTimeLevels("GRHydro::fs_alpha"));
  CCTKi_ScheduleGroupStorage("GRHydro::fs_alpha",1);
  if (evolve_tracer)
  {
  {
    int cctkschedulei_tlevelarray[] = {1,1,0};
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_fluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_fluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_fluxes"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_flux")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_tracer_flux", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_flux"));
    CCTKi_ScheduleGroup("FluxTerms",
"FluxTerms",
                        "GRHydro",
                        "GRHydro",
                        "Calculation of intercell fluxes",
                        "GRHydroRHS",
                        2,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        0, /* Number of AFTER    routines  */
                        1, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "GRHydro::GRHydro_fluxes",
                        "GRHydro::GRHydro_tracer_flux",
                        "",
                        "GRHydro::flux_direction");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_FSAlpha),
                           "GRHydro_FSAlpha",
                           "GRHydro",
                           "GRHydro",
                           "Compute the maximum characteristic speeds",
                           "FluxTerms",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "GRHydro_SplitFlux");
  }
  {
    int cctkschedulei_tlevelarray[] = {1,1,0};
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::flux_splitting")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::flux_splitting", CCTK_DeclaredTimeLevels("GRHydro::flux_splitting"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_flux_splitting")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_tracer_flux_splitting", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_flux_splitting"));
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_SplitFlux),
                           "Reconstruct",
                           "GRHydro",
                           "GRHydro",
                           "Compute the fluxes using WENO5 FD + Lax-Friedrichs splitting",
                           "FluxTerms",
                           "Fortran",
                           2,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           1, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GRHydro::flux_splitting",
                           "GRHydro::GRHydro_tracer_flux_splitting",
                           "GRHydro::GRHydro_fluxes",
                           "");
  }
  }
  else
  {
  {
    int cctkschedulei_tlevelarray[] = {1,0};
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_fluxes")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::GRHydro_fluxes", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_fluxes"));
    CCTKi_ScheduleGroup("FluxTerms",
"FluxTerms",
                        "GRHydro",
                        "GRHydro",
                        "Calculation of intercell fluxes",
                        "GRHydroRHS",
                        1,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        0, /* Number of AFTER    routines  */
                        1, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "GRHydro::GRHydro_fluxes",
                        "",
                        "GRHydro::flux_direction");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_FSAlpha),
                           "GRHydro_FSAlpha",
                           "GRHydro",
                           "GRHydro",
                           "Compute the maximum characteristic speeds",
                           "FluxTerms",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "GRHydro_SplitFlux");
  }
  {
    int cctkschedulei_tlevelarray[] = {1,0};
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHydro::flux_splitting")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHydro::flux_splitting", CCTK_DeclaredTimeLevels("GRHydro::flux_splitting"));
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_SplitFlux),
                           "Reconstruct",
                           "GRHydro",
                           "GRHydro",
                           "Compute the fluxes using WENO5 FD + Lax-Friedrichs splitting",
                           "FluxTerms",
                           "Fortran",
                           1,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           1, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GRHydro::flux_splitting",
                           "GRHydro::GRHydro_fluxes",
                           "");
  }
  }
}
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(UpdateCalculation),
                           "UpdateCalcul",
                           "GRHydro",
                           "GRHydro",
                           "Calculate the update term from the fluxes",
                           "FluxTerms",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "Riemann");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydroAdvanceLoop),
                           "GRHydroAdvanceLoop",
                           "GRHydro",
                           "GRHydro",
                           "Decrement the flux_direction variable",
                           "FluxTerms",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "level",
                           "",
                           "UpdateCalcul");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydroUpdateAtmosphereMask),
                           "GRHydroUpdateAtmosphereMask",
                           "GRHydro",
                           "GRHydro",
                           "Alter the update terms if inside the atmosphere region",
                           "GRHydroRHS",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "FluxTerms");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("GRHydro_PostStep",
"GRHydro_PostStep",
                        "GRHydro",
                        "GRHydro",
                        "Post step tasks for GRHydro",
                        "HydroBase_PostStep",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        0, /* Number of AFTER    routines  */
                        0, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_RefinementLevel),
                           "GRHydro_RefinementLevel",
                           "GRHydro",
                           "GRHydro",
                           "Calculate current refinement level",
                           "MoL_PostStep",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_PostStep");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_RefinementLevel),
                           "GRHydro_RefinementLevel",
                           "GRHydro",
                           "GRHydro",
                           "Calculate current refinement level",
                           "FluxTerms",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "Reconstruct");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_SqrtSpatialDeterminant),
                           "GRHydro_SqrtSpatialDeterminant",
                           "GRHydro",
                           "GRHydro",
                           "Calculate sdetg",
                           "HydroBase_Con2Prim",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           1, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "Con2Prim",
                           "GRHydro::execute_MoL_Step");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_SqrtSpatialDeterminant),
                           "GRHydro_SqrtSpatialDeterminant",
                           "GRHydro",
                           "GRHydro",
                           "Calculate sdetg",
                           "CCTK_POST_RECOVER_VARIABLES",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_RefinementLevel),
                           "GRHydro_RefinementLevel",
                           "GRHydro",
                           "GRHydro",
                           "Calculate current refinement level (for the check of the C2P mask)",
                           "CCTK_POSTSTEP",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_RefinementLevel),
                           "GRHydro_RefinementLevel",
                           "GRHydro",
                           "GRHydro",
                           "Calculate current refinement level",
                           "CCTK_POSTREGRIDINITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_RefinementLevel),
                           "GRHydro_RefinementLevel",
                           "GRHydro",
                           "GRHydro",
                           "Calculate current refinement level",
                           "CCTK_INITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_Initial");
  }
if (CCTK_Equals(GRHydro_eos_type,"General")) 
{
  if(CCTK_Equals(Bvec_evolution_method,"GRHydro"))
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(Conservative2PrimitiveM),
                           "Con2Prim",
                           "GRHydro",
                           "GRHydro",
                           "Convert back to primitive variables (general) - MHD version",
                           "HydroBase_Con2Prim",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           1, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "GRHydro::execute_MoL_PostStep");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(Primitive2ConservativeCellsM),
                           "Primitive2ConservativeCellsM",
                           "GRHydro",
                           "GRHydro",
                           "Convert initial data given in primive variables to conserved variables - MHD version",
                           "HydroBase_Prim2ConInitial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  } else if(CCTK_Equals(Bvec_evolution_method,"GRHydro_Avec")) 
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_BvecfromAvec),
                           "GRHydro_BvecfromAvec",
                           "GRHydro",
                           "GRHydro",
                           "Populate Bvec from Avec",
                           "HydroBase_Con2Prim",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("HydroBase_Boundaries",
"HydroBase_Boundaries",
                        "GRHydro",
                        "GRHydro",
                        "Call boundary conditions after magnetic field initial data setup",
                        "HydroBase_Con2Prim",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        1, /* Number of AFTER    routines  */
                        0, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "",
                        "GRHydro_BvecfromAvec");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(Conservative2PrimitiveAM),
                           "Con2Prim",
                           "GRHydro",
                           "GRHydro",
                           "Convert back to primitive variables (general) - MHD with Avec version",
                           "HydroBase_Con2Prim",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           1, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_Boundaries",
                           "GRHydro::execute_MoL_PostStep");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(Primitive2ConservativeCellsAM),
                           "Primitive2ConservativeCellsAM",
                           "GRHydro",
                           "GRHydro",
                           "Convert initial data given in primive variables to conserved variables - MHD with Avec version",
                           "HydroBase_Prim2ConInitial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  } else {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(Conservative2Primitive),
                           "Con2Prim",
                           "GRHydro",
                           "GRHydro",
                           "Convert back to primitive variables (general)",
                           "HydroBase_Con2Prim",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           1, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "GRHydro::execute_MoL_PostStep");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(Primitive2ConservativeCells),
                           "Primitive2ConservativeCells",
                           "GRHydro",
                           "GRHydro",
                           "Convert initial data given in primive variables to conserved variables",
                           "HydroBase_Prim2ConInitial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  }
}
else if (CCTK_Equals(GRHydro_eos_type,"Polytype")) 
{
  if(CCTK_Equals(Bvec_evolution_method,"GRHydro"))
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(Conservative2PrimitivePolytypeM),
                           "Con2Prim",
                           "GRHydro",
                           "GRHydro",
                           "Convert back to primitive variables (polytype) - MHD version",
                           "HydroBase_Con2Prim",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           1, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "GRHydro::execute_MoL_PostStep");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(Primitive2ConservativePolyCellsM),
                           "Primitive2ConservativePolyCellsM",
                           "GRHydro",
                           "GRHydro",
                           "Convert initial data given in primive variables to conserved variables - MHD version",
                           "HydroBase_Prim2ConInitial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  } else if(CCTK_Equals(Bvec_evolution_method,"GRHydro_Avec")) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(Conservative2PrimitivePolytypeAM),
                           "Con2Prim",
                           "GRHydro",
                           "GRHydro",
                           "Convert back to primitive variables (polytype) - MHD with Avec version",
                           "HydroBase_Con2Prim",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           1, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "GRHydro::execute_MoL_PostStep");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(Primitive2ConservativePolyCellsAM),
                           "Primitive2ConservativePolyCellsAM",
                           "GRHydro",
                           "GRHydro",
                           "Convert initial data given in primive variables to conserved variables - MHD with Avec version",
                           "HydroBase_Prim2ConInitial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  } else {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(Conservative2PrimitivePolytype),
                           "Con2Prim",
                           "GRHydro",
                           "GRHydro",
                           "Convert back to primitive variables (polytype)",
                           "HydroBase_Con2Prim",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           1, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "GRHydro::execute_MoL_PostStep");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(Primitive2ConservativePolyCells),
                           "Primitive2ConservativePolyCells",
                           "GRHydro",
                           "GRHydro",
                           "Convert initial data given in primive variables to conserved variables",
                           "HydroBase_Prim2ConInitial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  }
}
if (evolve_tracer)
{
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracers")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::GRHydro_tracers", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracers"));
  CCTKi_ScheduleGroupStorage("GRHydro::GRHydro_tracers",timelevels);
  if(!(timelevels >= 0 && timelevels  <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_cons_tracers")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)timelevels, "GRHydro::GRHydro_cons_tracers", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_cons_tracers"));
  CCTKi_ScheduleGroupStorage("GRHydro::GRHydro_cons_tracers",timelevels);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_rhs")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::GRHydro_tracer_rhs", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_tracer_rhs"));
  CCTKi_ScheduleGroupStorage("GRHydro::GRHydro_tracer_rhs",1);
}
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("Do_GRHydro_Boundaries",
"Do_GRHydro_Boundaries",
                        "GRHydro",
                        "GRHydro",
                        "GRHydro Boundary conditions group",
                        "HydroBase_Boundaries",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        0, /* Number of AFTER    routines  */
                        0, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("GRHydro_AtmosphereMaskBoundaries",
"GRHydro_AtmosphereMaskBoundaries",
                        "GRHydro",
                        "GRHydro",
                        "Apply boundary conditions to primitives",
                        "HydroBase_PostStep",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        2, /* Number of BEFORE   routines  */
                        0, /* Number of AFTER    routines  */
                        0, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "",
                        "HydroBase_Boundaries",
                        "GRHydro_PrimitiveInitialGuessesBoundaries");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_SelectAtmosphereMaskBoundaries),
                           "GRHydro_SelectAtmosphereMaskBoundaries",
                           "GRHydro",
                           "GRHydro",
                           "Select atmosphere mask for boundary conditions",
                           "GRHydro_AtmosphereMaskBoundaries",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           1, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GRHydro::GRHydro_atmosphere_mask_real",
                           "LEVEL",
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("ApplyBCs",
"GRHydro_ApplyAtmosphereMaskBCs",
                        "GRHydro",
                        "GRHydro",
                        "Apply boundary conditions to real-valued atmosphere mask",
                        "GRHydro_AtmosphereMaskBoundaries",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        1, /* Number of AFTER    routines  */
                        0, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "",
                        "GRHydro_SelectAtmosphereMaskBoundaries");
  }
if (!sync_conserved_only)
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_Boundaries),
                           "GRHydro_Bound",
                           "GRHydro",
                           "GRHydro",
                           "Select GRHydro boundary conditions",
                           "HydroBase_Select_Boundaries",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           20, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           1, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GRHydro::dens",
                           "GRHydro::tau",
                           "GRHydro::scon",
                           "HydroBase::w_lorentz",
                           "HydroBase::rho",
                           "HydroBase::press",
                           "HydroBase::eps",
                           "HydroBase::vel",
                           "GRHydro::Bcons",
                           "GRHydro::entropycons",
                           "HydroBase::Bvec",
                           "GRHydro::psidc",
                           "GRHydro::GRHydro_cons_tracers",
                           "GRHydro::GRHydro_tracers",
                           "hydrobase::temperature",
                           "hydrobase::entropy",
                           "hydrobase::Y_e",
                           "GRHydro::Y_e_con",
                           "GRHydro::lvel",
                           "GRHydro::lBvec",
                           "LEVEL",
                           "",
                           "GRHydro::execute_MoL_PostStep");
  }
}
else
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_Boundaries),
                           "GRHydro_Bound",
                           "GRHydro",
                           "GRHydro",
                           "Select GRHydro boundary conditions",
                           "HydroBase_Select_Boundaries",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           8, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           1, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GRHydro::dens",
                           "GRHydro::tau",
                           "GRHydro::scon",
                           "GRHydro::Bcons",
                           "GRHydro::entropycons",
                           "GRHydro::psidc",
                           "GRHydro::GRHydro_cons_tracers",
                           "GRHydro::Y_e_con",
                           "LEVEL",
                           "",
                           "GRHydro::execute_MoL_PostStep");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("GRHydro_PrimitiveBoundaries",
"GRHydro_PrimitiveBoundaries",
                        "GRHydro",
                        "GRHydro",
                        "Apply boundary conditions to all primitives",
                        "CCTK_POSTREGRID",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        1, /* Number of BEFORE   routines  */
                        0, /* Number of AFTER    routines  */
                        0, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "",
                        "MoL_PostStep");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("GRHydro_PrimitiveBoundaries",
"GRHydro_PrimitiveBoundaries",
                        "GRHydro",
                        "GRHydro",
                        "Apply boundary conditions to all primitives",
                        "CCTK_POSTREGRIDINITIAL",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        1, /* Number of BEFORE   routines  */
                        0, /* Number of AFTER    routines  */
                        0, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "",
                        "MoL_PostStep");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("GRHydro_PrimitiveInitialGuessesBoundaries",
"GRHydro_PrimitiveInitialGuessesBoundaries",
                        "GRHydro",
                        "GRHydro",
                        "Apply boundary conditions to those primitives used as initial guesses",
                        "HydroBase_PostStep",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        1, /* Number of BEFORE   routines  */
                        0, /* Number of AFTER    routines  */
                        0, /* Number of WHILE    variables */
                        1, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "",
                        "HydroBase_Boundaries",
                        "GRHydro::InLastMoLPostStep");
  }
    if(CCTK_IsImplementationActive("Coordinates")) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_SelectPrimitiveInitialGuessesBoundaries),
                           "GRHydro_SelectPrimitiveInitialGuessesBoundaries",
                           "GRHydro",
                           "GRHydro",
                           "Select initial guess primitive variables for boudary conditions",
                           "GRHydro_PrimitiveInitialGuessesBoundaries",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           6, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "HydroBase::press",
                           "HydroBase::rho",
                           "HydroBase::eps",
                           "hydrobase::temperature",
                           "GRHydro::lvel",
                           "GRHydro::lBvec",
                           "LEVEL",
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_SelectPrimitiveBoundaries),
                           "GRHydro_SelectPrimitiveBoundaries",
                           "GRHydro",
                           "GRHydro",
                           "Select primitive variables for boundary conditions",
                           "GRHydro_PrimitiveBoundaries",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           9, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "HydroBase::press",
                           "hydrobase::entropy",
                           "hydrobase::Y_e",
                           "GRHydro::GRHydro_tracers",
                           "HydroBase::rho",
                           "HydroBase::eps",
                           "hydrobase::temperature",
                           "GRHydro::lvel",
                           "GRHydro::lBvec",
                           "LEVEL",
                           "");
  }
    }
    else
    {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_SelectPrimitiveInitialGuessesBoundaries),
                           "GRHydro_SelectPrimitiveInitialGuessesBoundaries",
                           "GRHydro",
                           "GRHydro",
                           "Select initial guess primitive variables for boudary conditions",
                           "GRHydro_PrimitiveInitialGuessesBoundaries",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           6, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "HydroBase::press",
                           "HydroBase::rho",
                           "HydroBase::eps",
                           "HydroBase::vel",
                           "HydroBase::Bvec",
                           "hydrobase::temperature",
                           "LEVEL",
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_SelectPrimitiveBoundaries),
                           "GRHydro_SelectPrimitiveBoundaries",
                           "GRHydro",
                           "GRHydro",
                           "Select primitive variables for boundary conditions",
                           "GRHydro_PrimitiveBoundaries",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           9, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "HydroBase::press",
                           "hydrobase::entropy",
                           "hydrobase::Y_e",
                           "GRHydro::GRHydro_tracers",
                           "HydroBase::rho",
                           "HydroBase::eps",
                           "HydroBase::vel",
                           "HydroBase::Bvec",
                           "hydrobase::temperature",
                           "LEVEL",
                           "");
  }
    }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("ApplyBCs",
"GRHydro_ApplyPrimitiveInitialGuessBCs",
                        "GRHydro",
                        "GRHydro",
                        "Apply boundary conditions to initial guess primitive variables",
                        "GRHydro_PrimitiveInitialGuessesBoundaries",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        1, /* Number of AFTER    routines  */
                        0, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "",
                        "GRHydro_SelectPrimitiveInitialGuessesBoundaries");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("ApplyBCs",
"GRHydro_ApplyPrimitiveBCs",
                        "GRHydro",
                        "GRHydro",
                        "Apply boundary conditions to all primitive variables",
                        "GRHydro_PrimitiveBoundaries",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        1, /* Number of AFTER    routines  */
                        0, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "",
                        "GRHydro_SelectPrimitiveBoundaries");
  }
}  
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydro_SetLastMoLPostStep,
                           "GRHydro_SetLastMoLPostStep",
                           "GRHydro",
                           "GRHydro",
                           "Set grid scalar InLastMoLPostStep if this is the last MoL PostStep call",
                           "MoL_PostStep",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "level",
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydro_ClearLastMoLPostStep,
                           "GRHydro_ClearLastMoLPostStep",
                           "GRHydro",
                           "GRHydro",
                           "Reset InLastMoLPostStep to zero",
                           "MoL_Step",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "level",
                           "",
                           "MoL_PostStep");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydro_ClearLastMoLPostStep,
                           "GRHydro_ClearLastMoLPostStep",
                           "GRHydro",
                           "GRHydro",
                           "Initialize InLastMoLPostStep to zero",
                           "CCTK_WRAGH",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "global-early",
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydroPostSyncAtmosphereMask),
                           "GRHydroPostSyncAtmosphereMask",
                           "GRHydro",
                           "GRHydro",
                           "Set integer atmosphere mask from synchronized real atmosphere mask",
                           "HydroBase_PostStep",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "GRHydro_AtmosphereMaskBoundaries");
  }
if (CCTK_Equals(Bvec_evolution_method,"GRHydro"))
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_AtmosphereResetM),
                           "GRHydro_AtmosphereResetM",
                           "GRHydro",
                           "GRHydro",
                           "Reset the atmosphere - MHD version",
                           "HydroBase_PostStep",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           2, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           1, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_Boundaries",
                           "GRHydro_PrimitiveInitialGuessesBoundaries",
                           "GRHydroPostSyncAtmosphereMask",
                           "GRHydro::InLastMoLPostStep");
  }
} else if (CCTK_Equals(Bvec_evolution_method,"GRHydro_Avec")) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_AtmosphereResetAM),
                           "GRHydro_AtmosphereResetAM",
                           "GRHydro",
                           "GRHydro",
                           "Reset the atmosphere - MHD with Avec version",
                           "HydroBase_PostStep",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           2, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           1, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_Boundaries",
                           "GRHydro_PrimitiveInitialGuessesBoundaries",
                           "GRHydroPostSyncAtmosphereMask",
                           "GRHydro::InLastMoLPostStep");
  }
} else {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_AtmosphereReset),
                           "GRHydro_AtmosphereReset",
                           "GRHydro",
                           "GRHydro",
                           "Reset the atmosphere",
                           "HydroBase_PostStep",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           2, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           1, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_Boundaries",
                           "GRHydro_PrimitiveInitialGuessesBoundaries",
                           "GRHydroPostSyncAtmosphereMask",
                           "GRHydro::InLastMoLPostStep");
  }
}
if (set_trivial_rp_grid_function)
{
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_trivial_rp_gf_group")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::GRHydro_trivial_rp_gf_group", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_trivial_rp_gf_group"));
  CCTKi_ScheduleGroupStorage("GRHydro::GRHydro_trivial_rp_gf_group",1);
}
if (ppm_mppm_debug_eigenvalues)
{
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_mppm_eigenvalues")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::GRHydro_mppm_eigenvalues", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_mppm_eigenvalues"));
  CCTKi_ScheduleGroupStorage("GRHydro::GRHydro_mppm_eigenvalues",1);
}
if (Check_Rho_Minimum)
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_Check_Rho_Minimum),
                           "GRHydro_Check_Rho_Minimum",
                           "GRHydro",
                           "GRHydro",
                           "Check whether somewhere rho(i,j,k) < GRHydro_rho_min and produce a WARNING",
                           "CCTK_ANALYSIS",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           3,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "HydroBase::rho",
                           "HydroBase::press",
                           "HydroBase::eps",
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_RefinementLevel),
                           "GRHydro_RefinementLevel",
                           "GRHydro",
                           "GRHydro",
                           "Calculate current refinement level",
                           "CCTK_ANALYSIS",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           3,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "HydroBase::rho",
                           "HydroBase::press",
                           "HydroBase::eps",
                           "",
                           "GRHydro_Check_Rho_Minimum");
  }
}
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro::GRHydro_C2P_failed")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro::GRHydro_C2P_failed", CCTK_DeclaredTimeLevels("GRHydro::GRHydro_C2P_failed"));
  CCTKi_ScheduleGroupStorage("GRHydro::GRHydro_C2P_failed",1);
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(reset_GRHydro_C2P_failed),
                           "reset_GRHydro_C2P_failed",
                           "GRHydro",
                           "GRHydro",
                           "Initialise the mask function that contains the points where C2P has failed (at BASEGRID)",
                           "CCTK_BASEGRID",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(reset_GRHydro_C2P_failed),
                           "reset_GRHydro_C2P_failed",
                           "GRHydro",
                           "GRHydro",
                           "Reset the mask function that contains the points where C2P has failed (at PRESTEP)",
                           "CCTK_PRESTEP",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(sync_GRHydro_C2P_failed),
                           "sync_GRHydro_C2P_failed",
                           "GRHydro",
                           "GRHydro",
                           "Syncronise the mask function that contains the points where C2P has failed",
                           "CCTK_EVOL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           1, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GRHydro::GRHydro_C2P_failed",
                           "",
                           "MoL_Evolution");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(check_GRHydro_C2P_failed),
                           "check_GRHydro_C2P_failed",
                           "GRHydro",
                           "GRHydro",
                           "Check the mask function that contains the points where C2P has failed and report an error in case a failure is found",
                           "CCTK_POSTSTEP",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "GRHydro_RefinementLevel");
  }
} 
if (CCTK_Equals(Bvec_evolution_method,"GRHydro") || CCTK_Equals(Bvec_evolution_method,"GRHydro_Avec"))
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_TmunuM),
                           "GRHydro_TmunuM",
                           "GRHydro",
                           "GRHydro",
                           "Compute the energy-momentum tensor - MHD version",
                           "AddToTmunu",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  if (calculate_bcom){
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_CalcBcom),
                           "GRHydro_CalcBcom",
                           "GRHydro",
                           "GRHydro",
                           "Compute comoving magnetic field, pressure, etc...",
                           "HydroBase_PostStep",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "GRHydroTransformPrimToGlobalBasis");
  }
  }
} else {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_Tmunu),
                           "GRHydro_Tmunu",
                           "GRHydro",
                           "GRHydro",
                           "Compute the energy-momentum tensor",
                           "AddToTmunu",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
}
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("SetTmunu",
"SetTmunu",
                        "GRHydro",
                        "GRHydro",
                        "Calculate the stress-energy tensor",
                        "CCTK_POSTPOSTINITIAL",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        1, /* Number of BEFORE   routines  */
                        1, /* Number of AFTER    routines  */
                        0, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "",
                        "ADMConstraintsGroup",
                        "Con2Prim");
  }
if(track_divB)
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("GRHydroAnalysis",
"GRHydroAnalysis",
                        "GRHydro",
                        "GRHydro",
                        "Calculate analysis quantities",
                        "MoL_PseudoEvolution",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        0, /* Number of AFTER    routines  */
                        0, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_CalcDivB),
                           "GRHydro_CalcDivB",
                           "GRHydro",
                           "GRHydro",
                           "Calculate divB",
                           "GRHydroAnalysis",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "GRHydro_Analysis_Init");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("ApplyBCs",
"GRHydro_ApplyDivBBCs",
                        "GRHydro",
                        "GRHydro",
                        "Apply boundary conditions to divB",
                        "GRHydroAnalysis",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        0, /* Number of BEFORE   routines  */
                        1, /* Number of AFTER    routines  */
                        0, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "",
                        "GRHydro_CalcDivB");
  }
}
if (constrain_to_1D) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(ConstrainSconTo1D),
                           "ConstrainSconTo1D",
                           "GRHydro",
                           "GRHydro",
                           "Constrain conserved fluid velocity to radial direction",
                           "MoL_PostStepModify",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LOCAL",
                           "");
  }
}
if (apply_H_viscosity) {
  if (use_cxx_code) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)H_viscosity_calc_cs_cc,
                           "H_viscosity_calc_cs_cc",
                           "GRHydro",
                           "GRHydro",
                           "Compute local temporaries for H viscosity - C++ version",
                           "GRHydroRHS",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LOCAL",
                           "",
                           "FluxTerms");
  }
  } else {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(H_viscosity),
                           "H_viscosity",
                           "GRHydro",
                           "GRHydro",
                           "Compute local temporaries for H viscosity",
                           "GRHydroRHS",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           1, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LOCAL",
                           "",
                           "FluxTerms");
  }
  }
}
}

/*@@
  @routine    CCTKi_BindingsParameterRecovery_GRHydro
  @author     Automatically generated by CreateScheduleBindings.pl
  @desc
              Creates the parameter recovery bindings for thorn GRHydro
  @enddesc
@@*/

int CCTKi_BindingsParameterRecovery_GRHydro(void);
int CCTKi_BindingsParameterRecovery_GRHydro(void)
{
  /* this thorn doesn't define any parameter recovery routines */
  return (0);
}

