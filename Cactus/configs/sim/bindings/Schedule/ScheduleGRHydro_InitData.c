/*@@
   @file       ScheduleGRHydro_InitData.c
   @author     Automatically generated by CreateScheduleBindings.pl
   @desc
               Creates the schedule and parameter recovery bindings 
               for thorn GRHydro_InitData
   @enddesc
@@*/


#include "GRHydro_InitData/cctk.h"
#include "GRHydro_InitData/CParameters.h"
#include "cctki_ScheduleBindings.h"
#include "GRHydro_InitData/cctk_ScheduleFunctions.h"

/* Prototypes for Fortran schedule bindings functions to be registered */
/* Note that this is a cheat, we just need a function pointer. */
extern int CCTK_FNAME(GRHydro_MonopoleM)(void);
extern int CCTK_FNAME(GRHydro_RotorM)(void);
extern int CCTK_FNAME(GRHydro_AdvectedLoopM)(void);
extern int CCTK_FNAME(GRHydro_AlfvenWaveM)(void);
extern int CCTK_FNAME(GRHydro_shocktube_hot)(void);
extern int CCTK_FNAME(GRHydro_shocktubeM)(void);
extern int CCTK_FNAME(GRHydro_Diagshock_BoundaryM)(void);
extern int CCTK_FNAME(GRHydro_Diagshock_BoundaryM)(void);
extern int CCTK_FNAME(GRHydro_Diagshock2D_BoundaryM)(void);
extern int CCTK_FNAME(GRHydro_shocktube)(void);
extern int CCTK_FNAME(GRHydro_CylindricalExplosionM)(void);
extern int CCTK_FNAME(GRHydro_Init_Data_RefinementLevel)(void);
extern int CCTK_FNAME(GRHydro_con2primtest)(void);
extern int CCTK_FNAME(GRHydro_Init_Data_RefinementLevel)(void);
extern int CCTK_FNAME(c2p2cM)(void);
extern int CCTK_FNAME(c2p2c)(void);
extern int CCTK_FNAME(GRHydro_Init_Data_RefinementLevel)(void);
extern int CCTK_FNAME(p2c2pM)(void);
extern int CCTK_FNAME(p2c2p)(void);
extern int CCTK_FNAME(GRHydro_Init_Data_RefinementLevel)(void);
extern int CCTK_FNAME(p2c2pM_polytype)(void);
extern int CCTK_FNAME(GRHydro_reconstruction_test)(void);
extern int CCTK_FNAME(GRHydro_Only_Atmo)(void);
extern int CCTK_FNAME(GRHydro_ReadConformalData)(void);
extern int CCTK_FNAME(GRHydro_SimpleWave)(void);
extern int CCTK_FNAME(GRHydro_SimpleWave_Analysis)(void);
extern int CCTK_FNAME(GRHydro_Bondi_Iso)(void);
extern int CCTK_FNAME(GRHydro_BondiM_Iso)(void);
extern int CCTK_FNAME(GRHydro_PoloidalMagFieldM)(void);

void CCTKi_BindingsSchedule_GRHydro_InitData(void);
void CCTKi_BindingsSchedule_GRHydro_InitData(void)
{
  DECLARE_CCTK_PARAMETERS
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydro_InitData_CheckParameters,
                           "GRHydro_InitData_CheckParameters",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Check parameters",
                           "CCTK_PARAMCHECK",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
if (CCTK_Equals(initial_hydro,"monopole")) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_MonopoleM),
                           "GRHydro_MonopoleM",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Monopole initial data",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
}
if (CCTK_Equals(initial_hydro,"rotor")) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_RotorM),
                           "GRHydro_RotorM",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "MHD rotor initial data",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
}
if (CCTK_Equals(initial_hydro,"advectedloop")) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_AdvectedLoopM),
                           "GRHydro_AdvectedLoopM",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "MHD advected loop initial data",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
}
if (CCTK_Equals(initial_hydro,"alfvenwave")) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_AlfvenWaveM),
                           "GRHydro_AlfvenWaveM",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Circularly polarized Alfven wave initial data",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
}
if (CCTK_Equals(initial_hydro,"shocktube_hot")) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_shocktube_hot),
                           "GRHydro_shocktube_hot",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Hot Shocktube initial data",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           2, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_Y_e_one",
                           "HydroBase_Zero");
  }
}
if (CCTK_Equals(initial_hydro,"shocktube")) {
  if(CCTK_Equals(initial_Bvec,"shocktube"))
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_shocktubeM),
                           "GRHydro_shocktubeM",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Shocktube initial data - MHD version",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
    if(CCTK_Equals(shocktube_type,"diagshock")) 
    {
      if(clean_divergence){
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_Diagshock_BoundaryM),
                           "GRHydro_Diagshock_BoundaryM",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Diagonal shock boundary conditions",
                           "ApplyBCs",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           5, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           2, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GRHydro::dens",
                           "GRHydro::tau",
                           "GRHydro::scon",
                           "GRHydro::Bcons",
                           "GRHydro::psidc",
                           "",
                           "BoundaryConditions",
                           "Boundary::Boundary_ClearSelection");
  }
      } else {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_Diagshock_BoundaryM),
                           "GRHydro_Diagshock_BoundaryM",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Diagonal shock boundary conditions",
                           "ApplyBCs",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           4, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           2, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GRHydro::dens",
                           "GRHydro::tau",
                           "GRHydro::scon",
                           "GRHydro::Bcons",
                           "",
                           "BoundaryConditions",
                           "Boundary::Boundary_ClearSelection");
  }
      }
    }
    if(CCTK_Equals(shocktube_type,"diagshock2d")) 
    {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_Diagshock2D_BoundaryM),
                           "GRHydro_Diagshock2D_BoundaryM",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "2-D Diagonal shock boundary conditions",
                           "ApplyBCs",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           2, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "BoundaryConditions",
                           "Boundary::Boundary_ClearSelection");
  }
    }
  } else {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_shocktube),
                           "GRHydro_shocktube",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Shocktube initial data",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  }
}
if (CCTK_Equals(initial_hydro,"cylexp")) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_CylindricalExplosionM),
                           "GRHydro_CylindricalExplosionM",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Cylindrical Explosion initial data - MHD-only",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
}
if (CCTK_Equals(initial_data,"con2primtest")) {
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro_InitData::GRHydro_init_data_reflevel")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro_InitData::GRHydro_init_data_reflevel", CCTK_DeclaredTimeLevels("GRHydro_InitData::GRHydro_init_data_reflevel"));
  CCTKi_ScheduleGroupStorage("GRHydro_InitData::GRHydro_init_data_reflevel",1);
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_Init_Data_RefinementLevel),
                           "GRHydro_Init_Data_RefinementLevel",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Calculate current refinement level",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "GRHydro_con2primtest");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_con2primtest),
                           "GRHydro_con2primtest",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Testing the conservative to primitive solver",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
}
if (CCTK_Equals(initial_data,"con2prim2con_test")) {
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro_InitData::GRHydro_init_data_reflevel")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro_InitData::GRHydro_init_data_reflevel", CCTK_DeclaredTimeLevels("GRHydro_InitData::GRHydro_init_data_reflevel"));
  CCTKi_ScheduleGroupStorage("GRHydro_InitData::GRHydro_init_data_reflevel",1);
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_Init_Data_RefinementLevel),
                           "GRHydro_Init_Data_RefinementLevel",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Calculate current refinement level",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "c2p2c_call");
  }
  if(CCTK_Equals(Bvec_evolution_method,"GRHydro"))
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(c2p2cM),
                           "c2p2c_call",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Testing conservative to primitive to conservative - MHD version",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  } else {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(c2p2c),
                           "c2p2c_call",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Testing conservative to primitive to conservative",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  }
}
if (CCTK_Equals(initial_data,"prim2con2prim_test")) {
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro_InitData::GRHydro_init_data_reflevel")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro_InitData::GRHydro_init_data_reflevel", CCTK_DeclaredTimeLevels("GRHydro_InitData::GRHydro_init_data_reflevel"));
  CCTKi_ScheduleGroupStorage("GRHydro_InitData::GRHydro_init_data_reflevel",1);
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_Init_Data_RefinementLevel),
                           "GRHydro_Init_Data_RefinementLevel",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Calculate current refinement level",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "p2c2p_call");
  }
  if(CCTK_Equals(Bvec_evolution_method,"GRHydro"))
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(p2c2pM),
                           "p2c2p_call",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Testing primitive to conservative to primitive - MHD version",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  } else {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(p2c2p),
                           "p2c2p_call",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Testing primitive to conservative to primitive",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  }
}
if (CCTK_Equals(initial_data,"prim2con2prim_polytype_test")) {
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro_InitData::GRHydro_init_data_reflevel")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro_InitData::GRHydro_init_data_reflevel", CCTK_DeclaredTimeLevels("GRHydro_InitData::GRHydro_init_data_reflevel"));
  CCTKi_ScheduleGroupStorage("GRHydro_InitData::GRHydro_init_data_reflevel",1);
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_Init_Data_RefinementLevel),
                           "GRHydro_Init_Data_RefinementLevel",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Calculate current refinement level",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "p2c2p_call");
  }
  if(CCTK_Equals(Bvec_evolution_method,"GRHydro"))
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(p2c2pM_polytype),
                           "p2c2p_call",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Testing primitive to conservative to primitive - MHD polytype version",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  }
}
if (CCTK_Equals(initial_data,"reconstruction_test")) {
  {
    int cctkschedulei_tlevelarray[] = {1,1,0};
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHYDRO::GRHydro_prim_bext")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHYDRO::GRHydro_prim_bext", CCTK_DeclaredTimeLevels("GRHYDRO::GRHydro_prim_bext"));
    if(!(1 >= 0 && 1 <= CCTK_DeclaredTimeLevels("GRHYDRO::GRHydro_scalars")))
        CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                   "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                   "Value must be between 0 and %d (inclusive)",
                   (long)1, "GRHYDRO::GRHydro_scalars", CCTK_DeclaredTimeLevels("GRHYDRO::GRHydro_scalars"));
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_reconstruction_test),
                           "GRHydro_reconstruction_test",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Testing the reconstruction",
                           "HydroBase_Initial",
                           "Fortran",
                           2,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           2, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GRHYDRO::GRHydro_prim_bext",
                           "GRHYDRO::GRHydro_scalars",
                           "global",
                           "loop-local",
                           "");
  }
}
if (CCTK_Equals(initial_hydro,"only_atmo")) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_Only_Atmo),
                           "GRHydro_Only_Atmo",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Only atmosphere as initial data",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
}
if (CCTK_Equals(initial_hydro,"read_conformal")) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_ReadConformalData),
                           "GRHydro_ReadConformalData",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Set the missing quantities, after reading in from file initial data from conformally-flat codes (Garching)",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
}
if (CCTK_Equals(initial_hydro,"simple_wave")) {
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro_init_data::simple_wave_grid_functions")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro_init_data::simple_wave_grid_functions", CCTK_DeclaredTimeLevels("GRHydro_init_data::simple_wave_grid_functions"));
  CCTKi_ScheduleGroupStorage("GRHydro_init_data::simple_wave_grid_functions",1);
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro_init_data::simple_wave_scalars")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro_init_data::simple_wave_scalars", CCTK_DeclaredTimeLevels("GRHydro_init_data::simple_wave_scalars"));
  CCTKi_ScheduleGroupStorage("GRHydro_init_data::simple_wave_scalars",1);
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_SimpleWave),
                           "GRHydro_SimpleWave",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Set initial data from Anile Miller Motta, Phys.Fluids. 26, 1450 (1983)",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "");
  }
  if(!(1 >= 0 && 1  <= CCTK_DeclaredTimeLevels("GRHydro_init_data::simple_wave_output")))
      CCTK_VWarn(0, __LINE__, __FILE__, CCTK_THORNSTRING,
                 "Tried to schedule %ld timelevels for group '%s' in schedule.ccl.\n"
                 "Value must be between 0 and %d (inclusive)",
                 (long)1, "GRHydro_init_data::simple_wave_output", CCTK_DeclaredTimeLevels("GRHydro_init_data::simple_wave_output"));
  CCTKi_ScheduleGroupStorage("GRHydro_init_data::simple_wave_output",1);
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_SimpleWave_Analysis),
                           "GRHydro_SimpleWave_Analysis",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Compute some output variables for the Simple Wave",
                           "CCTK_ANALYSIS",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "GRHydro_Entropy");
  }
}
if (CCTK_EQUALS(initial_hydro, "hydro_bondi_solution_iso"))
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_Bondi_Iso),
                           "GRHydro_Bondi_Iso",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "setup GRHydro vars for the hydrodynamic Bondi solution",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_ExcisionMaskSetup");
  }
}
if (CCTK_EQUALS(initial_hydro, "magnetized_bondi_solution_iso"))
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_BondiM_Iso),
                           "GRHydro_BondiM_Iso",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "setup GRHydro vars for the magnetized Bondi solution",
                           "HydroBase_Initial",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_ExcisionMaskSetup");
  }
}
if (CCTK_EQUALS(initial_hydro, "hydro_bondi_solution"))
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydro_Bondi,
                           "GRHydro_Bondi",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "setup GRHydro vars for the hydrodynamic Bondi solution",
                           "HydroBase_Initial",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_ExcisionMaskSetup");
  }
}
if (CCTK_EQUALS(initial_hydro, "magnetized_bondi_solution"))
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydro_BondiM,
                           "GRHydro_BondiM",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "setup GRHydro vars for the magnetized Bondi solution",
                           "HydroBase_Initial",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           0, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_ExcisionMaskSetup");
  }
}
if(bondi_evolve_only_annulus) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydro_BondiM_Range,
                           "GRHydro_BondiM_Range",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "force analytic solution outside anulus",
                           "HydroBase_Con2Prim",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "Con2Prim");
  }
}
if(bondi_overwrite_boundary ) {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)GRHydro_BondiM_Boundary,
                           "GRHydro_BondiM_Boundary",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "force analytic solution in boundaries",
                           "HydroBase_Boundaries",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           0, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "HydroBase_Select_Boundaries");
  }
}
if (CCTK_EQUALS(initial_Bvec, "poloidalmagfield") || CCTK_EQUALS(initial_Avec, "poloidalmagfield"))
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)CCTK_FNAME(GRHydro_PoloidalMagFieldM),
                           "GRHydro_PoloidalMagFieldM",
                           "GRHydro_InitData",
                           "GRHydro_init_data",
                           "Set up a poloidal magnetic field. It expects the other fluid variables already to be set, as for example in the TOV solution",
                           "CCTK_INITIAL",
                           "Fortran",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0, /* Number of SYNC     groups    */
                           0, /* Number of WRITES clauses     */
                           0, /* Number of READS clauses      */
                           0, /* Number of Options            */
                           1, /* Number of BEFORE   routines  */
                           1, /* Number of AFTER    routines  */
                           0, /* Number of WHILE    variables */
                           0, /* Number of IF       variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "",
                           "GRHydroTransformPrimToLocalBasis",
                           "HydroBase_Initial");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("HydroBase_Boundaries",
"HydroBase_Boundaries",
                        "GRHydro_InitData",
                        "GRHydro_init_data",
                        "Call boundary conditions after magnetic field initial data setup",
                        "CCTK_INITIAL",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0, /* Number of SYNC     groups    */
                        0, /* Number of WRITES clauses     */
                        0, /* Number of READS clauses      */
                        0, /* Number of Options            */
                        1, /* Number of BEFORE   routines  */
                        1, /* Number of AFTER    routines  */
                        0, /* Number of WHILE    variables */
                        0, /* Number of IF       variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "",
                        "GRHydroTransformPrimToLocalBasis",
                        "GRHydro_PoloidalMagFieldM");
  }
}
}

/*@@
  @routine    CCTKi_BindingsParameterRecovery_GRHydro_InitData
  @author     Automatically generated by CreateScheduleBindings.pl
  @desc
              Creates the parameter recovery bindings for thorn GRHydro_InitData
  @enddesc
@@*/

int CCTKi_BindingsParameterRecovery_GRHydro_InitData(void);
int CCTKi_BindingsParameterRecovery_GRHydro_InitData(void)
{
  /* this thorn doesn't define any parameter recovery routines */
  return (0);
}

