[
  {
    "worker_id": 0,
    "example_index": 0,
    "thorn_name": "CactusBase/Boundary",
    "src_filename": "NoneBoundary.c",
    "generated_code": "/*@@\n  @file      NoneBoundary.c\n  @date      Mon Mar 15 15:09:00 1999\n  @author    Gerd Lanfermann\n  @desc\n             Routines for applying none boundary conditions\n  @enddesc\n  @history\n  @hdate     Tue 10 Apr 2001\n  @hauthor   Thomas Radke\n  @hdesc     BC routines generalized for applying to arbitrary CCTK data types\n  @endhistory\n  @version   $Id$\n@@*/\n\n/*#define DEBUG_BOUNDARY*/\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"cctk.h\"\n#include \"util_Table.h\"\n#include \"util_ErrorCodes.h\"\n#include \"cctk_Parameters.h\"\n#include \"cctk_FortranString.h\"\n\n#include \"Boundary.h\"\n\n/* the rcs ID and its dummy function to use it */\nstatic const char *rcsid = \"$Header$\";\nCCTK_FILEVERSION(CactusBase_Boundary_NoneBoundary_c);\n\n/********************************************************************\n ********************    External Routines   ************************\n ********************************************************************/\n/*@@\n   @routine    BndNone\n   @date       13 Feb 2003\n   @author     David Rideout\n   @desc\n               Top level function which is registered as handling\n               the None boundary condition\n   @enddesc\n\n   @var        GH\n   @vdesc      Pointer to CCTK grid hierarchy\n   @vtype      const cGH *\n   @vio        in\n   @endvar\n   @var        num_vars\n   @vdesc      number of variables passed in through var_indices[]\n   @vtype      CCTK_INT\n   @vio        in\n   @endvar\n   @var        var_indices\n   @vdesc      array of variable indicies to which to apply this boundary\n               condition\n   @vtype      CCTK_INT *\n   @vio        in\n   @endvar\n   @var        faces\n   @vdesc      array of set of faces to which to apply the bc\n   @vtype      CCTK_INT\n   @vio        in\n   @endvar\n   @var        widths\n   @vdesc      array of boundary widths for each variable\n   @vtype      CCTK_INT\n   @vio        in\n   @endvar\n   @var        table_handles\n   @vdesc      array of table handles which hold extra arguments\n   @vtype      CCTK_INT\n   @vio        in\n   @endvar\n   @returntype CCTK_INT\n   @returndesc\n               return code: 0 for success\n   @endreturndesc\n@@*/\nCCTK_INT BndNone(const cGH *GH, CCTK_INT num_vars, CCTK_INT *vars,\n                 CCTK_INT *faces, CCTK_INT *widths, CCTK_INT *tables) {\n  int i;\n\n  /* avoid compiler warnings about unused parameters */\n  (void)(GH + 0);\n  (void)(faces + 0);\n  (void)(widths + 0);\n  (void)(tables + 0);\n\n  /* loop through variables */\n  for (i = 0; i < num_vars; i++) {\n    /* Check to see if faces specification is valid */\n    if (faces[i] != CCTK_ALL_FACES) {\n      CCTK_VWarn(1, __LINE__, __FILE__, CCTK_THORNSTRING,\n                 \"Faces specification %d for None boundary conditions on \"\n                 \"%s is not implemented yet.  \"\n                 \"Applying None bcs to all (external) faces.\",\n                 (int)faces[i], CCTK_VarName(vars[i]));\n    }\n  }\n\n  /* None boundary condition does nothing - just return success */\n  return 0;\n}\n\n/* prototypes for external C routines are declared in header Boundary.h\n   here only follow the fortran wrapper prototypes */\nvoid CCTK_FCALL CCTK_FNAME(BndNoneDirGI)(int *ierr, const cGH **GH,\n                                         const int *stencil_size,\n                                         const int *dir, const int *gi);\nvoid CCTK_FCALL CCTK_FNAME(BndNoneGI)(int *ierr, const cGH **GH,\n                                      const int *stencil, const int *gi);\nvoid CCTK_FCALL CCTK_FNAME(BndNoneDirGN)(int *ierr, const cGH **GH,\n                                         const int *stencil_size,\n                                         const int *dir, ONE_FORTSTRING_ARG);\nvoid CCTK_FCALL CCTK_FNAME(BndNoneGN)(int *ierr, const cGH **GH,\n                                      const int *stencil, ONE_FORTSTRING_ARG);\nvoid CCTK_FCALL CCTK_FNAME(BndNoneDirVI)(int *ierr, const cGH **GH,\n                                         const int *stencil_size,\n                                         const int *dir, const int *vi);\nvoid CCTK_FCALL CCTK_FNAME(BndNoneVI)(int *ierr, const cGH **GH,\n                                      const int *stencil, const int *vi);\nvoid CCTK_FCALL CCTK_FNAME(BndNoneDirVN)(int *ierr, const cGH **GH,\n                                         const int *stencil_size,\n                                         const int *dir, ONE_FORTSTRING_ARG);\nvoid CCTK_FCALL CCTK_FNAME(BndNoneVN)(int *ierr, const cGH **GH,\n                                      const int *stencil, ONE_FORTSTRING_ARG);\n\n/********************************************************************\n ********************    Internal Routines   ************************\n ********************************************************************/\n\n/*@@\n   @routine    BndNoneDirGI\n   @date       Sun Jan 21 2001\n   @author     Gabrielle Allen\n   @desc\n               Apply none boundary conditions by group index in given direction\n   @enddesc\n\n   @var        GH\n   @vdesc      Pointer to CCTK grid hierarchy\n   @vtype      const cGH *\n   @vio        in\n   @endvar\n   @var        stencil_size\n   @vdesc      stencil size in this direction\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        dir\n   @vdesc      direction to apply boundaries\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        gi\n   @vdesc      index of group to apply boundaries to\n   @vtype      int\n   @vio        in\n   @endvar\n\n   @returntype int\n   @returndesc\n               return code of @seeroutine BndNone <BR>\n               -1 if invalid group index was passed\n   @endreturndesc\n@@*/\nint BndNoneDirGI(const cGH *GH, int stencil_size, int dir, int gi) {\n  int first_vi, retval;\n\n  first_vi = CCTK_FirstVarIndexI(gi);\n  if (first_vi >= 0) {\n    retval = BndNoneDirVI(GH, stencil_size, dir, first_vi);\n  } else {\n    CCTK_VWarn(2, __LINE__, __FILE__, CCTK_THORNSTRING,\n               \"Invalid group index %d in BndNoneDirGI\", gi);\n    retval = -1;\n  }\n\n  return (retval);\n}\n\n/*@@\n   @routine    BndNoneGI\n   @date       Thu Mar  2 11:02:10 2000\n   @author     Gerd Lanfermann\n   @desc\n               Apply none boundary conditions by group index\n   @enddesc\n   @calls      BndNoneDirGI\n\n   @var        GH\n   @vdesc      Pointer to CCTK grid hierarchy\n   @vtype      const cGH *\n   @vio        in\n   @endvar\n   @var        stencil\n   @vdesc      stencil width\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        gi\n   @vdesc      index of group to apply boundaries to\n   @vtype      int\n   @vio        in\n   @endvar\n\n   @returntype int\n   @returndesc\n               return code of @seeroutine BndNoneDirGI\n   @endreturndesc\n@@*/\nint BndNoneGI(const cGH *GH, int stencil, int gi) {\n  return BndNoneDirGI(GH, stencil, 0, gi);\n}\n\n/*@@\n   @routine    BndNoneDirGN\n   @date       Sun Jan 21 2001\n   @author     Gabrielle Allen\n   @desc\n               Apply none boundary conditions by group name in given direction\n   @enddesc\n   @calls      BndNoneDirGI\n\n   @var        GH\n   @vdesc      Pointer to CCTK grid hierarchy\n   @vtype      const cGH *\n   @vio        in\n   @endvar\n   @var        stencil_size\n   @vdesc      stencil size in this direction\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        dir\n   @vdesc      direction to apply boundaries\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        gname\n   @vdesc      name of group to apply boundaries to\n   @vtype      const char *\n   @vio        in\n   @endvar\n\n   @returntype int\n   @returndesc\n               return code of @seeroutine BndNoneDirGI <BR>\n               -1 if invalid group name was passed\n   @endreturndesc\n@@*/\nint BndNoneDirGN(const cGH *GH, int stencil_size, int dir,\n                 const char *gname) {\n  int gi, retval;\n\n  gi = CCTK_GroupIndex(gname);\n  if (gi >= 0) {\n    retval = BndNoneDirGI(GH, stencil_size, dir, gi);\n  } else {\n    CCTK_VWarn(2, __LINE__, __FILE__, CCTK_THORNSTRING,\n               \"Invalid group name '%s' in BndNoneDirGN\", gname);\n    retval = -1;\n  }\n\n  return (retval);\n}\n\n/*@@\n   @routine    BndNoneGN\n   @date       Thu Mar  2 11:02:10 2000\n   @author     Gerd Lanfermann\n   @desc\n               Apply none boundary conditions by group name\n   @enddesc\n   @calls      BndNoneDirGN\n\n   @var        GH\n   @vdesc      Pointer to CCTK grid hierarchy\n   @vtype      const cGH *\n   @vio        in\n   @endvar\n   @var        stencil\n   @vdesc      stencil width\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        gname\n   @vdesc      name of group to apply boundaries to\n   @vtype      const char *\n   @vio        in\n   @endvar\n\n   @returntype int\n   @returndesc\n               return code of @seeroutine BndNoneDirGN\n   @endreturndesc\n@@*/\nint BndNoneGN(const cGH *GH, int stencil, const char *gname) {\n  return BndNoneDirGN(GH, stencil, 0, gname);\n}\n\n/*@@\n   @routine    BndNoneDirVI\n   @date       Sun Jan 21 2001\n   @author     Gabrielle Allen\n   @desc\n               Apply none boundary conditions by variable index in given direction\n   @enddesc\n\n   @var        GH\n   @vdesc      Pointer to CCTK grid hierarchy\n   @vtype      const cGH *\n   @vio        in\n   @endvar\n   @var        stencil_size\n   @vdesc      stencil size in this direction\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        dir\n   @vdesc      direction to apply boundaries\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        vi\n   @vdesc      index of variable to apply boundaries to\n   @vtype      int\n   @vio        in\n   @endvar\n\n   @returntype int\n   @returndesc\n               return code: 0 for success\n               -1 if invalid variable index was passed\n   @endreturndesc\n@@*/\nint BndNoneDirVI(const cGH *GH, int stencil_size, int dir, int vi) {\n  int retval;\n\n  /* avoid compiler warnings about unused parameters */\n  (void)(GH + 0);\n  (void)(stencil_size + 0);\n  (void)(dir + 0);\n\n  /* check input arguments */\n  if (vi < 0 || vi >= CCTK_NumVars()) {\n    CCTK_VWarn(2, __LINE__, __FILE__, CCTK_THORNSTRING,\n               \"Invalid variable index %d in BndNoneDirVI\", vi);\n    retval = -1;\n  } else {\n    retval = 0;\n  }\n\n  return (retval);\n}\n\n/*@@\n   @routine    BndNoneVI\n   @date       Thu Mar  2 11:02:10 2000\n   @author     Gerd Lanfermann\n   @desc\n               Apply none boundary conditions by variable index\n   @enddesc\n   @calls      BndNoneDirVI\n\n   @var        GH\n   @vdesc      Pointer to CCTK grid hierarchy\n   @vtype      const cGH *\n   @vio        in\n   @endvar\n   @var        stencil\n   @vdesc      stencil width\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        vi\n   @vdesc      index of variable to apply boundaries to\n   @vtype      int\n   @vio        in\n   @endvar\n\n   @returntype int\n   @returndesc\n               return code of @seeroutine BndNoneDirVI\n   @endreturndesc\n@@*/\nint BndNoneVI(const cGH *GH, int stencil, int vi) {\n  return BndNoneDirVI(GH, stencil, 0, vi);\n}\n\n/*@@\n   @routine    BndNoneDirVN\n   @date       Sun Jan 21 2001\n   @author     Gabrielle Allen\n   @desc\n               Apply none boundary conditions by variable name in given direction\n   @enddesc\n   @calls      BndNoneDirVI\n\n   @var        GH\n   @vdesc      Pointer to CCTK grid hierarchy\n   @vtype      const cGH *\n   @vio        in\n   @endvar\n   @var        stencil_size\n   @vdesc      stencil size in this direction\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        dir\n   @vdesc      direction to apply boundaries\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        vname\n   @v",
    "build_result": {
      "success": true,
      "return_code": 0,
      "stdout": "Cactus - version: 4.2.3\nSetup configuration Boundary (yes)?\nSetup of configuration Boundary cancelled\n",
      "stderr": "",
      "clean_output": "Please specify a configuration to clean.\n",
      "clean_error": ""
    },
    "test_result": {
      "total_tests": 0,
      "passed_tests": 0,
      "failed_tests": 0,
      "test_results": [],
      "error": "No test files found"
    },
    "score_result": {
      "overall_score": 40.0,
      "build_score": 40,
      "test_run_score": 0.0,
      "test_accuracy_score": 0.0,
      "breakdown": {
        "build_success": true,
        "total_tests": 0,
        "passed_tests": 0,
        "failed_tests": 0,
        "test_success_rate": 0.0,
        "tests_attempted": false
      },
      "grade": "F"
    },
    "timestamp": "2025-09-26T13:06:16.448437",
    "success": true
  },
  {
    "worker_id": 1,
    "example_index": 1,
    "thorn_name": "CactusBase/Boundary",
    "src_filename": "FlatBoundary.c",
    "generated_code": "/*@@\n  @file      FlatBoundary.c\n  @date      Mon Mar 15 15:09:00 1999\n  @author    Miguel Alcubierre, Gabrielle Allen, Gerd Lanfermann\n  @desc\n             Routines for applying flat boundary conditions\n  @enddesc\n  @history\n  @hdate     Sat 02 Nov 2002\n  @hauthor   David Rideout\n  @hdesc     Complete rewrite for Cactus 4.0, to use new boundary API\n  @endhistory\n  @version   $Header$\n@@*/\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"cctk.h\"\n#include \"cctk_Parameters.h\"\n#include \"cctk_FortranString.h\"\n\n#include \"Symmetry.h\"\n#include \"Boundary.h\"\n\n/* the rcs ID and its dummy function to use it */\nstatic const char *rcsid = \"$Header$\";\nCCTK_FILEVERSION(CactusBase_Boundary_FlatBoundary_c);\n\n/********************************************************************\n ********************    Local Data Types   ***********************\n ********************************************************************/\n\n/********************************************************************\n ********************    Local Data   *****************************\n ********************************************************************/\n\n/********************************************************************\n ********************    Local Functions  *************************\n ********************************************************************/\nstatic int ApplyBndFlat(const cGH *GH, \n                        CCTK_INT stencil_dir,\n                        const CCTK_INT *stencil_alldirs,\n                        int dir,\n                        int first_var_to,\n                        int first_var_from,\n                        int num_vars);\n\n/********************************************************************\n ********************    External Routines   **********************\n ********************************************************************/\n\n/*@@\n   @routine    BndFlat\n   @date       13 Feb 2003\n   @author     David Rideout\n   @desc\n               Function which handles 'Flat' boundary condition\n   @enddesc\n   @calls      ApplyBndFlat\n\n   @var        GH\n   @vdesc      Pointer to CCTK grid hierarchy\n   @vtype      const cGH *\n   @vio        in\n   @endvar\n   @var        num_vars\n   @vdesc      number of variables passed in through var_indices[]\n   @vtype      CCTK_INT\n   @vio        in\n   @endvar\n   @var        var_indices\n   @vdesc      array of variable indicies to which to apply this boundary\n               condition\n   @vtype      CCTK_INT *\n   @vio        in\n   @endvar\n   @var        faces\n   @vdesc      array of set of faces to which to apply the bc\n   @vtype      CCTK_INT\n   @vio        in\n   @endvar\n   @var        widths\n   @vdesc      array of boundary widths for each variable\n   @vtype      CCTK_INT\n   @vio        in\n   @endvar\n   @var        table_handles\n   @vdesc      array of table handles which hold extra arguments\n   @vtype      CCTK_INT\n   @vio        in\n   @endvar\n   @returntype CCTK_INT\n   @returndesc\n               return code of @ref ApplyBndFlat <BR>\n               -1 if invalid variable type\n               -2 if invalid variable dimension\n               -3 if invalid stencil size\n   @endreturndesc\n@@*/\n\nCCTK_INT BndFlat(const cGH *GH, CCTK_INT num_vars, CCTK_INT *var_indices,\n                 CCTK_INT *faces, CCTK_INT *widths, CCTK_INT *table_handles)\n{\n  DECLARE_CCTK_PARAMETERS;\n  int i, j, k, gi, gdim, max_gdim, err, retval;\n\n  /* character strings */\n  char *groupname;\n  CCTK_INT *boundary_widths, *stencil_alldirs, stencil_dir;\n  int *symbnd;\n  SymmetryGHex *sGHex;\n\n  retval = 0; symbnd = NULL; sGHex = NULL;\n  stencil_alldirs = NULL; boundary_widths = NULL;\n\n  /* get the dimensionality */\n  max_gdim = CCTK_MaxDim();\n\n  /* allocate arrays for variables with less than max_gdim dimensions */\n  boundary_widths = calloc (2 * max_gdim, sizeof (CCTK_INT));\n  stencil_alldirs = calloc (2 * max_gdim, sizeof (CCTK_INT));\n  if (! (boundary_widths && stencil_alldirs))\n  {\n    CCTK_VWarn (1, __LINE__, __FILE__, CCTK_THORNSTRING,\n                \"BndFlat: Could not allocate memory for internal arrays\");\n    retval = -5; goto BndFlat_exit;\n  }\n\n  /* Initialize arrays */\n  for (i = 0; i < 2 * max_gdim; i++)\n  {\n    boundary_widths[i] = 0;\n    stencil_alldirs[i] = 0;\n  }\n\n  /* get symmetry GH extension to get symmetry boundary width */\n  sGHex = (SymmetryGHex *) CCTK_GHExtension (GH, \"Symmetry\");\n\n  /* loop through variables, j keeps track of var_indices[i] */\n  for (i = j = 0; i < num_vars; i++, j++)\n  {\n    /* with PUGH we can have different variables with different\n       stencil widths */\n    gi = CCTK_GroupIndexFromVarI (var_indices[i]);\n    if (gi < 0)\n    {\n      CCTK_VWarn (1, __LINE__, __FILE__, CCTK_THORNSTRING,\n                  \"BndFlat: Invalid variable index %d\", var_indices[i]);\n      retval = -4; goto BndFlat_exit;\n    }\n\n    gdim = CCTK_GroupDimI (gi);\n\n    /* check the group type */\n    if (CCTK_GroupTypeI (gi) != CCTK_GF)\n    {\n      groupname = CCTK_GroupName (gi);\n      CCTK_VWarn (1, __LINE__, __FILE__, CCTK_THORNSTRING,\n                  \"BndFlat: Variable '%s' is not a grid function. \"\n                  \"Flat boundary conditions can only be applied to grid \"\n                  \"functions.\", groupname);\n      free (groupname);\n      retval = -1; goto BndFlat_exit;\n    }\n\n    /* check that the variable has storage */\n    if (! CCTK_QueryGroupStorageI (GH, gi))\n    {\n      groupname = CCTK_GroupName (gi);\n      CCTK_VWarn (2, __LINE__, __FILE__, CCTK_THORNSTRING,\n                  \"BndFlat: Cannot apply flat boundary conditions to \"\n                  \"variable '%s' (no storage)\", groupname);\n      free (groupname);\n      continue;\n    }\n\n    /* from here on we know that we have a grid function */\n    stencil_dir = widths[i];\n    if (stencil_dir < 0)\n    {\n      CCTK_VWarn (1, __LINE__, __FILE__, CCTK_THORNSTRING,\n                  \"BndFlat: stencil width %d is invalid\", \n                  (int) stencil_dir);\n      retval = -3; goto BndFlat_exit;\n    }\n\n    /* initialize the boundary_widths array */\n    BndSanityCheckWidths(GH, var_indices[i], gdim, &stencil_dir, \"Flat\");\n\n    /* Use boundary_widths for PUGH */\n    for (k = 0; k < 2 * gdim; k++)\n    {\n      boundary_widths[k] = stencil_dir;\n      stencil_alldirs[k] = stencil_dir;\n    }\n\n    /* get the symmetry boundary width */\n    if (sGHex)\n    {\n      symbnd = (int *) sGHex->GFSym[var_indices[i]];\n    }\n\n    /* now loop over all faces */\n    for (k = 0; k < 2 * gdim; k++)\n    {\n      /* skip this face if no boundary width is set */\n      if (boundary_widths[k] <= 0)\n      {\n        continue;\n      }\n\n      /* skip this face if it's not selected */\n      if (! (faces[i] & (1 << k)))\n      {\n        continue;\n      }\n\n      /* skip this face if it's a symmetry face */\n      if (symbnd && symbnd[k] < 0)\n      {\n        continue;\n      }\n\n      /* apply the boundary condition */\n      if ((err = ApplyBndFlat (GH, stencil_dir, stencil_alldirs, k,\n                               var_indices[i], var_indices[i], 1)) < 0)\n      {\n        CCTK_VWarn (1, __LINE__, __FILE__, CCTK_THORNSTRING,\n                    \"BndFlat: Error %d applying flat boundary \"\n                    \"conditions to variable '%s'\", err,\n                    CCTK_VarName (var_indices[i]));\n        retval = err; goto BndFlat_exit;\n      }\n    }\n  }\n\nBndFlat_exit:\n  if (boundary_widths)\n  {\n    free (boundary_widths);\n  }\n  if (stencil_alldirs)\n  {\n    free (stencil_alldirs);\n  }\n\n  return retval;\n}\n\n\n/*@@\n   @routine    BndFlatDirGI\n   @date       Sat Jan 20 14:57:28 2001\n   @author     Gabrielle Allen\n   @desc\n               Apply flat boundary conditions by group index in given direction\n   @enddesc\n   @calls      ApplyBndFlat\n\n   @var        GH\n   @vdesc      Pointer to CCTK grid hierarchy\n   @vtype      const cGH *\n   @vio        in\n   @endvar\n   @var        stencil_size\n   @vdesc      stencil size in this direction\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        dir\n   @vdesc      direction to apply BC\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        gi\n   @vdesc      index of group to apply BC to\n   @vtype      int\n   @vio        in\n   @endvar\n\n   @returntype int\n   @returndesc\n               return code of @ref ApplyBndFlat <BR>\n               -1 if invalid group index was given\n   @endreturndesc\n@@*/\nint BndFlatDirGI (const cGH *GH,\n                  int stencil_size,\n                  int dir,\n                  int gi)\n{\n  int first_vi, retval;\n\n  first_vi = CCTK_FirstVarIndexI (gi);\n  if (first_vi >= 0)\n  {\n    retval = ApplyBndFlat (GH, stencil_size, NULL, dir, first_vi, first_vi,\n                           CCTK_NumVarsInGroupI (gi));\n  }\n  else\n  {\n    CCTK_VWarn (2, __LINE__, __FILE__, CCTK_THORNSTRING,\n                \"BndFlatDirGI: Invalid group index %d\", gi);\n    retval = -1;\n  }\n\n  return (retval);\n}\n\nint BndFlatGI (const cGH *GH,\n               const int *stencil,\n               int gi)\n{\n  int dir, err, retval;\n\n  retval = 0;\n  for (dir = 0; dir < 2 * CCTK_GroupDimI (gi); dir++)\n  {\n    err = BndFlatDirGI (GH, stencil[dir], dir, gi);\n    if (err < 0)\n    {\n      retval = err;\n    }\n  }\n\n  return (retval);\n}\n\nint BndFlatDirGN (const cGH *GH,\n                  int stencil_size,\n                  int dir,\n                  const char *gname)\n{\n  return (BndFlatDirGI (GH, stencil_size, dir, CCTK_GroupIndex (gname)));\n}\n\nint BndFlatGN (const cGH *GH,\n               const int *stencil,\n               const char *gname)\n{\n  return (BndFlatGI (GH, stencil, CCTK_GroupIndex (gname)));\n}\n\nint BndFlatDirVI (const cGH *GH,\n                  int stencil_size,\n                  int dir,\n                  int vi)\n{\n  return (ApplyBndFlat (GH, stencil_size, NULL, dir, vi, vi, 1));\n}\n\nint BndFlatVI (const cGH *GH,\n               const int *stencil,\n               int vi)\n{\n  int dir, err, retval;\n\n  retval = 0;\n  for (dir = 0; dir < 2 * CCTK_GroupDimFromVarI (vi); dir++)\n  {\n    err = BndFlatDirVI (GH, stencil[dir], dir, vi);\n    if (err < 0)\n    {\n      retval = err;\n    }\n  }\n\n  return (retval);\n}\n\nint BndFlatDirVN (const cGH *GH,\n                  int stencil_size,\n                  int dir,\n                  const char *vname)\n{\n  return (BndFlatDirVI (GH, stencil_size, dir, CCTK_VarIndex (vname)));\n}\n\nint BndFlatVN (const cGH *GH,\n               const int *stencil,\n               const char *vname)\n{\n  return (BndFlatVI (GH, stencil, CCTK_VarIndex (vname)));\n}\n\n/********************************************************************\n ********************    Local Routines   *************************\n ********************************************************************/\n\n/* maximum dimension we can deal with */\n#define MAXDIM  3\n\n/* macro to compute the linear index of a 3D point */\n#define INDEX_3D(ash, i, j, k)  ((i) + (ash)[0]*((j) + (ash)[1]*(k)))\n/* macro to compute the linear index of a 2D point */\n#define INDEX_2D(ash, i, j, k)  ((i) + (ash)[0]*(j))\n/* macro to compute the linear index of a 1D point */\n#define INDEX_1D(ash, i, j, k)  (i)\n\n/*@@\n   @routine    FLAT_BOUNDARY\n   @date       Sat 02 Nov 2002\n   @author     David Rideout\n   @desc\n               Macro to apply flat boundary conditions to a variable\n               Currently it is limited up to 3D variables only.\n   @enddesc\n\n   @var        doBC\n   @vdesc      flag telling whether to apply boundary conditions or not\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        iend, jend, kend\n   @vdesc      upper ranges for the loopers",
    "build_result": {
      "success": true,
      "return_code": 0,
      "stdout": "Cactus - version: 4.2.3\nSetup configuration Boundary (yes)?\nSetup of configuration Boundary cancelled\n",
      "stderr": "",
      "clean_output": "Please specify a configuration to clean.\n",
      "clean_error": ""
    },
    "test_result": {
      "total_tests": 0,
      "passed_tests": 0,
      "failed_tests": 0,
      "test_results": [],
      "error": "No test files found"
    },
    "score_result": {
      "overall_score": 40.0,
      "build_score": 40,
      "test_run_score": 0.0,
      "test_accuracy_score": 0.0,
      "breakdown": {
        "build_success": true,
        "total_tests": 0,
        "passed_tests": 0,
        "failed_tests": 0,
        "test_success_rate": 0.0,
        "tests_attempted": false
      },
      "grade": "F"
    },
    "timestamp": "2025-09-26T13:06:26.901076",
    "success": true
  }
]