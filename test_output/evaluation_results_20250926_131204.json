[
  {
    "worker_id": 0,
    "example_index": 0,
    "thorn_name": "CactusExamples/Poisson",
    "src_filename": "uniform_charge.c",
    "generated_code": "#include <assert.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"cctk.h\"\n#include \"cctk_Arguments.h\"\n#include \"cctk_Parameters.h\"\n\n#include \"util_Table.h\"\n\nvoid Poisson_prepare(CCTK_ARGUMENTS)\n{\n  DECLARE_CCTK_ARGUMENTS;\n  DECLARE_CCTK_PARAMETERS;\n  \n  int i, j, k;\n  int index;\n  \n  for (k = 0; k < cctk_lsh[2]; k++) {\n    for (j = 0; j < cctk_lsh[1]; j++) {\n      for (i = 0; i < cctk_lsh[0]; i++) {\n        index = CCTK_GFINDEX3D(cctkGH, i, j, k);\n        \n        phi[index] = 0.0;\n        res[index] = 0.0;\n      }\n    }\n  }\n}\n\nvoid Poisson_solve(CCTK_ARGUMENTS)\n{\n  DECLARE_CCTK_ARGUMENTS;\n  DECLARE_CCTK_PARAMETERS;\n  \n  int i, j, k;\n  int index;\n  CCTK_REAL x, y, z, r;\n  CCTK_REAL rho;\n  CCTK_REAL volume;\n  int ierr;\n  int table_handle;\n  \n  volume = 4.0 * M_PI * radius * radius * radius / 3.0;\n  \n  for (k = 0; k < cctk_lsh[2]; k++) {\n    for (j = 0; j < cctk_lsh[1]; j++) {\n      for (i = 0; i < cctk_lsh[0]; i++) {\n        index = CCTK_GFINDEX3D(cctkGH, i, j, k);\n        \n        x = CCTK_ORIGIN_SPACE(0) + (cctk_lbnd[0] + i) * CCTK_DELTA_SPACE(0);\n        y = CCTK_ORIGIN_SPACE(1) + (cctk_lbnd[1] + j) * CCTK_DELTA_SPACE(1);\n        z = CCTK_ORIGIN_SPACE(2) + (cctk_lbnd[2] + k) * CCTK_DELTA_SPACE(2);\n        \n        r = sqrt(x*x + y*y + z*z);\n        \n        if (r <= radius) {\n          rho = charge / volume;\n        } else {\n          rho = 0.0;\n        }\n        \n        res[index] = rho;\n      }\n    }\n  }\n  \n  table_handle = Util_TableCreateFromString(options);\n  if (table_handle < 0) {\n    CCTK_WARN(0, \"Could not create table from solver options\");\n  }\n  \n  ierr = TATelliptic_Solve(cctkGH, 3, 1,\n                          CCTK_VarIndex(\"Poisson::phi\"),\n                          CCTK_VarIndex(\"Poisson::res\"),\n                          solver, table_handle);\n  \n  if (ierr != 0) {\n    CCTK_WARN(0, \"TATelliptic_Solve failed\");\n  }\n  \n  Util_TableDestroy(table_handle);\n}\n\nvoid Poisson_boundaries_select(CCTK_ARGUMENTS)\n{\n  DECLARE_CCTK_ARGUMENTS;\n  DECLARE_CCTK_PARAMETERS;\n  \n  int ierr;\n  int table_handle;\n  \n  table_handle = Util_TableCreateFromString(\"value=0.0\");\n  if (table_handle < 0) {\n    CCTK_WARN(0, \"Could not create table for boundary conditions\");\n  }\n  \n  ierr = Boundary_SelectGroupForBC(cctkGH, CCTK_ALL_FACES, 1, table_handle,\n                                   \"Poisson::potential\", \"scalar\");\n  \n  if (ierr != 0) {\n    CCTK_WARN(0, \"Could not select boundary conditions for potential\");\n  }\n  \n  Util_TableDestroy(table_handle);\n}",
    "build_result": {
      "success": true,
      "return_code": 0,
      "stdout": "Cactus - version: 4.2.3\nSetup configuration Poisson (yes)?\nSetup of configuration Poisson cancelled\n",
      "stderr": "",
      "clean_output": "Please specify a configuration to clean.\n",
      "clean_error": ""
    },
    "test_result": {
      "total_tests": 2,
      "passed_tests": 0,
      "failed_tests": 2,
      "test_results": [
        {
          "test_name": "charge_tatelliptic_petsc",
          "passed": false,
          "return_code": 127,
          "output_length": 0,
          "error_length": 46
        },
        {
          "test_name": "charge_tatelliptic_petsc",
          "passed": false,
          "return_code": 127,
          "output_length": 0,
          "error_length": 46
        }
      ]
    },
    "score_result": {
      "overall_score": 50.0,
      "build_score": 40,
      "test_run_score": 10,
      "test_accuracy_score": 0.0,
      "breakdown": {
        "build_success": true,
        "total_tests": 2,
        "passed_tests": 0,
        "failed_tests": 2,
        "test_success_rate": 0.0,
        "tests_attempted": true
      },
      "grade": "D"
    },
    "timestamp": "2025-09-26T13:11:07.310919",
    "success": true
  },
  {
    "worker_id": 0,
    "example_index": 1,
    "thorn_name": "CactusExamples/Poisson",
    "src_filename": "make.code.defn",
    "generated_code": "# Main make.code.defn file for thorn Poisson\n# Source files in this directory\nSRCS = uniform_charge.c\n\n# Subdirectories containing source files  \nSUBDIRS =",
    "build_result": {
      "success": true,
      "return_code": 0,
      "stdout": "Cactus - version: 4.2.3\nSetup configuration Poisson (yes)?\nSetup of configuration Poisson cancelled\n",
      "stderr": "",
      "clean_output": "Please specify a configuration to clean.\n",
      "clean_error": ""
    },
    "test_result": {
      "total_tests": 2,
      "passed_tests": 0,
      "failed_tests": 2,
      "test_results": [
        {
          "test_name": "charge_tatelliptic_petsc",
          "passed": false,
          "return_code": 127,
          "output_length": 0,
          "error_length": 46
        },
        {
          "test_name": "charge_tatelliptic_petsc",
          "passed": false,
          "return_code": 127,
          "output_length": 0,
          "error_length": 46
        }
      ]
    },
    "score_result": {
      "overall_score": 50.0,
      "build_score": 40,
      "test_run_score": 10,
      "test_accuracy_score": 0.0,
      "breakdown": {
        "build_success": true,
        "total_tests": 2,
        "passed_tests": 0,
        "failed_tests": 2,
        "test_success_rate": 0.0,
        "tests_attempted": true
      },
      "grade": "D"
    },
    "timestamp": "2025-09-26T13:11:13.598135",
    "success": true
  },
  {
    "worker_id": 0,
    "example_index": 2,
    "thorn_name": "CactusExamples/SampleBoundary",
    "src_filename": "Register.c",
    "generated_code": "/*@@\n   @file      Register.c\n   @date      6 May 2003\n   @author    David Rideout\n   @desc\n              Registration of boundary conditions provided by this thorn\n   @enddesc\n   @version   $Id$\n @@*/\n\n#include \"cctk.h\"\n#include \"cctk_Arguments.h\"\n#include \"cctk_Parameters.h\"\n\n#include \"SampleBnd.h\"\n\n/* the rcs ID and its dummy function to use it */\nstatic const char *rcsid = \"$Header$\";\nCCTK_FILEVERSION(CactusExamples_SampleBoundary_Register_c);\n\n/********************************************************************\n ********************    External Routines   ************************\n ********************************************************************/\n\n/*@@\n   @routine    SampleBoundary_RegisterBCs\n   @date       6 May 2003\n   @author     David Rideout\n   @desc\n               Register all the boundary conditions that this thorn provides\n   @enddesc\n\n   @var        CCTK_ARGUMENTS\n   @vdesc      standard Cactus argument list\n   @vtype      various\n   @vio        in\n   @endvar\n\n   @calls      Boundary_RegisterPhysicalBC\n\n   @returntype int\n   @returndesc\n               return code of @seeroutine Boundary_RegisterPhysicalBC <BR>\n               0 for success\n   @endreturndesc\n@@*/\n\nvoid SampleBoundary_RegisterBCs(CCTK_ARGUMENTS)\n{\n  DECLARE_CCTK_ARGUMENTS;\n  \n  int ierr;\n\n  /* Register the linear extrapolation boundary condition */\n  ierr = Boundary_RegisterPhysicalBC(cctkGH, \n                                     (CCTK_INT (*) (CCTK_POINTER_TO_CONST,\n                                                    CCTK_INT,\n                                                    CCTK_INT *,\n                                                    CCTK_INT *,\n                                                    CCTK_INT *,\n                                                    CCTK_INT *)) BndLinExtrap,\n                                     \"LinearExtrap\");\n  if (ierr < 0)\n  {\n    CCTK_WARN(0, \"Failed to register LinearExtrap boundary condition\");\n  }\n}",
    "build_result": {
      "success": true,
      "return_code": 0,
      "stdout": "Cactus - version: 4.2.3\nSetup configuration SampleBoundary (yes)?\nSetup of configuration SampleBoundary cancelled\n",
      "stderr": "",
      "clean_output": "Please specify a configuration to clean.\n",
      "clean_error": ""
    },
    "test_result": {
      "total_tests": 1,
      "passed_tests": 0,
      "failed_tests": 1,
      "test_results": [
        {
          "test_name": "wavetoyc",
          "passed": false,
          "return_code": 127,
          "output_length": 0,
          "error_length": 46
        }
      ]
    },
    "score_result": {
      "overall_score": 50.0,
      "build_score": 40,
      "test_run_score": 10,
      "test_accuracy_score": 0.0,
      "breakdown": {
        "build_success": true,
        "total_tests": 1,
        "passed_tests": 0,
        "failed_tests": 1,
        "test_success_rate": 0.0,
        "tests_attempted": true
      },
      "grade": "D"
    },
    "timestamp": "2025-09-26T13:11:27.246805",
    "success": true
  },
  {
    "worker_id": 0,
    "example_index": 3,
    "thorn_name": "CactusExamples/SampleBoundary",
    "src_filename": "SampleBnd.h",
    "generated_code": "/*@@\n   @header    SampleBnd.h\n   @date      6 May 2003\n   @author    David Rideout\n   @desc \n              Header file for SampleBoundary thorn\n   @enddesc \n   @version   $Header$\n @@*/\n\n#ifndef _SAMPLEBND_H_\n#define _SAMPLEBND_H_\n\n#include \"cctk.h\"\n\n#ifdef __cplusplus\nextern \"C\" \n{\n#endif\n\n/* Function pointer type for physical boundary conditions */\ntypedef int (*phys_bc_fn_ptr)(const cGH *GH, \n                              int num_vars, \n                              int *var_indices, \n                              int *faces, \n                              int *boundary_widths, \n                              int *table_handles);\n\n/* Scheduled routine prototypes */\nvoid SampleBoundary_RegisterBCs(CCTK_ARGUMENTS);\n\n/* Boundary condition implementation prototypes */\nint BndLinExtrap(const cGH *GH, \n                 int num_vars, \n                 int *vars, \n                 int *faces, \n                 int *widths, \n                 int *tables);\n\n/* Fortran routine prototype */\nvoid CCTK_FCALL CCTK_FNAME(Linear_extrap_one_bndry)(int *doBC, \n                                                    const int *lsh, \n                                                    CCTK_REAL *var_ptr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* _SAMPLEBND_H_ */",
    "build_result": {
      "success": true,
      "return_code": 0,
      "stdout": "Cactus - version: 4.2.3\nSetup configuration SampleBoundary (yes)?\nSetup of configuration SampleBoundary cancelled\n",
      "stderr": "",
      "clean_output": "Please specify a configuration to clean.\n",
      "clean_error": ""
    },
    "test_result": {
      "total_tests": 1,
      "passed_tests": 0,
      "failed_tests": 1,
      "test_results": [
        {
          "test_name": "wavetoyc",
          "passed": false,
          "return_code": 127,
          "output_length": 0,
          "error_length": 46
        }
      ]
    },
    "score_result": {
      "overall_score": 50.0,
      "build_score": 40,
      "test_run_score": 10,
      "test_accuracy_score": 0.0,
      "breakdown": {
        "build_success": true,
        "total_tests": 1,
        "passed_tests": 0,
        "failed_tests": 1,
        "test_success_rate": 0.0,
        "tests_attempted": true
      },
      "grade": "D"
    },
    "timestamp": "2025-09-26T13:11:37.016174",
    "success": true
  },
  {
    "worker_id": 0,
    "example_index": 4,
    "thorn_name": "CactusExamples/SampleBoundary",
    "src_filename": "LinearExtrapBnd.c",
    "generated_code": "/*@@\n   @file      LinearExtrapBnd.c\n   @date      6 May 2003\n   @author    David Rideout\n   @desc \n              C wrapper for linear extrapolation boundary condition\n   @enddesc \n   @version   $Header$\n @@*/\n\n#include \"cctk.h\"\n#include \"cctk_Arguments.h\"\n#include \"cctk_Parameters.h\"\n#include \"SampleBnd.h\"\n\nstatic const char *rcsid = \"$Header$\";\n\nCCTK_FILEVERSION(CactusExamples_SampleBoundary_LinearExtrapBnd_c);\n\n/* Fortran routine prototype */\nvoid CCTK_FCALL CCTK_FNAME(Linear_extrap_one_bndry)(int *doBC, int *lsh, CCTK_REAL *var);\n\n/*@@\n   @routine    BndLinExtrap\n   @date       6 May 2003\n   @author     David Rideout\n   @desc \n               Apply linear extrapolation boundary condition to a set of variables\n   @enddesc \n   @calls      Linear_extrap_one_bndry\n   @history \n   @endhistory\n   @var        GH\n   @vdesc      Pointer to CCTK grid hierarchy\n   @vtype      const CCTK_POINTER_TO_CONST\n   @vio        in\n   @endvar\n   @var        num_vars\n   @vdesc      Number of variables to apply boundary condition to\n   @vtype      const CCTK_INT\n   @vio        in\n   @endvar\n   @var        var_indices\n   @vdesc      Array of variable indices\n   @vtype      const CCTK_INT *\n   @vio        in\n   @endvar\n   @var        faces\n   @vdesc      Array of face flags\n   @vtype      const CCTK_INT *\n   @vio        in\n   @endvar\n   @var        widths\n   @vdesc      Array of boundary widths\n   @vtype      const CCTK_INT *\n   @vio        in\n   @endvar\n   @var        table_handles\n   @vdesc      Array of table handles\n   @vtype      const CCTK_INT *\n   @vio        in\n   @endvar\n   @returntype int\n   @returndesc\n               0 for success, negative for error\n   @endreturndesc\n@@*/\n\nint BndLinExtrap(const CCTK_POINTER_TO_CONST GH, const CCTK_INT num_vars, \n                 const CCTK_INT *var_indices, const CCTK_INT *faces, \n                 const CCTK_INT *widths, const CCTK_INT *table_handles)\n{\n  const cGH *cctkGH = (const cGH *) GH;\n  int i, j;\n  int var_index;\n  int doBC[6];\n  CCTK_REAL *var_ptr;\n  int lsh[3];\n  int gdim;\n  \n  /* Check that we have a valid grid hierarchy */\n  if (!cctkGH)\n  {\n    CCTK_VWarn(1, __LINE__, __FILE__, CCTK_THORNSTRING,\n               \"BndLinExtrap: NULL pointer passed for grid hierarchy\");\n    return -1;\n  }\n  \n  /* Get grid dimension */\n  gdim = CCTK_GroupDimFromVarI(var_indices[0]);\n  \n  /* Check that we're in 3D */\n  if (gdim != 3)\n  {\n    CCTK_VWarn(1, __LINE__, __FILE__, CCTK_THORNSTRING,\n               \"BndLinExtrap: Linear extrapolation boundary condition \"\n               \"only implemented for 3D grids\");\n    return -2;\n  }\n  \n  /* Get local grid size */\n  for (i = 0; i < 3; i++)\n  {\n    lsh[i] = cctkGH->cctk_lsh[i];\n  }\n  \n  /* Check that grid is large enough */\n  for (i = 0; i < 3; i++)\n  {\n    if (lsh[i] < 3)\n    {\n      CCTK_VWarn(1, __LINE__, __FILE__, CCTK_THORNSTRING,\n                 \"BndLinExtrap: Grid too small for linear extrapolation \"\n                 \"(need at least 3 points in each direction)\");\n      return -3;\n    }\n  }\n  \n  /* Loop over all variables */\n  for (i = 0; i < num_vars; i++)\n  {\n    var_index = var_indices[i];\n    \n    /* Get pointer to variable data */\n    var_ptr = (CCTK_REAL *) CCTK_VarDataPtrI(cctkGH, 0, var_index);\n    \n    if (!var_ptr)\n    {\n      CCTK_VWarn(1, __LINE__, __FILE__, CCTK_THORNSTRING,\n                 \"BndLinExtrap: Cannot get data pointer for variable index %d\",\n                 var_index);\n      return -4;\n    }\n    \n    /* Check variable type */\n    if (CCTK_VarTypeI(var_index) != CCTK_VARIABLE_REAL)\n    {\n      CCTK_VWarn(1, __LINE__, __FILE__, CCTK_THORNSTRING,\n                 \"BndLinExtrap: Variable index %d is not of type CCTK_REAL\",\n                 var_index);\n      return -5;\n    }\n    \n    /* Set up face flags */\n    for (j = 0; j < 6; j++)\n    {\n      doBC[j] = 0;\n    }\n    \n    /* Decode faces array */\n    if (faces[i] == CCTK_ALL_FACES)\n    {\n      for (j = 0; j < 6; j++)\n      {\n        doBC[j] = 1;\n      }\n    }\n    else\n    {\n      /* faces[i] is a bitfield */\n      if (faces[i] & 0x01) doBC[0] = 1;  /* x lower */\n      if (faces[i] & 0x02) doBC[1] = 1;  /* x upper */\n      if (faces[i] & 0x04) doBC[2] = 1;  /* y lower */\n      if (faces[i] & 0x08) doBC[3] = 1;  /* y upper */\n      if (faces[i] & 0x10) doBC[4] = 1;  /* z lower */\n      if (faces[i] & 0x20) doBC[5] = 1;  /* z upper */\n    }\n    \n    /* Call Fortran routine to do the actual work */\n    CCTK_FNAME(Linear_extrap_one_bndry)(doBC, lsh, var_ptr);\n  }\n  \n  return 0;\n}",
    "build_result": {
      "success": true,
      "return_code": 0,
      "stdout": "Cactus - version: 4.2.3\nSetup configuration SampleBoundary (yes)?\nSetup of configuration SampleBoundary cancelled\n",
      "stderr": "",
      "clean_output": "Please specify a configuration to clean.\n",
      "clean_error": ""
    },
    "test_result": {
      "total_tests": 1,
      "passed_tests": 0,
      "failed_tests": 1,
      "test_results": [
        {
          "test_name": "wavetoyc",
          "passed": false,
          "return_code": 127,
          "output_length": 0,
          "error_length": 46
        }
      ]
    },
    "score_result": {
      "overall_score": 50.0,
      "build_score": 40,
      "test_run_score": 10,
      "test_accuracy_score": 0.0,
      "breakdown": {
        "build_success": true,
        "total_tests": 1,
        "passed_tests": 0,
        "failed_tests": 1,
        "test_success_rate": 0.0,
        "tests_attempted": true
      },
      "grade": "D"
    },
    "timestamp": "2025-09-26T13:12:03.350324",
    "success": true
  }
]