[
  {
    "worker_id": 0,
    "example_index": 0,
    "thorn_name": "CactusBase/Boundary",
    "src_filename": "NoneBoundary.c",
    "generated_code": "/*@@\n  @file      NoneBoundary.c\n  @date      Mon Mar 15 15:09:00 1999\n  @author    Gerd Lanfermann\n  @desc\n             Routines for applying none boundary conditions\n  @enddesc\n  @history\n  @hdate     Tue 10 Apr 2001\n  @hauthor   Thomas Radke\n  @hdesc     BC routines generalized for applying to arbitrary CCTK data types\n  @endhistory\n  @version   $Id$\n@@*/\n\n/*#define DEBUG_BOUNDARY*/\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"cctk.h\"\n#include \"util_Table.h\"\n#include \"util_ErrorCodes.h\"\n#include \"cctk_Parameters.h\"\n#include \"cctk_FortranString.h\"\n\n#include \"Boundary.h\"\n\n/* the rcs ID and its dummy function to use it */\nstatic const char *rcsid = \"$Header$\";\nCCTK_FILEVERSION(CactusBase_Boundary_NoneBoundary_c);\n\n/********************************************************************\n ********************    External Routines   ************************\n ********************************************************************/\n/*@@\n   @routine    BndNone\n   @date       13 Feb 2003\n   @author     David Rideout\n   @desc\n               Top level function which is registered as handling\n               the None boundary condition\n   @enddesc\n\n   @var        GH\n   @vdesc      Pointer to CCTK grid hierarchy\n   @vtype      const cGH *\n   @vio        in\n   @endvar\n   @var        num_vars\n   @vdesc      number of variables passed in through var_indices[]\n   @vtype      CCTK_INT\n   @vio        in\n   @endvar\n   @var        var_indices\n   @vdesc      array of variable indicies to which to apply this boundary\n               condition\n   @vtype      CCTK_INT *\n   @vio        in\n   @endvar\n   @var        faces\n   @vdesc      array of set of faces to which to apply the bc\n   @vtype      CCTK_INT\n   @vio        in\n   @endvar\n   @var        widths\n   @vdesc      array of boundary widths for each variable\n   @vtype      CCTK_INT\n   @vio        in\n   @endvar\n   @var        table_handles\n   @vdesc      array of table handles which hold extra arguments\n   @vtype      CCTK_INT\n   @vio        in\n   @endvar\n   @returntype CCTK_INT\n   @returndesc\n               return code: 0 for success\n   @endreturndesc\n@@*/\nCCTK_INT BndNone(const cGH *GH, CCTK_INT num_vars, CCTK_INT *vars,\n                 CCTK_INT *faces, CCTK_INT *widths, CCTK_INT *tables) {\n  int i;\n\n  /* avoid compiler warnings about unused parameters */\n  (void)(GH + 0);\n  (void)(faces + 0);\n  (void)(widths + 0);\n  (void)(tables + 0);\n\n  /* loop through variables */\n  for (i = 0; i < num_vars; i++) {\n    /* Check to see if faces specification is valid */\n    if (faces[i] != CCTK_ALL_FACES) {\n      CCTK_VWarn(1, __LINE__, __FILE__, CCTK_THORNSTRING,\n                 \"Faces specification %d for None boundary conditions on \"\n                 \"%s is not implemented yet.  \"\n                 \"Applying None bcs to all (external) faces.\",\n                 (int)faces[i], CCTK_VarName(vars[i]));\n    }\n  }\n\n  /* None boundary condition does nothing - just return success */\n  return 0;\n}\n\n/* prototypes for external C routines are declared in header Boundary.h\n   here only follow the fortran wrapper prototypes */\nvoid CCTK_FCALL CCTK_FNAME(BndNoneDirGI)(int *ierr, const cGH **GH,\n                                         const int *stencil_size,\n                                         const int *dir, const int *gi);\nvoid CCTK_FCALL CCTK_FNAME(BndNoneGI)(int *ierr, const cGH **GH,\n                                      const int *stencil, const int *gi);\nvoid CCTK_FCALL CCTK_FNAME(BndNoneDirGN)(int *ierr, const cGH **GH,\n                                         const int *stencil_size,\n                                         const int *dir, ONE_FORTSTRING_ARG);\nvoid CCTK_FCALL CCTK_FNAME(BndNoneGN)(int *ierr, const cGH **GH,\n                                      const int *stencil, ONE_FORTSTRING_ARG);\nvoid CCTK_FCALL CCTK_FNAME(BndNoneDirVI)(int *ierr, const cGH **GH,\n                                         const int *stencil_size,\n                                         const int *dir, const int *vi);\nvoid CCTK_FCALL CCTK_FNAME(BndNoneVI)(int *ierr, const cGH **GH,\n                                      const int *stencil, const int *vi);\nvoid CCTK_FCALL CCTK_FNAME(BndNoneDirVN)(int *ierr, const cGH **GH,\n                                         const int *stencil_size,\n                                         const int *dir, ONE_FORTSTRING_ARG);\nvoid CCTK_FCALL CCTK_FNAME(BndNoneVN)(int *ierr, const cGH **GH,\n                                      const int *stencil, ONE_FORTSTRING_ARG);\n\n/********************************************************************\n ********************    Internal Routines   ************************\n ********************************************************************/\n\n/*@@\n   @routine    BndNoneDirGI\n   @date       Sun Jan 21 2001\n   @author     Gabrielle Allen\n   @desc\n               Apply none boundary conditions by group index in given direction\n   @enddesc\n\n   @var        GH\n   @vdesc      Pointer to CCTK grid hierarchy\n   @vtype      const cGH *\n   @vio        in\n   @endvar\n   @var        stencil_size\n   @vdesc      stencil size in this direction\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        dir\n   @vdesc      direction to apply boundaries\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        gi\n   @vdesc      group index of group to apply boundary conditions to\n   @vtype      int\n   @vio        in\n   @endvar\n\n   @returntype int\n   @returndesc\n               return code of @seeroutine BndNone <BR>\n               -1 if invalid group index was passed\n   @endreturndesc\n@@*/\nint BndNoneDirGI(const cGH *GH, int stencil_size, int dir, int gi) {\n  int first_vi, retval;\n\n  first_vi = CCTK_FirstVarIndexI(gi);\n  if (first_vi >= 0) {\n    retval = BndNoneDirVI(GH, stencil_size, dir, first_vi);\n  } else {\n    CCTK_VWarn(2, __LINE__, __FILE__, CCTK_THORNSTRING,\n               \"Invalid group index %d in BndNoneDirGI\", gi);\n    retval = -1;\n  }\n\n  return (retval);\n}\n\nvoid CCTK_FCALL CCTK_FNAME(BndNoneDirGI)(int *ierr, const cGH **GH,\n                                         const int *stencil_size,\n                                         const int *dir, const int *gi) {\n  *ierr = BndNoneDirGI(*GH, *stencil_size, *dir, *gi);\n}\n\n/*@@\n   @routine    BndNoneGI\n   @date       Thu Mar  2 11:02:10 2000\n   @author     Gerd Lanfermann\n   @desc\n               Apply none boundary conditions by group index\n   @enddesc\n   @calls      BndNoneDirGI\n\n   @var        GH\n   @vdesc      Pointer to CCTK grid hierarchy\n   @vtype      const cGH *\n   @vio        in\n   @endvar\n   @var        stencil\n   @vdesc      stencil width\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        gi\n   @vdesc      group index of group to apply boundary conditions to\n   @vtype      int\n   @vio        in\n   @endvar\n\n   @returntype int\n   @returndesc\n               return code of @seeroutine BndNoneDirGI <BR>\n               -1 if invalid group index was passed\n   @endreturndesc\n@@*/\nint BndNoneGI(const cGH *GH, int stencil, int gi) {\n  int retval;\n\n  if (CCTK_GroupIndexIsValid(GH, gi)) {\n    retval = BndNoneDirGI(GH, stencil, 0, gi);\n  } else {\n    CCTK_VWarn(2, __LINE__, __FILE__, CCTK_THORNSTRING,\n               \"Invalid group index %d in BndNoneGI\", gi);\n    retval = -1;\n  }\n\n  return (retval);\n}\n\nvoid CCTK_FCALL CCTK_FNAME(BndNoneGI)(int *ierr, const cGH **GH,\n                                      const int *stencil, const int *gi) {\n  *ierr = BndNoneGI(*GH, *stencil, *gi);\n}\n\n/*@@\n   @routine    BndNoneDirGN\n   @date       Thu Mar  2 11:02:10 2000\n   @author     Gerd Lanfermann\n   @desc\n               Apply none boundary conditions by group name in given direction\n   @enddesc\n   @calls      BndNoneDirGI\n\n   @var        GH\n   @vdesc      Pointer to CCTK grid hierarchy\n   @vtype      const cGH *\n   @vio        in\n   @endvar\n   @var        stencil_size\n   @vdesc      stencil size in this direction\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        dir\n   @vdesc      direction to apply boundaries\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        gname\n   @vdesc      group name to apply boundary conditions to\n   @vtype      const char *\n   @vio        in\n   @endvar\n\n   @returntype int\n   @returndesc\n               return code of @seeroutine BndNoneDirGI <BR>\n               -1 if invalid group name was passed\n   @endreturndesc\n@@*/\nint BndNoneDirGN(const cGH *GH, int stencil_size, int dir,\n                 const char *gname) {\n  int gi, retval;\n\n  gi = CCTK_GroupIndex(gname);\n  if (gi >= 0) {\n    retval = BndNoneDirGI(GH, stencil_size, dir, gi);\n  } else {\n    CCTK_VWarn(2, __LINE__, __FILE__, CCTK_THORNSTRING,\n               \"Invalid group name '%s' in BndNoneDirGN\", gname);\n    retval = -1;\n  }\n\n  return (retval);\n}\n\nvoid CCTK_FCALL CCTK_FNAME(BndNoneDirGN)(int *ierr, const cGH **GH,\n                                         const int *stencil_size,\n                                         const int *dir,\n                                         ONE_FORTSTRING_ARG) {\n  ONE_FORTSTRING_CREATE(gname)\n  *ierr = BndNoneDirGN(*GH, *stencil_size, *dir, gname);\n  free(gname);\n}\n\n/*@@\n   @routine    BndNoneGN\n   @date       Thu Mar  2 11:02:10 2000\n   @author     Gerd Lanfermann\n   @desc\n               Apply none boundary conditions by group name\n   @enddesc\n   @calls      BndNoneGI\n\n   @var        GH\n   @vdesc      Pointer to CCTK grid hierarchy\n   @vtype      const cGH *\n   @vio        in\n   @endvar\n   @var        stencil\n   @vdesc      stencil width\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        gname\n   @vdesc      group name to apply boundary conditions to\n   @vtype      const char *\n   @vio        in\n   @endvar\n\n   @returntype int\n   @returndesc\n               return code of @seeroutine BndNoneGI <BR>\n               -1 if invalid group name was passed\n   @endreturndesc\n@@*/\nint BndNoneGN(const cGH *GH, int stencil, const char *gname) {\n  int gi, retval;\n\n  gi = CCTK_GroupIndex(gname);\n  if (gi >= 0) {\n    retval = BndNoneGI(GH, stencil, gi);\n  } else {\n    CCTK_VWarn(2, __LINE__, __FILE__, CCTK_THORNSTRING,\n               \"Invalid group name '%s' in BndNoneGN\", gname);\n    retval = -1;\n  }\n\n  return (retval);\n}\n\nvoid CCTK_FCALL CCTK_FNAME(BndNoneGN)(int *ierr, const cGH **GH,\n                                      const int *stencil,\n                                      ONE_FORTSTRING_ARG) {\n  ONE_FORTSTRING_CREATE(gname)\n  *ierr = BndNoneGN(*GH, *stencil, gname);\n  free(gname);\n}\n\n/*@@\n   @routine    BndNoneDirVI\n   @date       Thu Mar  2 11:02:10 2000\n   @author     Gerd Lanfermann\n   @desc\n               Apply none boundary conditions by variable index in given direction\n   @enddesc\n\n   @var        GH\n   @vdesc      Pointer to CCTK grid hierarchy\n   @vtype      const cGH *\n   @vio        in\n   @endvar\n   @var        stencil_size\n   @vdesc      stencil size in this direction\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        dir\n   @vdesc      direction to apply boundaries\n   @vtype      int\n   @vio        in\n   @endvar\n   @var        vi\n   @vdesc      variable index to apply boundary conditions to\n   @vtype      int\n   @vio        in\n   @endvar\n\n   @returntype int\n   @returndesc\n               return code: 0 for success\n               -1 if invalid variable index was passed\n   @endreturndesc\n@@*/\nint BndNoneDirVI(const cGH *GH, int stencil_",
    "build_result": {
      "success": true,
      "return_code": 0,
      "stdout": "Cactus - version: 4.2.3\nSetup configuration Boundary (yes)?\nSetup of configuration Boundary cancelled\n",
      "stderr": "",
      "clean_output": "Please specify a configuration to clean.\n",
      "clean_error": ""
    },
    "test_result": {
      "total_tests": 0,
      "passed_tests": 0,
      "failed_tests": 0,
      "test_results": [],
      "error": "No test files found"
    },
    "score_result": {
      "overall_score": 40.0,
      "build_score": 40,
      "test_run_score": 0.0,
      "test_accuracy_score": 0.0,
      "breakdown": {
        "build_success": true,
        "total_tests": 0,
        "passed_tests": 0,
        "failed_tests": 0,
        "test_success_rate": 0.0,
        "tests_attempted": false
      },
      "grade": "F"
    },
    "timestamp": "2025-09-26T13:05:15.770204",
    "success": true
  }
]